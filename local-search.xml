<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>孙工给的AI书签</title>
    <link href="/%E5%AD%99%E5%B7%A5%E7%BB%99%E7%9A%84AI%E4%B9%A6%E7%AD%BE.html"/>
    <url>/%E5%AD%99%E5%B7%A5%E7%BB%99%E7%9A%84AI%E4%B9%A6%E7%AD%BE.html</url>
    
    <content type="html"><![CDATA[<h1 id="AI-书签"><a href="#AI-书签" class="headerlink" title="AI 书签"></a>AI 书签</h1><p>部分平台工具是国外的平台和工具，需要挂梯子。</p><span id="more"></span><h2 id="AI-平台与工具"><a href="#AI-平台与工具" class="headerlink" title="AI 平台与工具"></a>AI 平台与工具</h2><ul><li><a href="https://platform.deepseek.com/sign_in">DeepSeek 开放平台</a> - 深度求索公司推出的AI开放平台，提供大模型API接口和开发工具</li><li><a href="https://ai2sql.io/">SQL Query Builder &amp; Generator</a> - 基于AI的SQL查询构建器和生成器，帮助用户快速生成SQL语句</li><li><a href="https://www.pulumi.com/">Pulumi</a> - 支持多种编程语言的基础设施即代码(IaC)平台，简化云资源管理</li><li><a href="https://swimm.io/">Swimm（自动文档生成）</a> - 自动生成和维护代码文档的工具，帮助团队保持文档与代码同步</li><li><a href="https://applitools.com/">Applitools （视觉测试）</a> - 基于AI的视觉测试平台，用于自动化UI测试和视觉回归测试</li><li><a href="https://mastergo.com/files/home">主页 - MasterGo</a> - 在线设计协作平台，支持团队实时协作设计</li><li><a href="https://scriptecho.cn/index.html">ScriptEcho | AI生成生产级代码 |</a> - AI驱动的代码生成工具，可生成生产级别的代码</li><li><a href="https://www.figma.com/community/plugin/842128343887142055/figma-to-code-html-tailwind-flutter-swiftui">Figma to Code (HTML, Tailwind, Flutter, SwiftUI) | Figma</a> - Figma插件，可将设计直接转换为多种框架的代码</li><li><a href="https://www.bilibili.com/video/BV1pYFQeGEUe/?vd_source=7eda77efae7e8a863552f4fa445ec247">用Figma插件,生成高质量前端页面 _ Figma AI to Code</a> - 介绍如何使用Figma AI插件生成前端代码的教程视频</li></ul><h2 id="AI-编辑器与开发工具"><a href="#AI-编辑器与开发工具" class="headerlink" title="AI 编辑器与开发工具"></a>AI 编辑器与开发工具</h2><ul><li><a href="https://www.cursor.com/cn">Cursor - The AI Code Editor</a> - 集成AI功能的代码编辑器，提供智能代码补全和生成功能</li><li><a href="https://www.cursor.com/cn/features">Features | Cursor - The AI Code Editor</a> - Cursor编辑器的功能详细介绍</li><li><a href="https://www.cursor.com/cn/settings">Settings | Cursor - The AI Code Editor</a> - Cursor编辑器的设置选项</li><li><a href="https://www.cursor.com/cn/pricing">Pricing | Cursor - The AI Code Editor</a> - Cursor编辑器的价格方案</li><li><a href="https://claude.ai/login?returnTo=/?">Claude</a> - Anthropic公司开发的AI助手，擅长自然语言处理和代码生成</li><li><a href="https://codegeex.cn/">CodeGeeX</a> - 支持多种编程语言的代码生成工具，由清华大学开发</li><li><a href="https://www.trae.com.cn/?utm_source=community&utm_medium=csdn&utm_campaign=baodeng">Trae - AI 原生 IDE</a> - 专为AI开发设计的集成开发环境</li><li><a href="https://zhuanlan.zhihu.com/p/26857011424">Claude 3.7 sonnet国内如何使用（保姆级指南）</a> - 详细介绍如何在国内使用Claude 3.7 sonnet模型的指南</li><li><a href="https://replit.com/learn/intro-to-ghostwriter">Intro to Ghostwriter</a> - Replit平台的AI编程助手Ghostwriter介绍</li><li><a href="https://otter.ai/home">Otter Notes - Otter.ai</a> - AI驱动的会议记录和笔记工具，可自动转录和总结会议内容（实测中文支持不怎么滴，垃圾）</li></ul><h2 id="本地部署大模型"><a href="#本地部署大模型" class="headerlink" title="本地部署大模型"></a>本地部署大模型</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/22439948590">本地部署大模型的工具汇总</a> - 汇总了各种用于本地部署大模型的工具和平台</li><li><a href="https://blog.csdn.net/datian1234/article/details/147249976">DeepSeek本地部署</a> - 详细介绍如何在本地部署DeepSeek大模型</li><li><a href="https://blog.csdn.net/m0_71745484/article/details/145773049">本地部署大模型的三种工具</a> - 介绍三种可用于本地部署大模型的工具</li><li><a href="https://zhuanlan.zhihu.com/p/15487902211">本地部署大型语言模型：常用工具总结和推荐</a> - 总结和推荐用于本地部署大型语言模型的常用工具</li><li><a href="https://www.bilibili.com/video/BV12TLAzuEni/?spm_id_from=333.1007.tianma.10-1-35.click&vd_source=7eda77efae7e8a863552f4fa445ec247">Langchain入门到精通实战教程</a> - Langchain框架从入门到精通的实战教程视频</li></ul><h2 id="Spring-AI"><a href="#Spring-AI" class="headerlink" title="Spring AI"></a>Spring AI</h2><p>Spring-AI-Alibaba相关资料在百炼平台分类，需要查看往下翻。</p><ul><li><a href="https://spring.io/projects/spring-ai">Spring AI</a> - Spring框架的AI扩展，简化AI应用开发</li><li><a href="https://docs.spring.io/spring-ai/reference/concepts.html">AI Concepts :: Spring AI Reference</a> - Spring AI的核心概念和参考文档</li><li><a href="https://blog.csdn.net/qq839019311/article/details/136482017">Spring AI</a> - Spring AI的详细介绍和使用方法</li><li><a href="https://blog.csdn.net/m0_74824865/article/details/145804086">Spring AI-Function Call（八）</a> - Spring AI中函数调用的详细教程</li><li><a href="https://www.bilibili.com/video/BV1WARBYoEjc?spm_id_from=333.788.recommend_more_video.-1&vd_source=7eda77efae7e8a863552f4fa445ec247">MCP协议+SpringAI实战</a> - 结合MCP协议和Spring AI的实战教程视频</li></ul><h2 id="Ollama-与-LangChain"><a href="#Ollama-与-LangChain" class="headerlink" title="Ollama 与 LangChain"></a>Ollama 与 LangChain</h2><ul><li><a href="https://www.modelscope.cn/models/Intel/ollama">Ollama 英特尔优化版 · 模型库</a> - 英特尔优化的Ollama模型库，提供高性能本地大模型部署</li><li><a href="https://ollama.com/library">library</a> - Ollama官方模型库，提供多种可下载的大模型</li><li><a href="https://ollama.com/library/qwen3">qwen3</a> - 通义千问3模型在Ollama平台的版本</li><li><a href="https://www.51cto.com/article/814847.html">LangChain4j比SpringAI强在哪？</a> - 比较LangChain4j和SpringAI的优缺点</li><li><a href="https://blog.csdn.net/weixin_43886636/article/details/147373017">LangChain4j Naive RAG</a> - LangChain4j中Naive RAG和文档分割器的使用教程</li><li><a href="https://docs.langchain4j.dev/tutorials/rag#document-parser">RAG (Retrieval-Augmented Generation) | LangChain4j</a> - LangChain4j中检索增强生成(RAG)的官方文档</li><li><a href="https://github.com/langchain4j/langchain4j/blob/main/langchain4j/src/test/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoaderTest.java">langchain4j&#x2F;langchain4j · GitHub</a> - LangChain4j的文件系统文档加载器测试代码</li><li><a href="https://juejin.cn/post/7478228124859645964">langchain4j+poi读取文档</a> - 使用LangChain4j和POI读取文档的教程</li><li><a href="https://juejin.cn/post/7484470497247428646">langchain4j的MCP讲解</a> - 探讨LangChain4j对模型上下文协议(MCP)的支持</li></ul><h2 id="MCP-相关"><a href="#MCP-相关" class="headerlink" title="MCP 相关"></a>MCP 相关</h2><ul><li><a href="https://developer.aliyun.com/article/1663774">5个开源MCP服务器：扩展AI助手能力</a> - 介绍5个开源的MCP服务器，用于扩展AI助手能力</li><li><a href="https://juejin.cn/post/7478504097395785747">Model Context Protocol(MCP) 编程极速入门简介</a> - MCP协议的快速入门指南</li><li><a href="https://smithery.ai/server/@smithery-ai/server-sequential-thinking">Sequential Thinking | Smithery</a> - Smithery平台的顺序思考服务器，基于MCP协议</li><li><a href="https://smithery.ai/">Smithery MCP 工具库</a> - Smithery提供的MCP工具库，用于构建AI应用</li><li><a href="https://modelcontextprotocol.io/introduction">Introduction - Model Context Protocol</a> - MCP协议的官方介绍文档</li><li><a href="https://github.com/modelcontextprotocol">Model Context Protocol · GitHub</a> - MCP协议的GitHub仓库</li><li><a href="https://mcp.so/">MCP Servers</a> - MCP服务器的官方平台</li><li><a href="https://mcpmarket.cn/">MCP市场</a> - 中国区的MCP市场，提供各种MCP服务和工具</li><li><a href="https://github.com/github/github-mcp-server">GitHub’s official MCP Server</a> - GitHub官方的MCP服务器实现</li><li><a href="https://github.com/modelcontextprotocol/servers?tab=readme-ov-file">Model Context Protocol Servers</a> - MCP协议服务器的官方仓库</li><li><a href="https://github.com/jingfeng-linksprite/demos/tree/main/projects/introduction-to-mcp-with-sql-agent">jingfeng-linksprite&#x2F;demos · GitHub</a> - 使用MCP和SQL代理的示例项目</li></ul><h2 id="其他-AI-工具"><a href="#其他-AI-工具" class="headerlink" title="其他 AI 工具"></a>其他 AI 工具</h2><ul><li><a href="https://grok.com/">Grok</a> - xAI公司开发的AI助手，提供实时信息访问能力</li><li><a href="https://www.deepseek.com/">DeepSeek | 深度求索</a> - 深度求索公司官网，提供AI大模型和开发工具</li><li><a href="https://platform.deepseek.com/usage">DeepSeek 开放平台</a> - DeepSeek的开放平台使用指南</li><li><a href="https://kimi.moonshot.cn/?data_source=tracer&utm_campaign=TR_D0pcUf08&utm_content=&utm_medium=%E7%99%BE%E5%BA%A6&utm_source=baidu_search&utm_term=%7Bkw_enc_utf8%7D">Kimi AI助手</a> - 月之暗面公司开发的AI助手，擅长推理和深度思考</li><li><a href="https://www.doubao.com/chat/2854679153265922">新对话 - 豆包</a> - 字节跳动开发的AI助手豆包</li><li><a href="https://pingcode.com/signup?utm_source=KB-push">PingCode</a> - 智能研发管理平台，集成了AI功能</li><li><a href="https://v3.polymersearch.com/?login_status=success">Polymer</a> - 基于AI的数据分析和可视化平台</li><li><a href="https://www.tabnine.com/">Tabnine AI Code Assistant</a> - 提供私有化部署的AI代码助手</li><li><a href="https://windsurf.com/">Windsurf (formerly Codeium)</a> - 强大的AI代码编辑器，前身为Codeium</li><li><a href="https://www.jetbrains.com/ai/">JetBrains AI Service and In-IDE AI Assistant</a> - JetBrains IDE集成的AI助手服务</li><li><a href="https://tensorflow.google.cn/?hl=zh-cn">关于TensorFlow | TensorFlow中文官网</a> - Google开发的深度学习框架TensorFlow的中文官网</li><li><a href="https://openrouter.ai/auth?callback_url=vscode://saoudrizwan.claude-dev/openrouter">OpenRouter</a> - 提供多种AI模型API的统一访问平台</li></ul><h2 id="阿里云百炼"><a href="#阿里云百炼" class="headerlink" title="阿里云百炼"></a>阿里云百炼</h2><ul><li><a href="https://bailian.console.aliyun.com/?switchAgent=11970194&productCode=p_efm&switchUserType=3#/home">百炼控制台</a> - 阿里云百炼平台的官方控制台</li><li><a href="https://help.aliyun.com/document_detail/2878644.html?spm=5176.30100617.J_3864174140.3.48447105kKLWux#table-resource-type-compare">无影AgentBay云服务-阿里云帮助中心</a> - 阿里云无影AgentBay云服务的帮助文档</li><li><a href="https://developer.aliyun.com/article/1662874">【MCP教程系列】阿里云开发者社区</a> - 使用阿里云百炼平台进行数据分析和可视化的教程</li><li><a href="https://blog.csdn.net/qq_45511726/article/details/147271491">Spring AI Alibaba 对接百炼平台大模型使用详解</a> - 详细介绍如何使用Spring AI Alibaba对接百炼平台大模型</li><li><a href="https://help.aliyun.com/zh/model-studio/spring-ai-alibaba-integrate-llm-application?scm=20140722.S_help@@%E6%96%87%E6%A1%A3@@2872834._.RL_Springai-LOC_2024NSHelpLink-OR_ser-PAR1_213e367917478928363728122ee4e5-V_4-P0_0-P1_0">使用Spring AI Alibaba集成阿里云百炼大模型应用</a> - 阿里云官方文档：使用Spring AI Alibaba集成百炼大模型</li><li><a href="https://java2ai.com/?spm=4347728f.638c0b20.0.0.23f87982NTcSMy">Spring AI Alibaba 官网</a> - Spring AI Alibaba的官方网站</li><li><a href="https://help.aliyun.com/zh/model-studio/models">模型列表</a> - 阿里云百炼平台提供的模型列表</li><li><a href="https://help.aliyun.com/zh/model-studio/model-user-guide/?spm=a2c4g.11186623.help-menu-2400256.d_0.17937095JAV4Gl">用户指南（模型）</a> - 阿里云百炼平台的模型使用指南</li></ul><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul><li><a href="https://github.com/deepseek-ai/awesome-deepseek-integration/blob/main/docs/translate.js/README_cn.md">自动翻译基于I18N</a> - 基于I18N的自动翻译工具</li><li><a href="https://zhuanlan.zhihu.com/p/722280173">用AI做数据分析：12个强力AI数据分析工具分享</a> - 介绍12个强大的AI数据分析工具</li><li><a href="https://d.aigclink.ai/?v=8f252a54730e49f4b8caf897b7ae49f6">AI方案库-传递最新AI落地解决方案｜AIGCLINK</a> - 提供最新AI落地解决方案的平台</li><li><a href="https://www.bilibili.com/video/BV1b8XHY7EqF?spm_id_from=333.788.recommend_more_video.0&vd_source=7eda77efae7e8a863552f4fa445ec247">cline开放MCP开源AI应用商店（AIAgent）</a> - 介绍cline开放MCP开源AI应用商店的视频</li><li><a href="https://blog.csdn.net/2401_85325397/article/details/145566859">Ollama + DeepSeek本地部署</a> - 详细介绍DeepSeek本地部署的教程</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目日志实践</title>
    <link href="/Go%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5.html"/>
    <url>/Go%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5.html</url>
    
    <content type="html"><![CDATA[<p>伴随着项目的成长，代码的规模越来越大、组件的关系越来越繁杂、部署的点位也越来越多，人肉运维逐渐难以维护项目的运行，日志的重要性的越发体现出来。</p><span id="more"></span><p>这次的改造涉及到项目中的多个 Go 程序，需要实现下列功能：</p><ul><li>将程序运行时的信息写入日志文件</li><li>将程序崩溃时的错误写入日志文件</li><li>日志文件可以滚动更新</li></ul><p>为了实现上述功能，使用了一些标准库和开源库，分别是：</p><ul><li>runtime: 用来获得 panic 信息</li><li><a href="https://github.com/natefinch/lumberjack">lumberjack</a>: 实现了滚动日志文件写入</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>有了上述这些库的帮助，实际上我要做的事情已经很少了，大概还有这些：</p><ul><li>配置开源库，文件大小、保存位置、保存数量等等</li><li>实现日志分级，在需要的时候开启 DEBUG，平时就输出 INFO 和 ERROR</li><li>gin 框架 recovery 时写入日志，主程序 panic 时写入日志</li></ul><p>最终的实现是这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>runlog.go</span></div><code class="language-go"><span class="token keyword">package</span> vlog<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token string">"runtime/debug"</span><span class="token string">"time"</span><span class="token string">"github.com/gin-gonic/gin"</span><span class="token string">"gopkg.in/natefinch/lumberjack.v2"</span><span class="token punctuation">)</span><span class="token keyword">var</span> RunLogger <span class="token operator">*</span>lumberjack<span class="token punctuation">.</span>Logger<span class="token keyword">var</span> VRunLogLevel RunLogLevel <span class="token operator">=</span> RL_INFO<span class="token comment">// 运行日志初始化</span><span class="token keyword">func</span> <span class="token function">InitRunLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>RunLogger <span class="token operator">=</span> <span class="token operator">&amp;</span>lumberjack<span class="token punctuation">.</span>Logger<span class="token punctuation">&#123;</span>Filename<span class="token punctuation">:</span>   <span class="token string">"./logs/col_run.log"</span><span class="token punctuation">,</span>MaxSize<span class="token punctuation">:</span>    <span class="token number">50</span><span class="token punctuation">,</span>    <span class="token comment">// mb</span>MaxBackups<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    <span class="token comment">// 最大文件保留</span>MaxAge<span class="token punctuation">:</span>     <span class="token number">30</span><span class="token punctuation">,</span>    <span class="token comment">// 最大天数保留</span>LocalTime<span class="token punctuation">:</span>  <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 使用UTC时间</span>Compress<span class="token punctuation">:</span>   <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 不压缩</span><span class="token punctuation">&#125;</span><span class="token function">RunLog</span><span class="token punctuation">(</span>RL_INFO<span class="token punctuation">,</span> <span class="token string">"运行日志初始化..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 日志等级</span><span class="token keyword">type</span> RunLogLevel <span class="token builtin">int</span><span class="token keyword">const</span> <span class="token punctuation">(</span>RL_DEBUG RunLogLevel <span class="token operator">=</span> <span class="token boolean">iota</span>RL_INFORL_ERROR<span class="token punctuation">)</span><span class="token comment">// 写入日志</span><span class="token keyword">func</span> <span class="token function">RunLog</span><span class="token punctuation">(</span>level RunLogLevel<span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> a <span class="token operator">...</span>any<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> level <span class="token operator">&lt;</span> VRunLogLevel <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取当前时间</span>now <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>timeStr <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"[%d-%02d-%02d %02d:%02d:%02d.%03d] "</span><span class="token punctuation">,</span>now<span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>now<span class="token punctuation">.</span><span class="token function">Hour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Minute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>now<span class="token punctuation">.</span><span class="token function">Nanosecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token comment">// 日志等级</span><span class="token keyword">var</span> levelStr <span class="token builtin">string</span><span class="token keyword">switch</span> level <span class="token punctuation">&#123;</span><span class="token keyword">case</span> RL_DEBUG<span class="token punctuation">:</span>levelStr <span class="token operator">=</span> <span class="token string">"[DEBUG] "</span><span class="token keyword">case</span> RL_INFO<span class="token punctuation">:</span>levelStr <span class="token operator">=</span> <span class="token string">"[INFO] "</span><span class="token keyword">case</span> RL_ERROR<span class="token punctuation">:</span>levelStr <span class="token operator">=</span> <span class="token string">"[ERROR] "</span><span class="token punctuation">&#125;</span><span class="token comment">// 写入日志</span>RunLogger<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>timeStr <span class="token operator">+</span> levelStr <span class="token operator">+</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> a<span class="token operator">...</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>timeStr <span class="token operator">+</span> levelStr <span class="token operator">+</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> a<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// WEB恢复</span><span class="token keyword">func</span> <span class="token function">WebRecovery</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// 记录错误信息，可以使用自己喜欢的日志库</span><span class="token function">RunLog</span><span class="token punctuation">(</span>RL_ERROR<span class="token punctuation">,</span> <span class="token string">"发生panic:\n%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>stack <span class="token operator">:=</span> debug<span class="token punctuation">.</span><span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">RunLog</span><span class="token punctuation">(</span>RL_ERROR<span class="token punctuation">,</span> <span class="token string">"调用栈信息:\n%s"</span><span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token comment">// 设置响应状态码为500</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusInternalServerError<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"error"</span><span class="token punctuation">:</span> <span class="token string">"内部服务器错误"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 继续执行下一个中间件或路由处理函数</span>c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Panic 记录</span><span class="token keyword">func</span> <span class="token function">LogPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>stack <span class="token operator">:=</span> debug<span class="token punctuation">.</span><span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">RunLog</span><span class="token punctuation">(</span>RL_ERROR<span class="token punctuation">,</span> <span class="token string">"主程序异常退出"</span><span class="token punctuation">)</span><span class="token function">RunLog</span><span class="token punctuation">(</span>RL_ERROR<span class="token punctuation">,</span> <span class="token string">"调用栈信息:\n%s"</span><span class="token punctuation">,</span> stack<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在使用日志服务前，需要进行全局初始化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>main.go</span></div><code class="language-go"><span class="token comment">// ...</span>vlog<span class="token punctuation">.</span><span class="token function">InitRunLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><code>WebRecovery</code> 是写给 <code>gin</code> 框架的回调，用来记录 <code>HTTP</code> 服务执行过程中发生的 panic，使用时需要配置到 <code>gin</code> 框架中，用法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>web.go</span></div><code class="language-go">r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span>vlog<span class="token punctuation">.</span><span class="token function">WebRecovery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gin<span class="token punctuation">.</span><span class="token function">LoggerWithConfig</span><span class="token punctuation">(</span>gin<span class="token punctuation">.</span>LoggerConfig<span class="token punctuation">&#123;</span>Output<span class="token punctuation">:</span> vlog<span class="token punctuation">.</span>RunLogger<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果程序本身崩溃了，那么也需要记录到日志中，可以通过 main 函数的 defer 实现这一点：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>main.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">defer</span> vlog<span class="token punctuation">.</span><span class="token function">LogPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 其他初始化</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>DEBUG 等级的日志正常不会被记录或显示，可以在程序运行时通过 flag 开启，如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>main.go</span></div><code class="language-go">debug <span class="token operator">:=</span> flag<span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token string">"debug"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"是否开启调试模式"</span><span class="token punctuation">)</span>flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">*</span>debug <span class="token punctuation">&#123;</span>vlog<span class="token punctuation">.</span>VRunLogLevel <span class="token operator">=</span> vlog<span class="token punctuation">.</span>RL_DEBUG<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后，我们可以在程序各处埋点，添加不同级别的日志，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>task.go</span></div><code class="language-go">vlog<span class="token punctuation">.</span><span class="token function">RunLog</span><span class="token punctuation">(</span>vlog<span class="token punctuation">.</span>RL_INFO<span class="token punctuation">,</span> <span class="token string">"任务线程初始化..."</span><span class="token punctuation">)</span><span class="token comment">// ...</span>vlog<span class="token punctuation">.</span><span class="token function">RunLog</span><span class="token punctuation">(</span>vlog<span class="token punctuation">.</span>RL_ERROR<span class="token punctuation">,</span> <span class="token string">"[任务循环] License校验失败"</span><span class="token operator">+</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github常见用法示例</title>
    <link href="/github%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B.html"/>
    <url>/github%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B.html</url>
    
    <content type="html"><![CDATA[<p>本文总结了一些 github 最常见的使用场景，包括：</p><ul><li>使用他人的项目</li><li>创建自己的项目</li><li>参与他人的项目</li><li>维护分支</li></ul><span id="more"></span><h1 id="使用他人项目使用——clone"><a href="#使用他人项目使用——clone" class="headerlink" title="使用他人项目使用——clone"></a>使用他人项目使用——clone</h1><p>项目代码是在 github 网站上的，我们要将网站上的代码下载到本地，可以<code>点击网站仓库中的下载按钮</code>，也可以使用 <code>git clone</code> 操作。</p><p>点击下载按钮会直接下载一个项目仓库的 ZIP 包，解压就可以使用，这种是不会在本地创建一个仓库的，也就是说您获得的是纯粹的源码。</p><p>而使用 <code>git clone</code> 操作会获得一个带有 .git 文件夹的项目，这样您就会得到一个带版本控制功能的仓库！</p><h2 id="更新项目——pull"><a href="#更新项目——pull" class="headerlink" title="更新项目——pull"></a>更新项目——pull</h2><p>使用 <code>git clone</code> 操作后，您就可以使用 <code>git pull</code> 命令更新项目了。</p><p><code>git pull</code> 命令会从远程仓库拉取最新的代码，并合并到当前分支中，这样您就可以获得项目作者提供的各种更新。</p><h1 id="创建自己的项目"><a href="#创建自己的项目" class="headerlink" title="创建自己的项目"></a>创建自己的项目</h1><p>可以在 github 网站创建自己的项目仓库，之后使用 <code>git clone</code> 命令克隆到本地，就可以使用 git 管理自己的项目了。</p><h2 id="提交修改——add、commit"><a href="#提交修改——add、commit" class="headerlink" title="提交修改——add、commit"></a>提交修改——add、commit</h2><p><code>git clone</code> 命令会在本地建立一个仓库，那么对项目的修改也应该首先提交到本地，之后再推送到 github。</p><p>使用 <code>git add</code> 命令将修改的文件添加到暂存区，使用 <code>git commit</code> 命令将暂存区的修改提交到本地仓库。</p><h2 id="推送修改——push"><a href="#推送修改——push" class="headerlink" title="推送修改——push"></a>推送修改——push</h2><p>使用 <code>git push</code> 命令可以将本地仓库的修改推送到 github。</p><h1 id="参与他人的项目——fork"><a href="#参与他人的项目——fork" class="headerlink" title="参与他人的项目——fork"></a>参与他人的项目——fork</h1><p>这里分为两种情况，如果您只是想要稍微改动他人的项目自己使用，那么您只需要下载、修改、使用就可以了。（需要注意项目的 License 是否允许您这么做）</p><p>但是如果您想要参与项目，贡献代码，那么一般的流程是这样：</p><h2 id="和作者沟通您的想法——issue"><a href="#和作者沟通您的想法——issue" class="headerlink" title="和作者沟通您的想法——issue"></a>和作者沟通您的想法——issue</h2><p><code>issue</code> 在 github 的项目页面里，就像一个论坛，您可以直接发 issue 和作者沟通想法。也许您的想法并不符合项目的方向，也许您的想法作者已经考虑到了，总之在参与项目之前先沟通总是个好习惯。</p><h2 id="创建属于您的仓库——fork"><a href="#创建属于您的仓库——fork" class="headerlink" title="创建属于您的仓库——fork"></a>创建属于您的仓库——fork</h2><p>使用 github 页面上的 <code>fork</code> 按钮可以创建一个属于您的项目仓库，这个仓库会标记 <code>forked from xxxx</code>，您可以 clone 这个仓库，进行修改，随后 commit 提交，随您喜欢。</p><p>如果您只是想维护一个自己的分支，那么这样就足够了，但是如果您想将您的修改推送到项目主仓库，那么还需要一个操作：</p><h2 id="贡献修改——pull-request"><a href="#贡献修改——pull-request" class="headerlink" title="贡献修改——pull request"></a>贡献修改——pull request</h2><p>当您将本地的修改使用 <code>git commit</code> <code>git push</code> 推送到您的 fork 仓库后，github 页面上会看到一个 <code>open Pull Request</code> 的按钮，可以将您的修改请求推送给主仓库。如果主仓库的持有者同意，那么您的修改就会被合并到主仓库中，您也就完成了一次代码贡献。</p><h1 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h1><p>当然，假设您需要——在本地拥有两个分支（branch），一个用来同步线上的主仓库，另一个用来维护自己的修改，同时两个仓库都接受主仓库的更新，那么您可以：</p><h2 id="创建分支——branch"><a href="#创建分支——branch" class="headerlink" title="创建分支——branch"></a>创建分支——branch</h2><p>使用 <code>git branch</code> 命令可以创建一个分支，例如 <code>git branch zh</code> 会创建一个名为 <code>zh</code> 的分支。</p><h2 id="切换分支——checkout"><a href="#切换分支——checkout" class="headerlink" title="切换分支——checkout"></a>切换分支——checkout</h2><p>使用 <code>git checkout</code> 命令可以切换到某个分支，例如 <code>git checkout zh</code> 会切换到 <code>zh</code> 分支。</p><p>使用 <code>git branch</code> 会显示本地仓库的分支列表，以及当前正在使用的分支。</p><h2 id="追踪主仓库的更新"><a href="#追踪主仓库的更新" class="headerlink" title="追踪主仓库的更新"></a>追踪主仓库的更新</h2><p>假设主仓库为：</p><ul><li>xxx&#x2F;master</li></ul><p>而我们的仓库是：</p><ul><li>vc&#x2F;master （从主仓库 fork）</li><li>vc&#x2F;zh （这是我们自己创建的分支）</li></ul><p>主仓库更新后，我们可以在 github 页面（vc&#x2F;master）点击 <code>Update branch</code> 按钮，这样会让我们的 master 分支获得最新的代码。</p><p>随后我们需要在本地使用 <code>git pull</code> 命令拉取主仓库的更新，这样我们本地的 vc&#x2F;master 分支也会获得最新的代码。</p><h3 id="合并分支——merge"><a href="#合并分支——merge" class="headerlink" title="合并分支——merge"></a>合并分支——merge</h3><p>使用 <code>git checkout zh</code> 命令切换到我们自己的修改分支，使用 <code>git merge master</code> 命令将主仓库的更新合并到当前分支中。</p><p>这样我们自行修改的分支也会获得最新的代码。</p>]]></content>
    
    
    <categories>
      
      <category>豆知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>豆知识</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]无痛项目进度表</title>
    <link href="/%E6%97%A0%E7%97%9B%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E8%A1%A8.html"/>
    <url>/%E6%97%A0%E7%97%9B%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.joelonsoftware.com/2000/03/29/painless-software-schedules/">Painless Software Schedules</a></p></blockquote><span id="more"></span><p>去年十月，美国东北充满了 Acela 的广告，这是一条从波士顿到华盛顿的新高铁。电视里、海报上和路边广告牌随处可见，您 <em>可能</em> 会觉得这些宣传会给美国高铁拉来更多的生意。</p><p>好吧，可能会，但可惜的是美国高铁没机会进行验证了。Acela 的运行一次又一次延期，甚至直到营销活动结束，高铁也没开通。这让我想起了曾经的一位市场经理，他的宣传工作取得了巨大的成功，但是距离产品上市还有一个月：“宣发完美！但是他妈的这东西根本 <em>买不到</em>！”</p><div style="display: flex;justify-content:space-around;">  <p style="width: 50%;">    有些酷炫狂拽屌炸天的游戏公司喜欢在他们的官网上宣布他们的下一款游戏的发布时间是“制作完成后”。——进度表？哥们才不在乎什么进度表！哥们是最酷的游戏程序员！——好吧，但是大部分公司没资格这样干。您可以去问问 Lotus，当他们第一次对 123 3.0 版本进行宣发时，需要客户配置 80286 计算机，在当时这还是挺先进的稀有配置。随后他们的产品跳票了 16 个月（为了适应 8086 计算机的 640K 内存限制），等到他们完成时，微软的 Excel 已经发布了 16 个月了。（而且，讽刺的是，8086 在那时已经过时了）  </p>  <div style="width: 20%;"></div>  <img src="/无痛项目进度表/Yale_Sterling_Library.png" style="width: 66%;box-shadow: 5px 5px 10px #ccc;"></div><p>在我写这篇文章时，Netscape 5.0 浏览器已经跳票两年了。其中大部分原因要归功于他们犯了一个自杀式的错误——抛弃所有的代码然后从零开始开发——同样的错误也注定了 Ashton-Tate、Lotus 和苹果的 MacOS 被扫入历史的垃圾堆。Netscape 眼睁睁的看着他们的市场份额从 80% 掉落到 20%，但是他们根本没法还击，因为此时此刻他们的核心软件产品已经被拆解成了一千个零部件平铺在地上等待组装。单单这一个错误就超过了其他所有的决策失败，成功的成为了 Netscape 引爆自己的核弹。（Jamie Zawinski 的那篇 <a href="http://www.jwz.org/gruntle/nomo.html">举世闻名的小作文</a> 中有详细说明）</p><p><strong>因此，您必须制定进度表。</strong>即便不想做项目进度表已经成了所有程序员的共识。在我的经验里，绝大多数程序员会完全逃避制作进度表，少数程序员则是在老板的要求下勉强的、半推半就的、不情不愿的、制作了一份及其含糊其辞的进度表。实际上除了高层管理以外，从一开始就 <em>没人拿这个进度表当回事</em> 。（顺带提一句，这帮高管们还坚信 UFO 是真实存在的）</p><p>所以为什么大家都讨厌做项目进度表？有两个关键原因。第一，做项目进度表很痛苦。第二，大家都觉得项目进度表没用。如果说项目进度表最终没办法体现项目的进度，那为什么我们还要为此费力呢？既然大家都觉得项目进度表没用，而且随着项目的推进会错的越来越离谱，那为啥还要费力气做进度表呢？</p><p><strong>以下是一个简单、无痛、有效的项目进度表编写方法</strong></p><p><strong>1) 就用 Excel。</strong>不要整 Microsoft Project 这样的花活。Microsoft Project 这种工具的最大问题是您需要花很多时间来处理所谓的“依赖关系”，也就是项目中不同任务的先后次序。而我发现在软件项目中依赖关系非常显而易见，没必要专门去进行管理。</p><p>Project 的另一个问题是他假设您需要一个“一键重排进度表”的按钮，这个功能则不可避免地将工作重新分配给不同的人。对于软件项目来说，这个功能是完全不可用的，程序员的工作具有极大的连续性，而非即插即用。让 John 去修复 Rita 的 bug 会比让 Rita 自己来修复多消耗 7 倍的工时。假设您安排您的 UI 师傅去处理 WinSock 问题的话，那么她大概率需要先花两周时间去学习新知识。总而言之，Project 是给盖大楼项目用的管理软件，而不是给软件项目用的。</p><p><strong>2）保持简单。</strong>我的项目进度表的基础格式甚至您看一眼就可以记住，只需要 7 列：</p><div style="width: 100%;display: flex;justify-content:center;margin-bottom: 18px;">  <img src="/无痛项目进度表/Painless_Software_Schedules.png" style="width: 100%;box-shadow: 5px 5px 10px #ccc;"></div><p>如果您有多个开发人员，您可以给他们每个人安排一个 sheet，或者您也可以添加一列用来记录任务负责人。</p><p><strong>3）每个功能都应由若干任务构成。</strong>功能就是类似于在“程序中添加拼写检查”这种东西。而“添加拼写检查”这件事则由一系列需要程序员执行的小任务组成。编写项目进度表最重要的工作就是要列出这些任务清单。核心规则包括：</p><p><strong>4）让干活的程序员来评估工时。</strong>任何由管理层编造进度表，要求程序员去执行的项目都是注定失败的。只有具体去实施的程序员才能搞清楚完成任务需要哪些步骤，因此也只有干活的程序员自己能弄明白每个任务需要多长时间。</p><p><strong>5）任务时间精度要足够小。</strong>这是让进度表能生效的绝招。您的任务必须按小时计时，而非按天计时。（当我看到一个进度表以天为单位安排任务，或者甚至以周为单位，我就知道这东西根本不真实）。您是不是觉得任务时间精度高的收益只是 <em>统计更加精准</em>？错了！大错特错！当您尝试将大块的目标拆分成精细的目标时，您会发现得到的结果和之前<strong>全然不同</strong>，不仅仅是任务被更加细分，甚至 <em>总工时也全然不同</em>。这究竟是怎么回事？</p><p>当您开始拆分细颗粒度任务时，您实际上是在强迫自己真正思考功能实现的步骤。编写 <em>foo</em> 子程序、创建某某对话框、读取 wawa 文件等等。这些任务的工时很容易预估，因为您真的编写过子程序、创建过对话框、也读取过 wawa 文件。</p><p>相反，如果您粗心大意的安排“整块”任务（“实现语法纠正”），其实表示了 <em>您没有仔细思考过要做什么</em>。而如果您没有思考过要做什么，那么您当然无法获得准确的工时预估。</p><p>根据经验，每个任务应该在 2 到 16 小时之间。如果您的进度表上有一个 40 小时（一周）的任务，说明您的分解还不够细。</p><p>拆分细颗粒度任务还有另一个原因：这将强迫您去 <em>设计</em> 该死的功能。如果您只有一个随手写的 “互联网集成” 功能而且您安排了 3 周的工时，哥们你完了。如果您 <strong>必须搞清楚需要编写哪些子程序</strong>，那么您就必须要 <strong>确定</strong> 这个功能内容。通过（被迫）在编写项目进度表时的提前计划，您可以排除软件项目中的许多不确定因素。</p><div style="width: 100%;display: flex;justify-content:center;margin-bottom: 18px;">  <img src="/无痛项目进度表/New_Haven_Flower_Vendor.png" style="width: 100%;box-shadow: 5px 5px 10px #ccc;"></div><p><strong>6）持续跟踪原始预估工时和当前预估工时。</strong>当您第一次将某个任务添加到进度表时，请估算任务需要的工时并将其填入原始预估（OrigEst）和当前预估（CurrEst）两列中。随着时间的流逝，如果您觉得某个任务所需的工时大于或小于您所想的，您可以随时更新当前预估的值。这是您通过时间学会工时估算的最好方式。大部分程序员不知道该如何预估工时，没关系，您只需要不断地尝试，不断地更新进度表，最终都能学会。（您可能必须砍掉某些功能或是延迟发布，但是进度表仍然在起作用，至少他能够告诉您何时需要砍掉功能或是做好延迟发布的准备）。据我观察，大部分程序员大约需要一年的时间来学会较为准确的评估工时。</p><p>在任务完成时，当前预估列和已用时间（Elapsed）列的值应当相同，而剩余时间（Remain）列则会自动计算为0.</p><p><strong>7）每天更新已用时间。</strong>您无需掐着秒表编程，只需要在回家之前（或者对于那些极客就是在桌子下面睡觉之前），假装您已经工作了八小时，回头想想您今天做了哪些工作，然后在已用时间中把这八小时加上。剩余时间列则会被 Excel 自动计算。</p><p>同时，根据现实情况来更新当前预估工时。<em>每天更新进度表大概只需要消耗您两分钟时间</em>，这就是为啥我把这个方法叫做 <strong>无痛进度表方法</strong>——又快又简单。</p><p><strong>8）为休假和节假日添加条目。</strong>如果您的项目需要一年的时间，那么每个程序员都可能会有 10 - 15 天用于休假。您应该在进度表中添加休假和节假日，以及任何其他的导致程序员不上班的事项。随后您可以通过加总剩余时间列后除以 40 的方式来计算出发布日期——也就是剩余多少周的时间，包含所有事情在内。</p><p><strong>9）将调试时间加入进度表！</strong>调试时间是最难估算的。回头想想您的上一个项目吧。调试所用的时间很可能会是开发所用时间的 100% – 200%。调试必须在进度表中有一席之地，而且很可能是占用最多时间的内容。</p><p>调试时间是这样用的。假设有一个程序哥正在进行 wawa 功能的开发，原始预估工时是 16 小时，但至今为止他已经工作了 20 小时而且看起来还需要额外的 10 个小时。因此程序哥在当前预估列中输入 30 并且在已用时间中输入 20。</p><p>在项目快要到达节点时，所有这些 “延期” 加在一起可能已经积累了很多。理论上，为了赶上项目节点，我们必须砍掉一些功能。幸运的是，我们之前已经预留了一个测试条目，并且预留的时间非常充足，很适合被砍。</p><p>原则上，每一个程序员都应该在写编写代码后就地测试。程序员们永远不应该在还有 bug 需要处理的情况下去编写新的代码。bug 遗留的数量必须越少越好，有两个原因：</p><ol><li><p>在写代码的当天修复 bug 更容易。而在一个月后，当您已经忘记代码具体如何工作时，修复 bug 可能会非常困难和耗时。</p></li><li><p>修复 bug 就像做科研，您无法估计何时会有突破并解决 bug。如果任何时候只有一两个未解决的 bug，就很容易估算产品的交付时间，因为剩余需要科研的内容就那么点。另一方面，如果您有数百或数千个未解决的 bug，就不可能预测他们何时能被全部修复。</p></li></ol><p>如果程序员们总是一边开发一边 debug，那么为啥我们还需要为调试预留大量时间呢？好吧，实际上即使您在开发时已经修复了所有您已经发现的bug，到了每个里程碑节点的时候，您的产品仍将不可避免的会被测试人员（公司内部的或是 beta 客户）发现一些 <em>真正难搞</em> 的 bug。</p><p><strong>10）将集成时间加入进度表。</strong>如果您的团队超过一名程序员，那么不可避免的，他们产出的内容会存在冲突。有可能是他们都为了类似的功能各自实现了对话框。需要有人负责检查所有的菜单、快捷键、工具栏等等…清理和组织大家随意添加的各种菜单项。当两个程序员一起提交代码时编译器可能会出现编译错误。这些都需要修复，而且应该作为进度表中的一个条目。</p><p><strong>11）在进度表中加入缓冲（buffer）时间。</strong>事情的发展总是和我们预想的不同，至少有两种重要的缓冲您需要考虑。第一：为那些实际消耗时间比原始预估时间更长的任务预留缓冲。第二：为那些您没有考虑到的工作预留缓冲，例如管理层临时决定将 wawa 作为软件的<strong>重要功能</strong>而且必须在此版本发布。</p><p>您可能会发现：休假、节假日、测试、集成和缓冲的时间加起来比实际开发时间多得多。如果您对此感到惊讶，那说明您编程的时间还不长，对吧？忽视这些后果自负。</p><p><strong>12）永远不要允许管理层压缩程序员预估的工期。</strong>很多菜鸟经理觉得通过压缩工期可以“激励”程序员来尽快完成工作，我觉得这帮人就是纯弱智。实际上当我的进度落后于进度表时，我只会感觉到沮丧、没动力、项目注定失败。进度表不是给这些弱智玩心理游戏的地方。</p><p>如果您的上级执意要您压缩工期，您可以试试这个办法：在进度表中创建一个新的列叫做 <strong>Rick 的预估工期</strong>（这里假设您就是 Rick），在其中填入您对项目工期的预估。此后把 <strong>当前预估时间</strong> 列交由您的上级处置，随便他怎么填。当项目结束后，再看看谁的预估时间更加接近现实情况。我发现只需要和上级 <em>提及</em> 这个想法就能有效地威慑他们，特别是当他们意识到这种比较实际上就是在 <em>比谁工作的更慢</em> 的时候。</p><p>为什么无能的领导总在试图压缩程序员的工期？</p><p>在项目开始时，技术管理人员和商务开会，最后列出一份 <em>他觉得</em> 能在 3 个月内完成的功能清单，但实际需要 9 个月。当您只需要考虑架构层面的东西而并不考虑所有的实现步骤时，往往您觉得需要 <em>n</em> 天的工作，实际上大约需要 <em>3n</em> 天。随后当您开始编写项目进度表时，您将所有的步骤都写入表中然后逐渐意识到所需的时间远远超过预期。现实情况逐渐浮出水面。</p><p>无能的领导这时候灵光一闪，心想：<em>如果我能让程序员们工作得更快，那么我就能让他们在 3 个月内完成工作！</em> 好吧，然而这并不现实。随后他又想到也许可以招聘更多人来工作，但招来的人需要适应，需要熟悉项目，在最初几个月的时间里这些新来的哥们往往只能产出 50% 的生产力（而且还得让现有的熟练工花时间带他们）。不管怎么说吧，据我观察，现在新招的程序员往往要半年时间才能达到满产状态。</p><p>您可以通过对程序严格考核来增加大约 10% 的产出，这带来的结果就是让他们筋疲力尽。收益很小，长期亏损很大，这种行为就像是农民把留种的种子吃掉一样愚蠢。</p><p>您也可以通过让程序员 996 来增加大约 20% 的产出。boom！<em>bug 率超高</em>，<em>调试时间翻倍</em>，<em>半年内离职率激增</em>，而且您失去的都是那些高产员工，留下一群工作表演艺术家陪您 996 奋斗（毕竟真正工作的大脑不可能一天高强度运行 12 小时）。最后您得到的是延期的项目、低效的团队、破产的公司。一种绝妙的因果报应的方式适得其反。</p><p>无论怎么样，您都不可能在 <em>n</em> 个时间里产出 <em>3n</em> 的工作量，如果您仍然坚信您可以，那么请赶快把您公司的股票代码告诉我，我现在就去做空。</p><p><strong>13）进度表就像木块。</strong>如果您有一堆木块，然后无法把他们装进一个盒子里，那么您只有两个选择：要么换一个大点的盒子，要么就是放弃一些木块。如果您需要在 6 个月内交付产品，但您的进度表上却有 12 个月，您要么延期交付，要么就是删除一些功能。您就是没办法压缩那些木块，如果您假装可以，那么实际上您也只是在对自己看到的事实说谎，剥夺了自己 <em>真正面对问题</em> 的机会。</p><p>而且您也已经了解了，维护进度表的另一个好处是 <strong>强迫</strong> 您删除一些功能。为啥说这这是好处呢？假设您有两个功能：其中一个真的很有用而且会让您的产品走的更远（例如：Netscape 2.0 中的表格），另一个则是简单又好玩，程序员们非常想要加进去（例如：BLINK 标签），但是这玩意实际上没啥用，对市场也没啥帮助。</p><p>如果您没有项目进度表，程序员们总是会先去实现那些简单又好玩的功能。他们会在这些游乐场里耗尽所有的时间，一直到最后，您不得不为了那些有用又重要的功能延期。</p><p>而如果您制定了项目进度表，那么在工作开始前，您就会意识到您必须砍掉一部分功能（来保证交期），因此您当然会保留那些有用又重要的功能，砍掉那些简单又好玩的功能。通过强迫自己在功能之间做出选择，您最终会获得一个更强大，更好的产品，组合了最最重要的功能，而且能够按时发布。</p><p>我记得在开发 Excel 5 的时候，我们最初计划的功能列表无比庞大，会远远的超过预定的工期。当时我们觉得这些功能都是超级重要的功能！没有宏编辑向导我们怎么活啊？！</p><p>事实证明，我们别无选择，最终我们把进度表砍的只剩骨架，每个人都对这些功能被砍感到不快。为了安抚我们自己，我们告诉自己这些功能只重要性稍低，将延后到 Excel 6 再实现。</p><div style="width: 100%;display: flex;align-items: flex-start;">  <img src="/无痛项目进度表/Fall_in_New_Haven.png" style="width: 100%;box-shadow: 5px 5px 10px #ccc;">  <div style="width:60%;margin-left: 20px;">    <p>当 Excel 5 接近完成时，我开始和同事 Eric Michelman 一起制定 Excel 6 的规格。我们坐下来查看从 Excel 5 进度表中削减的"Excel 6"功能列表。我们完全震惊地发现，被削减的功能列表是我们能想象到的最糟糕的功列表。这些功能没有一个值得做。我认为即使在接下来的三个版本中，这些功能中也没有一个被实现。为适应进度表而筛选功能是我们能做的最好的事情。如果我们没有这样做，Excel 5 会花费两倍的时间，并包含 50% 无用的垃圾功能。（我完全确信这正是 Netscape 5/Mozilla 发生的事情：他们没有进度表，没有明确的功能列表，没人愿意削减任何功能，他们就是没有发布。当他们发布时，他们会有很多像 IRC 客户端这样他们根本不应该花时间的次要功能。）</p>  </div></div><p><strong>附录：关于 Excel 您应该知道的事情</strong></p><p>Excel 之所以成为处理软件进度表的绝佳产品，原因之一是大多数 Excel 开发者使用 Excel 的唯一目的就是维护他们的软件进度表！（他们中没多少人在运行业务假设情景分析…这里说的是程序员！）</p><p><strong>共享列表</strong> 使用文件&#x2F;共享列表命令允许每个人同时打开文件并同时编辑内容。由于您的整个团队应该持续更新进度表，这真的很有帮助。</p><p><strong>自动筛选</strong> 这是筛选进度表的好方法，例如，您只看到分配给您的所有功能。结合自动排序，您可以看到按优先级排序的分配给您的所有功能，这实际上就是您的”待办事项”列表。很酷！</p><p><strong>数据透视表</strong> 这是查看汇总和交叉表的好方法。例如，您可以制作一个图表，显示每个开发人员在每个优先级上的剩余时间。数据透视表就像切片面包和巧克力奶昔。您必须学会如何使用它们，因为它们让 Excel 的功能强大了一百万倍。</p><p><strong>WORKDAY 函数</strong> 是Excel 分析工具包中的无痛进度表中获取日历日期的好方法。</p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>软件项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>底层原理与新鲜工具</title>
    <link href="/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%96%B0%E9%B2%9C%E5%B7%A5%E5%85%B7.html"/>
    <url>/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%96%B0%E9%B2%9C%E5%B7%A5%E5%85%B7.html</url>
    
    <content type="html"><![CDATA[<p>在大众眼中，程序员们似乎总有着这样的形象：他们一直在钻研某些技术的底层实现、他们一直在探索解决问题的新鲜工具。然而，对于那些与工作切实相关，被程序员称为“业务”的部分——他们却常常不屑一顾：“这不过是为了工资不得不做的事”。</p><span id="more"></span><h1 id="底层原理？"><a href="#底层原理？" class="headerlink" title="底层原理？"></a>底层原理？</h1><p>经过一段时间的工作后，我逐渐发现所谓的“底层原理”并非是一个固定的范围，而是一类知识的统称，具有以下三个特点：</p><ul><li>我的当前工作所依赖的</li><li>我的知识范围能够触及的</li><li>我有兴趣去学习的</li></ul><p>“底层原理”就是这么个很主观的东西：业务员觉得运维支持老哥很底层、运维老哥觉得开发人员很底层、开发人员觉得做编译器的人很底层、编译器老哥觉得做操作系统的很底层、操作系统老哥……好吧，他们真的很底层，但是他们也依赖于CPU老哥、CPU老哥依赖于研究半导体和芯片制造的老哥、然后这些人又依赖于物理学家和数学家。</p><p>我们都有好奇心，每当好奇心推动我们去探索一些事物的时候，我们就把这些事物称为“底层原理”，其实就是这样。</p><h1 id="新鲜工具"><a href="#新鲜工具" class="headerlink" title="新鲜工具"></a>新鲜工具</h1><p>不同于底层原理带来的缓慢提升，新鲜工具则是能立竿见影的带来收益，当然，也伴随着风险。</p><p>我觉得最好的获取新鲜工具的过程是这样的：</p><ul><li>在做业务的过程中，遇到了一个棘手的问题</li><li>自己尝试去解决，在这个过程中经历了很多思考</li><li>领导点拨或突然偶遇新鲜工具，感慨是最佳实践，从此豁然开朗</li></ul><p>只有先经历过问题和思考，才能深刻理解答案的珍贵。从我自己的经验来看，第一次接触 redis、MQTT、时序库的时候，都曾给我带来如梦初醒的感觉。</p><h1 id="业务的价值"><a href="#业务的价值" class="headerlink" title="业务的价值"></a>业务的价值</h1><p>因此，业务的价值也不仅仅是完成本分并拿到工资，更重要的是在业务开发的过程中，驱使着我们的好奇心去探索“底层”，给我们设置难题促使我们找寻“工具”，进而一步一步的实现更有价值的自己。</p>]]></content>
    
    
    <categories>
      
      <category>想想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>想想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署Prometheus并监控Caddy</title>
    <link href="/%E9%83%A8%E7%BD%B2Prometheus%E5%B9%B6%E7%9B%91%E6%8E%A7Caddy.html"/>
    <url>/%E9%83%A8%E7%BD%B2Prometheus%E5%B9%B6%E7%9B%91%E6%8E%A7Caddy.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://prometheus.io/">普罗米修斯（Prometheus）</a> 是一套开源的监控系统，可以用来监控并存储软件程序运行中的各项指标。</p><span id="more"></span><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><a href="https://prometheus.io/download/">下载</a>、解压。</p><p>修改文件夹中的 <code>prometheus.yml</code>，配置对自身指标的监控：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><div class="caption"><span>prometheus.yml</span></div><code class="language-yaml"><span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span>     15s <span class="token comment"># By default, scrape targets every 15 seconds.</span>  <span class="token comment"># Attach these labels to any time series or alerts when communicating with</span>  <span class="token comment"># external systems (federation, remote storage, Alertmanager).</span>  <span class="token key atrule">external_labels</span><span class="token punctuation">:</span>    <span class="token key atrule">monitor</span><span class="token punctuation">:</span> <span class="token string">'codelab-monitor'</span><span class="token comment"># A scrape configuration containing exactly one endpoint to scrape:</span><span class="token comment"># Here it's Prometheus itself.</span><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token comment"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>    <span class="token comment"># Override the global default and scrape targets from this job every 5 seconds.</span>    <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>运行 <code>prometheus</code>，默认服务端口号即为 9090，已经可以通过 WEB 查看服务。</p><h1 id="查看指标"><a href="#查看指标" class="headerlink" title="查看指标"></a>查看指标</h1><p>通过<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">表达式（expression）</a> 筛选想要查询的内容，例如 <code>prometheus_target_interval_length_seconds</code> 用来查询普罗米修斯对系统每次指标采集的间隔。</p><h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><p><code>表达式&#123;key=&quot;value&quot;&#125;</code> 的方式筛选，例如 <code>&#123;job=&quot;prometheus&quot;, quantile=&quot;0.99&quot;&#125;</code>，表示采集任务是 prometheus（监控自己），获得其中 0.99 分位数的指标（即 99% 的数据延迟都低于该值）。</p><h1 id="监控Caddy"><a href="#监控Caddy" class="headerlink" title="监控Caddy"></a>监控Caddy</h1><p>Caddy 中的 admin 服务已经按照<a href="https://prometheus.io/docs/instrumenting/exposition_formats/#text-based-format">普罗米修斯指标标准</a>实现了一套监控指标，只需在全局选项中打开：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">&#123;    servers &#123;        metrics    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后在普罗米修斯中添加任务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><div class="caption"><span>prometheus.yml</span></div><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> caddy    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:2019'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>之后就能用表达式查看 caddy 提供的数据，例如这样的：<code>go_gc_duration_seconds&#123;job=&quot;caddy&quot;&#125;</code>。</p><h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><p>指标监控是各种系统中都非常常见的一项需求，而普罗米修斯提供了一套标准化的解决方案。</p><p>至于能否在生产环境中满足具体项目的指标要求，则还是需要在项目开始前对具体情况进行考察和测试。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
      <tag>caddy</tag>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[解决]在NAT背后使用Caddy提供HTTPS服务</title>
    <link href="/%5B%E8%A7%A3%E5%86%B3%5D%E5%9C%A8NAT%E8%83%8C%E5%90%8E%E4%BD%BF%E7%94%A8Caddy%E6%8F%90%E4%BE%9BHTTPS%E6%9C%8D%E5%8A%A1.html"/>
    <url>/%5B%E8%A7%A3%E5%86%B3%5D%E5%9C%A8NAT%E8%83%8C%E5%90%8E%E4%BD%BF%E7%94%A8Caddy%E6%8F%90%E4%BE%9BHTTPS%E6%9C%8D%E5%8A%A1.html</url>
    
    <content type="html"><![CDATA[<p>在 <a href="/%5B%E9%97%AE%E9%A2%98%5D%E5%9C%A8NAT%E8%83%8C%E5%90%8E%E4%BD%BF%E7%94%A8Caddy%E6%8F%90%E4%BE%9BHTTPS%E6%9C%8D%E5%8A%A1">问题</a> 的最后，我突然想到可以用 frp 代理一个 HTTP 服务出去，这样虽然不能使用 https 的功能，但是起码可以访问其他的基础功能。</p><span id="more"></span><p>于是我做了这个：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">http:&#x2F;&#x2F;192.168.34.197:10443 &#123;        encode zstd gzip        reverse_proxy https:&#x2F;&#x2F;192.168.34.197 &#123;                header_up Host &#123;upstream_hostport&#125;                transport http &#123;                        tls_insecure_skip_verify                &#125;        &#125;&#125;https:&#x2F;&#x2F;192.168.34.197 &#123;        encode zstd gzip        tls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>发现只能内网访问，通过 frp 代理地址还是不能访问（只有 HTTP ok，没有内容）。</p><p>这个事实一下就打破了我原有的想法，我原本以为是网络和 TLS 问题，现在看来不是，然后注意到 <code>http://192.168.34.197:10443</code>，我开始怀疑是 caddy 的路由没匹配上。</p><p>改成 <code>:10443</code> 后，frp 可用了。</p><p>后来把 Caddyfile 改成这样，直接按端口提供服务，一切问题都解决了：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">:443 &#123;        encode zstd gzip        tls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>也不需要按照浏览器的公网地址生成证书，反正都是信任不安全的证书，只要用内网地址生成一个证书就可以了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实 Caddy 的<a href="https://caddyserver.com/docs/caddyfile/concepts#addresses">文档</a>中早有说明：</p><blockquote><p>If you specify a hostname, only requests with a matching <code>Host</code> header will be honored. In other words, if the site address is <code>localhost</code>, then Caddy will not match requests to <code>127.0.0.1</code>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>HTTPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>运维</tag>
      
      <tag>HTTPS</tag>
      
      <tag>caddy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[问题]在NAT背后使用Caddy提供HTTPS服务</title>
    <link href="/%5B%E9%97%AE%E9%A2%98%5D%E5%9C%A8NAT%E8%83%8C%E5%90%8E%E4%BD%BF%E7%94%A8Caddy%E6%8F%90%E4%BE%9BHTTPS%E6%9C%8D%E5%8A%A1.html"/>
    <url>/%5B%E9%97%AE%E9%A2%98%5D%E5%9C%A8NAT%E8%83%8C%E5%90%8E%E4%BD%BF%E7%94%A8Caddy%E6%8F%90%E4%BE%9BHTTPS%E6%9C%8D%E5%8A%A1.html</url>
    
    <content type="html"><![CDATA[<p>前段时间，我尝试了 <a href="/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0HTTPS%E6%94%AF%E6%8C%81">在内网中使用 HTTPS 部署</a>，但立刻就在随后的实践中发现了一个问题。</p><span id="more"></span><p>我的领导告诉我，客户并不想运行我的证书安装程序，客户只是想打开浏览器输入地址就可以访问系统（因为这样比较方便）。</p><p>于是我就使用服务器的内网地址签发了一张证书，这样在内网通过 <code>https://ip</code> 的方式就可以访问系统了，虽然浏览器会提示不安全，但是所有功能也都可以正常使用，问题就算解决了。</p><p>随后，我想把这个服务通过一台路由设备代理到外网，也通过 https 访问，这样我可以方便的进行一些运维测试之类的工作。我就这样掉进了坑里。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>涉及到的设备包括：</p><ul><li>公网客户端（有公网地址的普通电脑一台）</li><li>路由器（用来做 NAT，只有基本的 NAT 能力）</li><li>服务器（在内网提供服务）</li></ul><p>涉及到的网络地址包括：</p><ul><li>路由器公网地址：36.33.xx.xx</li><li>路由器内网地址：192.168.34.1</li><li>服务器内网地址：192.168.34.197</li></ul><p>当前已经可以在内网使用 <code>https://192.168.34.197</code> 访问服务，目标是通过配置路由器 NAT 和服务器上的 caddy，使公网客户端可以使用 <code>https://36.33.xx.xx</code> 访问服务。</p><p><em>公网地址的 443 端口确定可用，之前测试过</em></p><h1 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h1><h3 id="公网地址-443-端口代理到服务器-443"><a href="#公网地址-443-端口代理到服务器-443" class="headerlink" title="公网地址 443 端口代理到服务器 443"></a>公网地址 443 端口代理到服务器 443</h3><p>最开始的思路比较简单，直接配置路由器将公网 443 端口映射到服务器 443 端口。</p><p>Caddyfile的配置也很简单：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">https:&#x2F;&#x2F;192.168.34.197 &#123;encode zstd gziptls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这种情况下，浏览器在报安全验证之后就可以进入网页，但请求不返回任何内容。观察 <code>response</code> 发现：</p><ul><li>content-length: 0</li><li>server: Caddy</li></ul><p>服务到达了 caddy，但是没有提供网站内容，接下来查看 caddy 的日志发现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token date number">2024/10/30</span> <span class="token time number">07:05:56.420</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">http.stdlib</span>http<span class="token operator">:</span> TLS handshake error from 36<span class="token punctuation">.</span>33<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token operator">:</span><span class="token number">65222</span><span class="token operator">:</span> remote error<span class="token operator">:</span> tls<span class="token operator">:</span> unknown certificate<span class="token date number">2024/10/30</span> <span class="token time number">07:05:56.422</span><span class="token level debug keyword">DEBUG</span>eventsevent<span class="token operator">&#123;</span><span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"tls_get_certificate"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token string">"9a9f30ec-e627-48e4-b7ee-52beb6bad236"</span><span class="token punctuation">,</span> <span class="token string">"origin"</span><span class="token operator">:</span> <span class="token string">"tls"</span><span class="token punctuation">,</span> <span class="token string">"data"</span><span class="token operator">:</span> <span class="token operator">&#123;</span><span class="token string">"client_hello"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"CipherSuites"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">10794</span><span class="token punctuation">,</span><span class="token number">4865</span><span class="token punctuation">,</span><span class="token number">4866</span><span class="token punctuation">,</span><span class="token number">4867</span><span class="token punctuation">,</span><span class="token number">49195</span><span class="token punctuation">,</span><span class="token number">49199</span><span class="token punctuation">,</span><span class="token number">49196</span><span class="token punctuation">,</span><span class="token number">49200</span><span class="token punctuation">,</span><span class="token number">52393</span><span class="token punctuation">,</span><span class="token number">52392</span><span class="token punctuation">,</span><span class="token number">49171</span><span class="token punctuation">,</span><span class="token number">49172</span><span class="token punctuation">,</span><span class="token number">156</span><span class="token punctuation">,</span><span class="token number">157</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">,</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"ServerName"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"SupportedCurves"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">64250</span><span class="token punctuation">,</span><span class="token number">25497</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"SupportedPoints"</span><span class="token operator">:</span><span class="token string">"AA=="</span><span class="token punctuation">,</span><span class="token string">"SignatureSchemes"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1027</span><span class="token punctuation">,</span><span class="token number">2052</span><span class="token punctuation">,</span><span class="token number">1025</span><span class="token punctuation">,</span><span class="token number">1283</span><span class="token punctuation">,</span><span class="token number">2053</span><span class="token punctuation">,</span><span class="token number">1281</span><span class="token punctuation">,</span><span class="token number">2054</span><span class="token punctuation">,</span><span class="token number">1537</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"SupportedProtos"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"h2"</span><span class="token punctuation">,</span><span class="token string">"http/1.1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"SupportedVersions"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">60138</span><span class="token punctuation">,</span><span class="token number">772</span><span class="token punctuation">,</span><span class="token number">771</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"RemoteAddr"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"IP"</span><span class="token operator">:</span><span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span><span class="token string">"Port"</span><span class="token operator">:</span><span class="token number">65223</span><span class="token punctuation">,</span><span class="token string">"Zone"</span><span class="token operator">:</span><span class="token string">""</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token string">"LocalAddr"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"IP"</span><span class="token operator">:</span><span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span><span class="token string">"Port"</span><span class="token operator">:</span><span class="token number">443</span><span class="token punctuation">,</span><span class="token string">"Zone"</span><span class="token operator">:</span><span class="token string">""</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:05:56.422</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.handshake</span>choosing certificate<span class="token operator">&#123;</span><span class="token string">"identifier"</span><span class="token operator">:</span> <span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span> <span class="token string">"num_choices"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:05:56.422</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.handshake</span>default certificate selection results<span class="token operator">&#123;</span><span class="token string">"identifier"</span><span class="token operator">:</span> <span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span> <span class="token string">"subjects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span> <span class="token string">"*.192.168.34.197"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"managed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"issuer_key"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"00c8e2e97b167d3f278fe71d0a962cd29174fec485fe2c00f25bb718e345f961"</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:05:56.422</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.handshake</span>matched certificate in cache<span class="token operator">&#123;</span><span class="token string">"remote_ip"</span><span class="token operator">:</span> <span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span> <span class="token string">"remote_port"</span><span class="token operator">:</span> <span class="token string">"65223"</span><span class="token punctuation">,</span> <span class="token string">"subjects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span> <span class="token string">"*.192.168.34.197"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"managed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"expiration"</span><span class="token operator">:</span> <span class="token string">"2094/10/31 03:05:40.000"</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"00c8e2e97b167d3f278fe71d0a962cd29174fec485fe2c00f25bb718e345f961"</span><span class="token operator">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>从日志里可以看到 <code>remote error: tls: unknown certificate</code>，我猜想是客户端不认证书，然后看到证书的 subjects 是 <code>192.168.34.197</code>，我就觉得是因为客户端输入的地址和证书提供的 CN 或者 SAN 不匹配导致的问题。</p><p>然后我就觉得，如果服务器能够提供 <code>36.33.xx.xx</code> 的证书就好了。</p><h3 id="使用公网地址的证书"><a href="#使用公网地址的证书" class="headerlink" title="使用公网地址的证书"></a>使用公网地址的证书</h3><p>然后就按照公网地址制作了证书，修改 Caddyfile：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">https:&#x2F;&#x2F;192.168.34.197 &#123;encode zstd gziptls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;3633xxxx-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;3633xxxx-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这下连 443 端口都没起来，查看日志是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token date number">2024/10/30</span> <span class="token time number">07:16:40.600</span><span class="token level warning important">WARN</span>tlsstapling OCSP<span class="token operator">&#123;</span><span class="token string">"error"</span><span class="token operator">:</span> <span class="token string">"no OCSP stapling for [36.33.xx.xx *.36.33.xx.xx]: no OCSP server specified in certificate"</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:16:40.600</span><span class="token level debug keyword">DEBUG</span>eventsevent<span class="token operator">&#123;</span><span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"cached_unmanaged_cert"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token string">"ca1f1002-a94b-4af4-a7fe-a88960129791"</span><span class="token punctuation">,</span> <span class="token string">"origin"</span><span class="token operator">:</span> <span class="token string">"tls"</span><span class="token punctuation">,</span> <span class="token string">"data"</span><span class="token operator">:</span> <span class="token operator">&#123;</span><span class="token string">"sans"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span><span class="token string">"*.36.33.xx.xx"</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:16:40.600</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.cache</span>added certificate to cache<span class="token operator">&#123;</span><span class="token string">"subjects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span> <span class="token string">"*.36.33.xx.xx"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"expiration"</span><span class="token operator">:</span> <span class="token string">"2094/10/31 03:01:19.000"</span><span class="token punctuation">,</span> <span class="token string">"managed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"issuer_key"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"15f7c42ab20c2daa817947d6d066a353fea00e6e69e2c873c33d3ebd2542257a"</span><span class="token punctuation">,</span> <span class="token string">"cache_size"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"cache_capacity"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:16:40.600</span><span class="token level info keyword">INFO</span>http<span class="token punctuation">.</span>auto_httpsenabling automatic HTTP<span class="token operator">-</span><span class="token operator">></span>HTTPS redirects<span class="token operator">&#123;</span><span class="token string">"server_name"</span><span class="token operator">:</span> <span class="token string">"srv0"</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:16:40.600</span><span class="token level debug keyword">DEBUG</span>http<span class="token punctuation">.</span>auto_httpsadjusted config<span class="token operator">&#123;</span><span class="token string">"tls"</span><span class="token operator">:</span> <span class="token operator">&#123;</span><span class="token string">"automation"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"policies"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"subjects"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"192.168.34.197"</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token punctuation">,</span> <span class="token string">"http"</span><span class="token operator">:</span> <span class="token operator">&#123;</span><span class="token string">"servers"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"remaining_auto_https_redirects"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"listen"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">":80"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"routes"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token string">"srv0"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"listen"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">":443"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"routes"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"handle"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"handler"</span><span class="token operator">:</span><span class="token string">"subroute"</span><span class="token punctuation">,</span><span class="token string">"routes"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"handle"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"encodings"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"gzip"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token string">"zstd"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token string">"handler"</span><span class="token operator">:</span><span class="token string">"encode"</span><span class="token punctuation">,</span><span class="token string">"prefer"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"zstd"</span><span class="token punctuation">,</span><span class="token string">"gzip"</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token string">"handler"</span><span class="token operator">:</span><span class="token string">"subroute"</span><span class="token punctuation">,</span><span class="token string">"routes"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"handle"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"handler"</span><span class="token operator">:</span><span class="token string">"vars"</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token operator">:</span><span class="token string">"/home/caddy/herong/web/dist"</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token string">"handler"</span><span class="token operator">:</span><span class="token string">"file_server"</span><span class="token punctuation">,</span><span class="token string">"hide"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"./Caddyfile"</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"terminal"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"tls_connection_policies"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">&#123;</span><span class="token string">"match"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"sni"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"192.168.34.197"</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token string">"certificate_selection"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"any_tag"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"cert0"</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"automatic_https"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>怀疑是证书中的地址和 caddy 配置中的地址对不上。</p><p>于是就再签了一张 SAN 同时包括两个地址的证书。</p><h3 id="同时包含公网和私网的证书"><a href="#同时包含公网和私网的证书" class="headerlink" title="同时包含公网和私网的证书"></a>同时包含公网和私网的证书</h3><p>制作了 CN 为 <code>36.33.xx.xx</code>，SAN 同时包括 <code>36.33.xx.xx</code> 和 <code>192.168.34.197</code> 的证书，使用后 443 端口算是能够起来了，caddy 配置文件也只改了证书：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">https:&#x2F;&#x2F;192.168.34.197 &#123;encode zstd gziptls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;3633xxxxw197-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;3633xxxxw197-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但是！客户端访问的问题依然存在，问题现象也和之前一模一样。只不过这次从客户端看到的证书的 CN 和 SAN 都是 <code>36.33.xx.xx</code>，这一点倒是符合预期。</p><p>查看 caddy 的日志，发现连报错都一样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token date number">2024/10/30</span> <span class="token time number">07:25:45.013</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">http.stdlib</span>http<span class="token operator">:</span> TLS handshake error from 36<span class="token punctuation">.</span>33<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token operator">:</span><span class="token number">49913</span><span class="token operator">:</span> remote error<span class="token operator">:</span> tls<span class="token operator">:</span> unknown certificate<span class="token date number">2024/10/30</span> <span class="token time number">07:25:45.015</span><span class="token level debug keyword">DEBUG</span>eventsevent<span class="token operator">&#123;</span><span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"tls_get_certificate"</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token string">"aa9a98f8-1058-4331-a1d9-e642f0645cf4"</span><span class="token punctuation">,</span> <span class="token string">"origin"</span><span class="token operator">:</span> <span class="token string">"tls"</span><span class="token punctuation">,</span> <span class="token string">"data"</span><span class="token operator">:</span> <span class="token operator">&#123;</span><span class="token string">"client_hello"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"CipherSuites"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">19018</span><span class="token punctuation">,</span><span class="token number">4865</span><span class="token punctuation">,</span><span class="token number">4866</span><span class="token punctuation">,</span><span class="token number">4867</span><span class="token punctuation">,</span><span class="token number">49195</span><span class="token punctuation">,</span><span class="token number">49199</span><span class="token punctuation">,</span><span class="token number">49196</span><span class="token punctuation">,</span><span class="token number">49200</span><span class="token punctuation">,</span><span class="token number">52393</span><span class="token punctuation">,</span><span class="token number">52392</span><span class="token punctuation">,</span><span class="token number">49171</span><span class="token punctuation">,</span><span class="token number">49172</span><span class="token punctuation">,</span><span class="token number">156</span><span class="token punctuation">,</span><span class="token number">157</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">,</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"ServerName"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"SupportedCurves"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">60138</span><span class="token punctuation">,</span><span class="token number">25497</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"SupportedPoints"</span><span class="token operator">:</span><span class="token string">"AA=="</span><span class="token punctuation">,</span><span class="token string">"SignatureSchemes"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1027</span><span class="token punctuation">,</span><span class="token number">2052</span><span class="token punctuation">,</span><span class="token number">1025</span><span class="token punctuation">,</span><span class="token number">1283</span><span class="token punctuation">,</span><span class="token number">2053</span><span class="token punctuation">,</span><span class="token number">1281</span><span class="token punctuation">,</span><span class="token number">2054</span><span class="token punctuation">,</span><span class="token number">1537</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"SupportedProtos"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"h2"</span><span class="token punctuation">,</span><span class="token string">"http/1.1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"SupportedVersions"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">51914</span><span class="token punctuation">,</span><span class="token number">772</span><span class="token punctuation">,</span><span class="token number">771</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"RemoteAddr"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"IP"</span><span class="token operator">:</span><span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span><span class="token string">"Port"</span><span class="token operator">:</span><span class="token number">49914</span><span class="token punctuation">,</span><span class="token string">"Zone"</span><span class="token operator">:</span><span class="token string">""</span><span class="token operator">&#125;</span><span class="token punctuation">,</span><span class="token string">"LocalAddr"</span><span class="token operator">:</span><span class="token operator">&#123;</span><span class="token string">"IP"</span><span class="token operator">:</span><span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span><span class="token string">"Port"</span><span class="token operator">:</span><span class="token number">443</span><span class="token punctuation">,</span><span class="token string">"Zone"</span><span class="token operator">:</span><span class="token string">""</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:25:45.015</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.handshake</span>choosing certificate<span class="token operator">&#123;</span><span class="token string">"identifier"</span><span class="token operator">:</span> <span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span> <span class="token string">"num_choices"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:25:45.015</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.handshake</span>default certificate selection results<span class="token operator">&#123;</span><span class="token string">"identifier"</span><span class="token operator">:</span> <span class="token string">"192.168.34.197"</span><span class="token punctuation">,</span> <span class="token string">"subjects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span> <span class="token string">"192.168.34.197"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"managed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"issuer_key"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"109ba9582f4bde945134e6794168af4c947a3cdf6d0391388cb09310fb811def"</span><span class="token operator">&#125;</span><span class="token date number">2024/10/30</span> <span class="token time number">07:25:45.015</span><span class="token level debug keyword">DEBUG</span><span class="token domain constant">tls.handshake</span>matched certificate in cache<span class="token operator">&#123;</span><span class="token string">"remote_ip"</span><span class="token operator">:</span> <span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span> <span class="token string">"remote_port"</span><span class="token operator">:</span> <span class="token string">"49914"</span><span class="token punctuation">,</span> <span class="token string">"subjects"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"36.33.xx.xx"</span><span class="token punctuation">,</span> <span class="token string">"192.168.34.197"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"managed"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"expiration"</span><span class="token operator">:</span> <span class="token string">"2094/10/31 07:24:23.000"</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token operator">:</span> <span class="token string">"109ba9582f4bde945134e6794168af4c947a3cdf6d0391388cb09310fb811def"</span><span class="token operator">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="其他的失败尝试"><a href="#其他的失败尝试" class="headerlink" title="其他的失败尝试"></a>其他的失败尝试</h3><p>例如另起一个服务端口，然后使用反向代理提供服务：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">https:&#x2F;&#x2F;192.168.34.197:10443 &#123;        encode zstd gzip        tls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;3633xxxx-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;3633xxxx-key.pem        reverse_proxy https:&#x2F;&#x2F;192.168.34.197 &#123;                header_up Host &#123;upstream_hostport&#125;        &#125;&#125;https:&#x2F;&#x2F;192.168.34.197 &#123;encode zstd gziptls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我期望着第一个服务能够提供公网地址的证书，但是不行。</p><p>甚至用 HTTP 都不行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">http:&#x2F;&#x2F;192.168.34.197:10443 &#123;        encode zstd gzip        reverse_proxy https:&#x2F;&#x2F;192.168.34.197 &#123;                header_up Host &#123;upstream_hostport&#125;        &#125;&#125;https:&#x2F;&#x2F;192.168.34.197 &#123;        encode zstd gzip        tls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;19216834197-key.pem        handle &#123;                root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;dist                file_server        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>是不是提供 HTTPS 服务的设备必须同时拥有地址和证书？</li><li>大型企业是否会遇到这样的问题？他们是怎么解决的？是不是有相关解决方案的供应商？</li><li>如果在更低层的网络上进行编程，能否解决这个问题？例如在服务器的 TCP 层进行编程？是否已经有相关的解决方案？</li><li>好像可以用 frp 解决？？！！</li></ol>]]></content>
    
    
    <categories>
      
      <category>HTTPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>运维</tag>
      
      <tag>HTTPS</tag>
      
      <tag>caddy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB项目集成人脸识别</title>
    <link href="/WEB%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.html"/>
    <url>/WEB%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.html</url>
    
    <content type="html"><![CDATA[<p>前端开发的一大痛点就是参考资料太多，css，h5 标准，浏览器的各种规范等等。AI 的出现真的很大程度上缓解了这些问题，让我这种半桶水的前端也能够快速的定位到我需要的文档。</p><span id="more"></span><p>项目中需要让客户使用人脸识别验证身份，很自然的想到如下实现思路：</p><ol><li>浏览器调用摄像头，获得视频</li><li>视频截图，发往后端</li><li>后端将照片和系统现有用户比对</li></ol><h1 id="浏览器调用摄像头"><a href="#浏览器调用摄像头" class="headerlink" title="浏览器调用摄像头"></a>浏览器调用摄像头</h1><p>托 AI 的福，很快就查到了关键词：摄像头调用使用 <code>navigator.mediaDevices</code> 相关接口，视频播放使用 <code>video</code> 元素。</p><h1 id="视频截图"><a href="#视频截图" class="headerlink" title="视频截图"></a>视频截图</h1><p>直接用 <code>canvas</code> 把 <code>video</code> 内容画上来，当成图片发给后端就好。</p><h1 id="后端比对"><a href="#后端比对" class="headerlink" title="后端比对"></a>后端比对</h1><p>使用 github 的 <a href="https://github.com/ageitgey/face_recognition">face_recognition</a> 仓库，该仓库可以使用命令行进行人脸比对，用 go 稍微封装一下就好了。</p><p>再次感谢无数开源作者为世界做出的贡献。</p><h1 id="前端代码示例"><a href="#前端代码示例" class="headerlink" title="前端代码示例"></a>前端代码示例</h1><p>用 <code>vue2</code> 做了一个简易的人脸识别弹窗：</p><figure><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    选择您的摄像头设备    &lt;el-button-group&gt;      &lt;el-button v-for&#x3D;&quot;(camera, x) in cameras&quot; :key&#x3D;&quot;x&quot; @click&#x3D;&quot;playThis(camera)&quot;&gt;&#123;&#123; camera.label &#125;&#125;&lt;&#x2F;el-button&gt;    &lt;&#x2F;el-button-group&gt;    &lt;video id&#x3D;&quot;video&quot;&gt;&lt;&#x2F;video &gt;    &lt;canvas id&#x3D;&quot;photo&quot; width&#x3D;&quot;640&quot; height&#x3D;&quot;420&quot; &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      cameras: [], &#x2F;&#x2F; 摄像头列表      video_dom: undefined,      timeHandler: undefined    &#125;  &#125;,  mounted() &#123;    const self &#x3D; this    this.video_dom &#x3D; document.getElementById(&#39;video&#39;)    navigator.mediaDevices.enumerateDevices().then(function(devices) &#123;      devices.forEach(device &#x3D;&gt; &#123;        if (device.kind &#x3D;&#x3D;&#x3D; &#39;videoinput&#39;) &#123;          self.cameras.push(device)        &#125;      &#125;)    &#125;).catch(function(err) &#123;      alert(&#39;你的浏览器无法获摄像头设备列表&#39;)      this.$emit(&#39;cancel&#39;)    &#125;)  &#125;,  methods: &#123;    playThis(camera) &#123;      this.atClose()      const self &#x3D; this      navigator.mediaDevices.getUserMedia(&#123; video: &#123; deviceId: camera.deviceId &#125; &#125;).then(function(stream) &#123;        const video &#x3D; document.getElementById(&#39;video&#39;)        video.srcObject &#x3D; stream        video.play()        self.toPhoto()      &#125;).catch(function(err) &#123;        console.log(&#39;获取摄像头媒体流时出现错误：&#39;, err)        alert(&#39;你的浏览器无法获取此设备流&#39;)        self.$emit(&#39;cancel&#39;)      &#125;)    &#125;,    toPhoto() &#123;      let self &#x3D; this      const canvas &#x3D; document.getElementById(&#39;photo&#39;)      const context &#x3D; canvas.getContext(&#39;2d&#39;)      const video &#x3D; document.getElementById(&#39;video&#39;)      this.timeHandler &#x3D; setTimeout(function() &#123;        context.drawImage(video, 0, 0, 640, 420)        let img &#x3D; canvas.toDataURL(&#39;image&#x2F;jpg&#39;)        img &#x3D; img.split(&#39;,&#39;)[1] &#x2F;&#x2F; 照片的 base64        &#x2F;&#x2F; TODO 发到后端做人脸识别判断        self.toPhoto()      &#125;,300)    &#125;,    atClose() &#123;      clearTimeout(this.timeHandler)      const video &#x3D; document.getElementById(&#39;video&#39;)      if (video &amp;&amp; video.srcObject) &#123;        let stream &#x3D; video.srcObject        let tracks &#x3D; stream.getTracks()        tracks.forEach(function(track) &#123;            track.stop()        &#125;)        video.srcObject &#x3D; null      &#125;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot;&gt;#video &#123;  width: 640px;  height: 420px;  background: #333;  margin-top: 20px;&#125;#photo &#123;  width: 640px;  height: 420px;  display: none;&#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网项目添加HTTPS支持</title>
    <link href="/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0HTTPS%E6%94%AF%E6%8C%81.html"/>
    <url>/%E5%86%85%E7%BD%91%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0HTTPS%E6%94%AF%E6%8C%81.html</url>
    
    <content type="html"><![CDATA[<p>公司实施了一些部署在客户内网的项目，思来想去还是用 HTTPS 访问服务器比较好，既解决了很多数据安全的问题，又满足了很多浏览器功能的安全性要求。</p><span id="more"></span><p>实现路径大致如下：</p><ul><li>创建和签名SSL&#x2F;TLS证书</li><li>部署 HTTPS 服务</li><li>修改 DNS 或客户端 host，让客户端可将域名解析到服务器</li><li>客户端安装证书</li></ul><h1 id="创建和签名-SSL-TLS-证书"><a href="#创建和签名-SSL-TLS-证书" class="headerlink" title="创建和签名 SSL&#x2F;TLS 证书"></a>创建和签名 SSL&#x2F;TLS 证书</h1><blockquote><p><a href="https://www.cnblogs.com/shisuizhe/p/13712591.html">参考</a><br><a href="https://monkeywie.cn/2019/11/15/create-ssl-cert-with-san/">参考</a></p></blockquote><ul><li><p>CA私钥和自签证书</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-newkey</span> rsa:4096 <span class="token parameter variable">-days</span> <span class="token number">25568</span> <span class="token parameter variable">-keyout</span> ca-key.pem <span class="token parameter variable">-out</span> ca-cert.pem <span class="token parameter variable">-subj</span> <span class="token string">"/C=cn/ST=shenzhen/L=shenzhen/O=msj/OU=msj/CN=msj"</span>Enter PEM pass phrase:******<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>服务器私钥和请求</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req <span class="token parameter variable">-newkey</span> rsa:4096 <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-keyout</span> battery-cap-key.pem <span class="token parameter variable">-out</span> battery-cap-req.pem <span class="token parameter variable">-subj</span> <span class="token string">"/C=cn/ST=shenzhen/L=shenzhen/O=msj/OU=msj/CN=battery-cap.msj"</span> <span class="token parameter variable">-reqexts</span> SAN <span class="token parameter variable">-config</span> openssl.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>CA 签署服务器证书</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl ca <span class="token parameter variable">-in</span> battery-cap-req.pem <span class="token parameter variable">-md</span> sha256 <span class="token parameter variable">-days</span> <span class="token number">25568</span> <span class="token parameter variable">-keyfile</span> ca-key.pem <span class="token parameter variable">-cert</span> ca-cert.pem <span class="token parameter variable">-extensions</span> SAN <span class="token parameter variable">-config</span> openssl.cnf <span class="token parameter variable">-out</span> battery-cap-cert.pem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><h1 id="部署-HTTPS-服务"><a href="#部署-HTTPS-服务" class="headerlink" title="部署 HTTPS 服务"></a>部署 HTTPS 服务</h1><blockquote><p><a href="/Caddy%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B.html">参考</a></p></blockquote><p>可以先部署静态站点进行测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">battery-cap.msj &#123;encode zstd gziptls &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;battery-cap-cert.pem &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;tls&#x2F;battery-cap-key.pemhandle &#123;root * &#x2F;home&#x2F;caddy&#x2F;herong&#x2F;web&#x2F;distfile_server&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="手动修改host"><a href="#手动修改host" class="headerlink" title="手动修改host"></a>手动修改host</h1><p>C:\Windows\System32\drivers\etc\hosts</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">192.168.34.197 battery-cap.msj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="客户端手动安装证书"><a href="#客户端手动安装证书" class="headerlink" title="客户端手动安装证书"></a>客户端手动安装证书</h1><p><a href="https://wenku.csdn.net/answer/eecfaab1adcf40a3a5e8724c4e3454fe">参考</a></p><h1 id="自动修改host、安装证书"><a href="#自动修改host、安装证书" class="headerlink" title="自动修改host、安装证书"></a>自动修改host、安装证书</h1><p>通过一个程序将修改 host 文件和安装证书两件事情放到一起，方便实施同事交付。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>domain <span class="token operator">:=</span> <span class="token string">"battery-cap.msj"</span>address <span class="token operator">:=</span> <span class="token string">"192.168.34.197"</span>cert <span class="token operator">:=</span> <span class="token string">"msj-cert.pem"</span><span class="token comment">// 日志</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">"证书安装.log"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">MessageBoxPlain</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">,</span> <span class="token string">"失败"</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>logger <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span><span class="token comment">// 参数回显</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"域名："</span> <span class="token operator">+</span> domain<span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"地址："</span> <span class="token operator">+</span> address<span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"证书："</span> <span class="token operator">+</span> cert<span class="token punctuation">)</span><span class="token comment">// 改host</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"修改 host 文件"</span><span class="token punctuation">)</span>hostFile<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"C:/Windows/System32/drivers/etc/hosts"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_APPEND<span class="token punctuation">,</span> <span class="token number">0600</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">MessageBoxPlain</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">,</span> <span class="token string">"失败"</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">defer</span> hostFile<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>hostFile<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>address <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> domain <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token comment">// 安装证书</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"安装证书"</span><span class="token punctuation">)</span>cmd <span class="token operator">:=</span> exec<span class="token punctuation">.</span><span class="token function">Command</span><span class="token punctuation">(</span><span class="token string">"cmd"</span><span class="token punctuation">,</span> <span class="token string">"/C"</span><span class="token punctuation">,</span> <span class="token string">"certmgr.exe /c /add  "</span><span class="token operator">+</span>cert<span class="token operator">+</span><span class="token string">" /s root"</span><span class="token punctuation">)</span>output<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">CombinedOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">MessageBoxPlain</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">,</span> <span class="token string">"失败"</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token function">MessageBoxPlain</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">,</span> <span class="token string">"完成"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>HTTPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>运维</tag>
      
      <tag>HTTPS</tag>
      
      <tag>caddy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Ubuntu上安装SVN服务</title>
    <link href="/%E5%9C%A8Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85SVN%E6%9C%8D%E5%8A%A1.html"/>
    <url>/%E5%9C%A8Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85SVN%E6%9C%8D%E5%8A%A1.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/xiaostudy/p/11374100.html">参考</a></p><h3 id="安装-SVN-服务"><a href="#安装-SVN-服务" class="headerlink" title="安装 SVN 服务"></a>安装 SVN 服务</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> subversion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><span id="more"></span><h3 id="创建根目录文件夹"><a href="#创建根目录文件夹" class="headerlink" title="创建根目录文件夹"></a>创建根目录文件夹</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /root/svn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="创建仓库文件夹"><a href="#创建仓库文件夹" class="headerlink" title="创建仓库文件夹"></a>创建仓库文件夹</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /root/svn/shidian<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">svnadmin create /root/svn/shidian<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="仓库创建成功"><a href="#仓库创建成功" class="headerlink" title="仓库创建成功"></a>仓库创建成功</h3><p>文件夹中生成了下列内容：</p><ul><li>conf</li><li>db</li><li>format</li><li>hooks</li><li>locks</li><li>README.txt</li></ul><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>svnserve -d -r &#x2F;root&#x2F;svn –listen-port 17749</p><h3 id="创建全局的账号密码和权限文件"><a href="#创建全局的账号密码和权限文件" class="headerlink" title="创建全局的账号密码和权限文件"></a>创建全局的账号密码和权限文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> /root/svn/passwd<span class="token function">touch</span> /root/svn/authz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="添加账号密码"><a href="#添加账号密码" class="headerlink" title="添加账号密码"></a>添加账号密码</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /root/svn/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>passwd</span></div><code class="language-text">[users]user1 = password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="添加权限配置"><a href="#添加权限配置" class="headerlink" title="添加权限配置"></a>添加权限配置</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /root/svn/authz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>可按分组或按用户配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>authz</span></div><code class="language-text">[groups]coder = user1,user2[shidian:/]@coder = rw* = r[u1:/]user1 = rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="在仓库中配置鉴权"><a href="#在仓库中配置鉴权" class="headerlink" title="在仓库中配置鉴权"></a>在仓库中配置鉴权</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /root/svn/shidian/conf/svnserve.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>修改下列四行</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><div class="caption"><span>svnserve.conf</span></div><code class="language-conf">anon-access &#x3D; noneauth-access &#x3D; writepassword-db &#x3D; &#x2F;root&#x2F;svn&#x2F;passwdauthz-db &#x3D; &#x2F;root&#x2F;svn&#x2F;authz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转]netperf和iperf网络性能测试小结</title>
    <link href="/%5B%E8%BD%AC%5Dnetperf%E5%92%8Ciperf%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%BB%93.html"/>
    <url>/%5B%E8%BD%AC%5Dnetperf%E5%92%8Ciperf%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%BB%93.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://wsgzao.github.io/post/netperf/">原文</a></p><span id="more"></span><!-- <body>    <header>      <div>                    <div id="imglogo">                <a href="/"><img src="/img/logo.png" alt="HelloDog" title="HelloDog"/></a>            </div>                        <div id="textlogo">                <h1 class="site-name"><a href="/" title="HelloDog">HelloDog</a></h1>                <h2 class="blog-motto">Keep Calm and Carry On</h2>            </div>            <div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">            </a></div>            <nav class="animated">                <ul>                    <ul>                                             <li><a href="/">主页 | Home</a></li>                                            <li><a href="/index/">索引 | Index</a></li>                                            <li><a href="/archives/">归档 | Archives</a></li>                                            <li><a href="/about/">简介 | About</a></li>                                        <li>                                             <form class="search">                            <label>Search</label>                        <input type="text" id="search" class="st-default-search-input" name="q" size="30" placeholder="搜索"><br>                        </form>                                        </li>                </ul>            </nav></div>    </header>    <div id="container">      <div id="main" class="post" itemscope itemprop="blogPost">      <article itemprop="articleBody">         <header class="article-info clearfix">  <h1 itemprop="name">          <a href="/post/netperf/" title="netperf和iperf网络性能测试小结" itemprop="url">netperf和iperf网络性能测试小结</a>  </h1>  <p class="article-author">By               <a href="/about" title="wsgzao" target="_blank" itemprop="author">wsgzao</a>          <p class="article-time">    <time datetime="2019-06-27T06:59:49.000Z" itemprop="datePublished"> 发表于 2019-06-27</time>      </p></header><blockquote><p>netperf和iperf网络性能测试小结</p></blockquote><h2 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h2><p>2019年06月27日 - 初稿</p><p>阅读原文 - <a href="https://wsgzao.github.io/post/netperf/">https://wsgzao.github.io/post/netperf/</a></p><p><strong>扩展阅读</strong></p><p>netperf - <a target="_blank" rel="noopener" href="https://github.com/HewlettPackard/netperf">https://github.com/HewlettPackard/netperf</a><br>iperf - <a target="_blank" rel="noopener" href="https://github.com/esnet/iperf">https://github.com/esnet/iperf</a></p><hr><h2 id="网络性能测量的五项指标"><a href="#网络性能测量的五项指标" class="headerlink" title="网络性能测量的五项指标"></a>网络性能测量的五项指标</h2><p>可用性（availability）<br>响应时间（response time）<br>网络利用率（network utilization）<br>网络吞吐量（network throughput）<br>网络带宽容量（network bandwidth capacity）</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>测试网络性能的第一步是确定网络是否正常工作，最简单的方法是使用 ping 命令。通过向远端的机器发送 icmp echo request，并等待接收 icmp echo reply 来判断远端的机器是否连通，网络是否正常工作。</p><p>Ping 命令有非常丰富的命令选项，比如 -c 可以指定发送 echo request 的个数，-s 可以指定每次发送的 ping 包大小。</p><p>网络设备内部一般有多个缓冲池，不同的缓冲池使用不同的缓冲区大小，分别用来处理不同大小的分组（packet）。例如交换机中通常具有三种类型的包缓冲：一类针对小的分组，一类针对中等大小的分组，还有一类针对大的分组。为了测试这样的网络设备，测试工具必须要具有发送不同大小分组的能力。Ping 命令的 -s 就可以使用在这种场合。</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>Ping 命令的 echo request&#x2F;reply 一次往返所花费时间就是响应时间。有很多因素会影响到响应时间，如网段的负荷，网络主机的负荷，广播风暴，工作不正常的网络设备等等。</p><p>在网络工作正常时，记录下正常的响应时间。当用户抱怨网络的反应时间慢时，就可以将现在的响应时间与正常的响应时间对比，如果两者差值的波动很大，就能说明网络设备存在故障。</p><h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p>网络利用率是指网络被使用的时间占总时间（即被使用的时间 + 空闲的时间）的比例。比如，Ethernet 虽然是共享的，但同时却只能有一个报文在传输。因此在任一时刻，Ethernet 或者是 100% 的利用率，或者是 0% 的利用率。</p><p>计算一个网段的网络利用率相对比较容易，但是确定一个网络的利用率就比较复杂。因此，网络测试工具一般使用网络吞吐量和网络带宽容量来确定网络中两个节点之间的性能。</p><h3 id="网络吞吐量"><a href="#网络吞吐量" class="headerlink" title="网络吞吐量"></a>网络吞吐量</h3><p>网络吞吐量是指在某个时刻，在网络中的两个节点之间，提供给网络应用的剩余带宽。</p><p>网络吞吐量可以帮助寻找网络路径中的瓶颈。比如，即使 client 和 server 都被分别连接到各自的 100M Ethernet 上，但是如果这两个 100M 的 Ethernet 被 10M 的 Ethernet 连接起来，那么 10M 的 Ethernet 就是网络的瓶颈。</p><p>网络吞吐量非常依赖于当前的网络负载情况。因此，为了得到正确的网络吞吐量，最好在不同时间（一天中的不同时刻，或者一周中不同的天）分别进行测试，只有这样才能得到对网络吞吐量的全面认识。</p><p>有些网络应用程序在开发过程的测试中能够正常运行，但是到实际的网络环境中却无法正常工作（由于没有足够的网络吞吐量）。这是因为测试只是在空闲的网络环境中，没有考虑到实际的网络环境中还存在着其它的各种网络流量。所以，网络吞吐量定义为剩余带宽是有实际意义的。</p><h3 id="网络带宽容量"><a href="#网络带宽容量" class="headerlink" title="网络带宽容量"></a>网络带宽容量</h3><p>与网络吞吐量不同，网络带宽容量指的是在网络的两个节点之间的最大可用带宽。这是由组成网络的设备的能力所决定的。</p><p>测试网络带宽容量有两个困难之处：在网络存在其它网络流量的时候，如何得知网络的最大可用带宽；在测试过程中，如何对现有的网络流量不造成影响。网络测试工具一般采用 packet pairs 和 packet trains 技术来克服这样的困难。</p><h3 id="收集网络性能数据的方式"><a href="#收集网络性能数据的方式" class="headerlink" title="收集网络性能数据的方式"></a>收集网络性能数据的方式</h3><p>当确定了网络性能的测试指标以后，就需要使用网络测试工具收集相应的性能数据，分别有三种从网络获取数据的方式：</p><ol><li>通过 snmp 协议直接到网络设备中获取，如 net-snmp 工具</li><li>侦听相关的网络性能数据，典型的工具是 tcpdump</li><li>自行产生相应的测试数据，即本文中介绍的 iperf、netperf 等工具</li></ol><h2 id="Netperf"><a href="#Netperf" class="headerlink" title="Netperf"></a>Netperf</h2><p>Netperf 是一种网络性能的测量工具，主要针对基于 TCP 或 UDP 的传输。Netperf 根据应用的不同，可以进行不同模式的网络性能测试，即批量数据传输（bulk data transfer）模式和请求 &#x2F; 应答（request&#x2F;reponse）模式。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-H host</td><td>指定远端运行 netserver 的 server IP 地址</td></tr><tr><td>-l testlen</td><td>指定测试的时间长度 (秒)</td></tr><tr><td>-t testname</td><td>指定进行的测试类型 (TCP_STREAM，UDP_STREAM，TCP_RR，TCP_CRR，UDP_RR)</td></tr></tbody></table><p>可选参数有如下几个：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-s size</td><td>设置本地系统的 socket 发送与接收缓冲大小</td></tr><tr><td>-S size</td><td>设置远端系统的 socket 发送与接收缓冲大小</td></tr><tr><td>-m size</td><td>设置本地系统发送测试分组的大小</td></tr><tr><td>-M size</td><td>设置远端系统接收测试分组的大小</td></tr><tr><td>-D</td><td>对本地与远端系统的 socket 设置 TCP_NODELAY 选项</td></tr><tr><td>-r req,resp</td><td>设置 request 和 reponse 分组的大小</td></tr></tbody></table><p><strong>实例：</strong></p><p>服务器端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netserver</span><br><span class="line"></span><br></pre></div></figure></td></tr></table></figure><p>客户端：</p><p><strong>1、批量 (bulk) 网络流量的性能</strong></p><p><strong>1）TCP_STREAM</strong></p><p>Netperf 缺省情况下进行 TCP 批量传输，即 - t TCP_STREAM。测试过程中，netperf 向 netserver 发送批量的 TCP 数据分组，以确定数据传输过程中的吞吐量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -H 192.168.0.28 -l 60</span><br><span class="line">TCP STREAM TEST to 192.168.0.28</span><br><span class="line">Recv   Send    Send</span><br><span class="line">Socket Socket  Message  Elapsed</span><br><span class="line">Size   Size    Size     Time     Throughput</span><br><span class="line">bytes  bytes   bytes    secs.    10^6bits/sec</span><br><span class="line">87380  16384  16384    60.00      88.00</span><br></pre></div></figure></td></tr></table></figure><p>从 netperf 的结果输出中，我们可以知道以下的一些信息：</p><ol><li>远端系统（即 server）使用大小为 87380 字节的 socket 接收缓冲</li><li>本地系统（即 client）使用大小为 16384 字节的 socket 发送缓冲</li><li>向远端系统发送的测试分组大小为 16384 字节</li><li>测试经历的时间为 60 秒</li><li>吞吐量的测试结果表明，TCP 带宽为 88Mbits &#x2F; 秒</li></ol><p>通过修改可选参数，并观察结果的变化，我们可以确定是什么因素影响了连接的吞吐量。例如，如果怀疑路由器由于缺乏足够的缓冲区空间，使得转发大的分组时存在问题，就可以增加测试分组（-m）的大小，以观察吞吐量的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -H 192.168.0.28 -l 60 -- -m 2048</span><br><span class="line">TCP STREAM TEST to 192.168.0.28</span><br><span class="line">Recv   Send    Send</span><br><span class="line">Socket Socket  Message  Elapsed</span><br><span class="line">Size   Size    Size     Time     Throughput</span><br><span class="line">bytes  bytes   bytes    secs.    10^6bits/sec</span><br><span class="line">87380  16384   2048    60.00      87.62</span><br></pre></div></figure></td></tr></table></figure><p>在这里，测试分组的大小减少到 2048 字节，而吞吐量却没有很大的变化（与前面例子中测试分组大小为 16K 字节相比）。相反，如果吞吐量有了较大的提升，则说明在网络中间的路由器确实存在缓冲区的问题。</p><p><strong>2）UDP_STREAM</strong></p><p>UDP_STREAM 用来测试进行 UDP 批量传输时的网络性能。需要特别注意的是，此时测试分组的大小不得大于 socket 的发送与接收缓冲大小，否则 netperf 会报出错提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -t UDP_STREAM -H 192.168.0.28 -l 60</span><br><span class="line">UDP UNIDIRECTIONAL SEND TEST to 192.168.0.28</span><br><span class="line">udp_send: data send error: Message too long</span><br></pre></div></figure></td></tr></table></figure><p>为了避免这样的情况，可以通过命令行参数限定测试分组的大小，或者增加 socket 的发送 &#x2F; 接收缓冲大小。UDP_STREAM 方式使用与 TCP_STREAM 方式相同的局部命令行参数，因此，这里可以使用 - m 来修改测试中使用分组的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -t UDP_STREAM -H 192.168.0.28 -- -m 1024</span><br><span class="line">UDP UNIDIRECTIONAL SEND TEST to 192.168.0.28</span><br><span class="line">Socket  Message  Elapsed      Messages</span><br><span class="line">Size    Size     Time         Okay Errors   Throughput</span><br><span class="line">bytes   bytes    secs            #      #   10^6bits/sec</span><br><span class="line">65535    1024    9.99        114127     0      93.55</span><br><span class="line">65535             9.99        114122            93.54</span><br></pre></div></figure></td></tr></table></figure><p>UDP_STREAM 方式的结果中有两行测试数据<br>第一行显示的是本地系统的发送统计，这里的吞吐量表示 netperf 向本地 socket 发送分组的能力。但是，我们知道，UDP 是不可靠的传输协议，发送出去的分组数量不一定等于接收到的分组数量。</p><p>第二行显示的就是远端系统接收的情况，由于 client 与 server 直接连接在一起，而且网络中没有其它的流量，所以本地系统发送过去的分组几乎都被远端系统正确的接收了，远端系统的吞吐量也几乎等于本地系统的发送吞吐量。但是，在实际环境中，一般远端系统的 socket 缓冲大小不同于本地系统的 socket 缓冲区大小，而且由于 UDP 协议的不可靠性，远端系统的接收吞吐量要远远小于发送出去的吞吐量。</p><p><strong>2、请求 &#x2F; 应答 (request&#x2F;response) 网络流量的性能</strong></p><p>另一类常见的网络流量类型是应用在 client&#x2F;server 结构中的 request&#x2F;response 模式。在每次交易（transaction）中，client 向 server 发出小的查询分组，server 接收到请求，经处理后返回大的结果数据。</p><p><strong>1） TCP_RR</strong></p><p>TCP_RR 方式的测试对象是多次 TCP request 和 response 的交易过程，但是它们发生在同一个 TCP 连接中，这种模式常常出现在数据库应用中。数据库的 client 程序与 server 程序建立一个 TCP 连接以后，就在这个连接中传送数据库的多次交易过程。 用户可以通过 - r 参数来改变 request 和 response 分组的大小，进行更有实际意义的测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -t TCP_RR -H 192.168.0.28 -- -r 32,1024</span><br><span class="line">TCP REQUEST/RESPONSE TEST to 192.168.0.28</span><br><span class="line">Local /Remote</span><br><span class="line">Socket Size   Request  Resp.   Elapsed  Trans.</span><br><span class="line">Send   Recv   Size     Size    Time     Rate</span><br><span class="line">bytes  Bytes  bytes    bytes   secs.    per sec</span><br><span class="line">16384  87380  32       1024    10.00    4945.97</span><br><span class="line">16384  87380</span><br></pre></div></figure></td></tr></table></figure><p>从结果中可以看出，增加 request&#x2F;reponse 分组的大小，会导致交易率明显的下降。<br>注：相对于实际的系统，这里交易率的计算没有充分考虑到交易过程中的应用程序处理时延，因此结果往往会高于实际情况</p><p><strong>2） TCP_CRR</strong></p><p>与 TCP_RR 不同，TCP_CRR 为每次交易建立一个新的 TCP 连接。最典型的应用就是 HTTP，每次 HTTP 交易是在一条单独的 TCP 连接中进行的。因此，由于需要不停地建立新的 TCP 连接，并且在交易结束后拆除 TCP 连接，交易率一定会受到很大的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -t TCP_CRR -H 192.168.0.28</span><br><span class="line">TCP Connect/Request/Response TEST to 192.168.0.28</span><br><span class="line">Local /Remote</span><br><span class="line">Socket Size   Request  Resp.   Elapsed  Trans.</span><br><span class="line">Send   Recv   Size     Size    Time     Rate</span><br><span class="line">bytes  Bytes  bytes    bytes   secs.    per sec</span><br><span class="line">131070 131070 1        1       9.99     2662.20</span><br><span class="line">16384  87380</span><br></pre></div></figure></td></tr></table></figure><p>即使是使用一个字节的 request&#x2F;response 分组，交易率也明显的降低了，只有 2662.20 次 &#x2F; 秒。</p><p><strong>3） UDP_RR</strong></p><p>UDP_RR 方式使用 UDP 分组进行 request&#x2F;response 的交易过程。由于没有 TCP 连接所带来的负担，所以我们推测交易率一定会有相应的提升。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">#./netperf -t UDP_RR -H 192.168.0.28</span><br><span class="line">UDP REQUEST/RESPONSE TEST to 192.168.0.28</span><br><span class="line">Local /Remote</span><br><span class="line">Socket Size   Request  Resp.   Elapsed  Trans.</span><br><span class="line">Send   Recv   Size     Size    Time     Rate</span><br><span class="line">bytes  Bytes  bytes    bytes   secs.    per sec</span><br><span class="line">65535  65535  1        1       9.99     10141.16</span><br><span class="line">65535  65535</span><br></pre></div></figure></td></tr></table></figure><p>结果证实了我们的推测，交易率为 10141.16 次 &#x2F; 秒，高过 TCP_RR 的数值。不过，如果出现了相反的结果，即交易率反而降低了，也不需要担心，因为这说明了在网络中，路由器或其它的网络设备对 UDP 采用了与 TCP 不同的缓冲区空间和处理技术。</p><h2 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h2><p>iperf 是一个网络性能测试工具。iperf 可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和 UDP 特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。<br>0<br><strong>客户端与服务器共用选项</strong></p><table><thead><tr><th>命令行选项</th><th>描述</th></tr></thead><tbody><tr><td>-u</td><td>–udp：使用 UDP 方式而不是 TCP 方式。需要客户端与服务器端同时使用此参数。</td></tr><tr><td>-p</td><td>–port : 设置端口，与服务器端的监听端口一致。默认是 5001 端口。</td></tr><tr><td>-l</td><td>–len : 设置读写缓冲区的长度。TCP 方式默认为 8KB，UDP 方式默认为 1470 字节。</td></tr><tr><td>-w</td><td>–window : 设置套接字缓冲区为指定大小。对于 TCP 方式，此设置为 TCP 窗口大小。对于 UDP 方式，此设置为接受 UDP 数据包的缓冲区大小，限制可以接受数据包的最大值。</td></tr><tr><td>-m</td><td>–print_mss : 输出 TCP MSS 值（通过 TCP_MAXSEG 支持）。MSS 值一般比 MTU 值小 40 字节。通常情况</td></tr></tbody></table><p><strong>服务器端专用选项</strong></p><table><thead><tr><th>命令行选项</th><th>描述</th></tr></thead><tbody><tr><td>-s</td><td>–server : iperf 服务器模式</td></tr><tr><td>-c</td><td>–client host : 如果 iperf 运行在服务器模式，并且用 - c 参数指定一个主机，那么 iperf 将只接受指定主机的连接。此参数不能工作于 UDP 模式。</td></tr><tr><td>-P</td><td>–parallel： 服务器关闭之前保持的连接数。默认是 0，这意味着永远接受连接。</td></tr></tbody></table><p><strong>客户端端专用选项</strong></p><table><thead><tr><th>命令行选项</th><th>描述</th></tr></thead><tbody><tr><td>-c</td><td>–client host ： 运行 iperf 的客户端模式，连接到指定的 iperf 服务器端。</td></tr><tr><td>-b</td><td>–bandwidth ：UDP 模式使用的带宽，必须配合 - u 参数，默认值是 1 Mbit&#x2F;sec。</td></tr><tr><td>-d</td><td>–dualtest ： 运行双测试模式。这将使服务器端反向连接到客户端，使用 - L 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。这些在操作的同时就立即完成了。如果你想要一个交互的测试，请尝试 - r 参数。</td></tr><tr><td>-r</td><td>–tradeoff ： 往复测试模式。当客户端到服务器端的测试结束时，服务器端通过 - l 选项指定的端口（或默认为客户端连接到服务器端的端口），反向连接至客户端。当客户端连接终止时，反向连接随即开始。如果需要同时进行双向测试，请尝试 - d 参数。</td></tr><tr><td>-L</td><td>–listenport ： 指指定服务端反向连接到客户端时使用的端口。默认使用客户端连接至服务端的端口。</td></tr><tr><td>-t</td><td>–time ： 设置传输的总时间。iperf 在指定的时间内，重复的发送指定长度的数据包。默认是 10 秒钟。</td></tr><tr><td>-P</td><td>–parallel： 线程数。指定客户端与服务端之间使用的线程数。默认是 1 线程。需要客户端与服务器端同时使用此参数。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>带宽测试通常采用 UDP 模式，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为 100Mbps，先用 - b 100M 进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。</p><p><strong>UDP 模式</strong></p><p>服务器端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">iperf -u -s</span><br><span class="line"></span><br></pre></div></figure></td></tr></table></figure><p>客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">/*在udp模式下，以100Mbps为数据发送速率，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒*/</span><br><span class="line">iperf -u -c 192.168.1.1 -b 100M -t 60</span><br><span class="line"></span><br><span class="line">/*客户端以5Mbps为数据发送速率,同时向服务器端发起30个连接线程*/</span><br><span class="line">iperf -u -c 192.168.1.1 -b 5M -P 30 -t 60</span><br><span class="line"></span><br><span class="line">/*以100M为数据发送速率，进行上下行带宽测试,-L参数指定本端双测试监听的端口*/</span><br><span class="line">iperf -u -c 192.168.1.1 -b 100M -d -t 60 -L 30000</span><br><span class="line"></span><br></pre></div></figure></td></tr></table></figure><p><strong>TCP 模式</strong></p><p>服务器端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">iperf -s</span><br></pre></div></figure></td></tr></table></figure><p>客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line">/*在tcp模式下，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒*/</span><br><span class="line">iperf -c 192.168.1.1 -t 60</span><br><span class="line"></span><br><span class="line">/*进行上下行带宽测试*/</span><br><span class="line">iperf -c 192.168.1.1 -d -t 60</span><br><span class="line"></span><br><span class="line">/*测试单线程TCP*/</span><br><span class="line">iperf –c 192.168.1.1 –p 12345 –i 1 –t 10 –w 20K</span><br><span class="line"></span><br><span class="line">-c：客户端模式，后接服务器ip</span><br><span class="line">-p：后接服务端监听的端口</span><br><span class="line">-i：设置带宽报告的时间间隔，单位为秒</span><br><span class="line">-t：设置测试的时长，单位为秒</span><br><span class="line">-w：设置tcp窗口大小，一般可以不用设置，默认即可</span><br><span class="line"></span><br><span class="line">对应服务器端：</span><br><span class="line">iperf –s –p 12345 –i 1 –t 10 –m -y</span><br><span class="line"></span><br><span class="line">/*测试多线程TCP: 客户端同时向服务器端发起30个连接线程*/</span><br><span class="line">iperf -c 192.168.1.1 -P 30 -t 60</span><br><span class="line"></span><br></pre></div></figure></td></tr></table></figure><p>发包完成后，可以通过 ifconfig ethx 和 ethtool -S ethx 查看对应收发包情况，确定发包数、包长、是否丢包等。</p><h2 id="Netperf-测试实践"><a href="#Netperf-测试实践" class="headerlink" title="Netperf 测试实践"></a>Netperf 测试实践</h2><figure class="highlight bash"><table><tr><td class="gutter"><figure><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></figure></td><td class="code"><figure><div class="code-wrapper"><pre><span class="line"><span class="comment"># install netperf</span></span><br><span class="line">wget -c <span class="string">&quot;https://codeload.github.com/HewlettPackard/netperf/tar.gz/netperf-2.7.0&quot;</span> -O netperf-2.7.0.tar.gz</span><br><span class="line">tar -zxvf netperf-2.7.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> netperf-netperf-2.7.0</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># add path</span></span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">netperf -h</span><br><span class="line">netserver -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line">netserver -4 -p 7777</span><br><span class="line">ps -ef | grep netserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># client</span></span><br><span class="line">netperf -H 10.71.14.122 -p 7777 -l 60</span><br><span class="line"></span><br><span class="line">netperf -t TCP_RR -H 10.71.14.122 -p 7777 -c -C -l 60</span><br><span class="line">netperf -t TCP_RR -H 10.71.14.122 -p 7777 -c -C -l 60 -- -r256,256</span><br><span class="line"></span><br><span class="line"><span class="comment"># check result</span></span><br><span class="line">bmon</span><br><span class="line">mpstat -P ALL 2</span><br><span class="line"></span><br></pre></div></figure></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-netperf/">netperf 与网络性能测量</a><br><a target="_blank" rel="noopener" href="https://www.alibabacloud.com/help/zh/faq-detail/55757.htm">网络性能测试方法</a></p>      </div>        <footer class="article-footer clearfix"><div class="article-catetags"><div class="article-categories">  <span></span>  <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0-Study/">学习 | Study</a></div></div>    <div class="article-share" id="share">          <div data-url="https://wsgzao.github.io/post/netperf/" data-title="netperf和iperf网络性能测试小结 | HelloDog" data-tsina="" class="share clearfix">      </div>        </div></footer>                  </article>    <nav class="article-nav clearfix">  <div class="prev" > <a href="/post/mpstat/" title="mpstat使用介绍和输出参数详解">  <strong>上一篇：</strong><br/>  <span>  mpstat使用介绍和输出参数详解</span></a></div><div class="next"><a href="/post/sre-vs-devops/"  title="SRE和DevOps"> <strong>下一篇：</strong><br/>  <span>SRE和DevOps</span></a></div></nav>    <section id="comments" class="comment">  <div id="disqus_thread">    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>  </div></section></div>        <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>  <div id="toc" class="toc-aside">  <strong class="toc-title">文章目录</strong>  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2"><span class="toc-number">2.</span> <span class="toc-text">更新历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E7%9A%84%E4%BA%94%E9%A1%B9%E6%8C%87%E6%A0%87"><span class="toc-number">3.</span> <span class="toc-text">网络性能测量的五项指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">可用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">3.2.</span> <span class="toc-text">响应时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">3.3.</span> <span class="toc-text">网络利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">网络吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E5%AE%B9%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">网络带宽容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">收集网络性能数据的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netperf"><span class="toc-number">4.</span> <span class="toc-text">Netperf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iperf"><span class="toc-number">5.</span> <span class="toc-text">iperf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netperf-%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.</span> <span class="toc-text">Netperf 测试实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">参考文章</span></a></li></ol>   </div><div id="asidepart"><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div><aside class="clearfix">  <div class="github-card"><p class="asidetitle">Github 名片</p><div class="github-card" data-github="wsgzao" data-theme="medium"></div><script type="text/javascript" src="//lab.lepture.com/github-cards/widget.js" ></script></div>  <div class="categorieslist">    <p class="asidetitle">分类</p>        <ul>                              <li><a href="/categories/Hexo/" title="Hexo">Hexo<sup>6</sup></a></li>                                        <li><a href="/categories/学习-Study/" title="学习 | Study">学习 | Study<sup>195</sup></a></li>                                        <li><a href="/categories/生活-Life/" title="生活 | Life">生活 | Life<sup>30</sup></a></li>                                        <li><a href="/categories/软件-Soft/" title="软件 | Soft">软件 | Soft<sup>5</sup></a></li>                          </ul></div>  <div class="linkslist">  <p class="asidetitle">友情链接</p>    <ul>                  <li>                            <a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>                      </li>                  <li>                            <a href="https://www.linkedin.com/in/aowang" target="_blank" title="LinkedIn">LinkedIn</a>                      </li>            </ul></div>  <div class="rsspart">    <a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a></div></aside></div>    </div>    <footer><div id="footer" >        <div class="line">        <span></span>        <div class="author"></div>    </div>            <section class="info">        <p> Hello, I&#39;m OX. This is my blog on GitHub. <br/>            Keep Calm and Carry On.</p>    </section>         <div class="social-font" class="clearfix">                        <a href="https://github.com/wsgzao" target="_blank" class="icon-github" title="github"></a>                                                <a href="https://www.linkedin.com/in/aowang" target="_blank" class="icon-linkedin" title="linkedin"></a>                                            </div>                            <p class="copyright">        Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2024                 <a href="/about" target="_blank" title="wsgzao">wsgzao</a>                        </p></div></footer>  </body> -->]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工具</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Caddy常用配置示例</title>
    <link href="/Caddy%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B.html"/>
    <url>/Caddy%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B.html</url>
    
    <content type="html"><![CDATA[<h1 id="Caddy常用配置示例"><a href="#Caddy常用配置示例" class="headerlink" title="Caddy常用配置示例"></a>Caddy常用配置示例</h1><p>最近将公司部分业务从 <code>nginx</code> 迁移到 <code>caddy</code>，为了避免翻车，总结了几个最常见的用法</p><span id="more"></span><h2 id="端口固定响应"><a href="#端口固定响应" class="headerlink" title="端口固定响应"></a>端口固定响应</h2><ul><li>用来测试运维同事有没有正确开放 <code>7000</code> 端口。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">:7000 &#123;  respond &quot;Hello, im 7000！&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="代理静态站点和后端服务"><a href="#代理静态站点和后端服务" class="headerlink" title="代理静态站点和后端服务"></a>代理静态站点和后端服务</h2><ul><li>前端页面存放在 <code>/home/lenovo/vc/ywyl/web</code></li><li>后台服务接口格式 <code>http://127.0.0.1/m/user/info</code></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">:7000 &#123;  # 静态站点根目录  root * &#x2F;home&#x2F;lenovo&#x2F;vc&#x2F;ywyl&#x2F;web  # 后端服务, 真实地址是 http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;m&#x2F;user&#x2F;infohandle &#x2F;m&#x2F;* &#123;reverse_proxy http:&#x2F;&#x2F;127.0.0.1:9090&#125;  # 静态站点服务handle &#123;file_server&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="自定义前缀用来区分业务"><a href="#自定义前缀用来区分业务" class="headerlink" title="自定义前缀用来区分业务"></a>自定义前缀用来区分业务</h2><ul><li>将 <code>http://localhost:7000/ecard/info</code> 代理到 <code>http://ipServer:80/info</code></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">:7000 &#123;  handle_path &#x2F;ecard&#x2F;* &#123;  reverse_proxy http:&#x2F;&#x2F;ipServer:80  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="自定义前缀-匹配一个有后缀的服务"><a href="#自定义前缀-匹配一个有后缀的服务" class="headerlink" title="自定义前缀, 匹配一个有后缀的服务"></a>自定义前缀, 匹配一个有后缀的服务</h2><ul><li>将 <code>http://127.0.0.1:8090/test2/tt2</code> 代理到 <code>http://127.0.0.1:8080/tt1/tt2</code></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">:8090 &#123;  # 8090&#x2F;test2&#x2F;tt2 -&gt; 8080&#x2F;tt1&#x2F;tt2  handle_path &#x2F;test2&#x2F;* &#123;    rewrite * &#x2F;tt1&#123;uri&#125;  reverse_proxy http:&#x2F;&#x2F;127.0.0.1:8080  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="后端服务是-HTTPS-或是会校验-Host-头的情况"><a href="#后端服务是-HTTPS-或是会校验-Host-头的情况" class="headerlink" title="后端服务是 HTTPS, 或是会校验 Host 头的情况"></a>后端服务是 HTTPS, 或是会校验 Host 头的情况</h2><ul><li>需要求改请求头, 否则请求不成功</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">example.com &#123;reverse_proxy https:&#x2F;&#x2F;example.com &#123;header_up Host &#123;upstream_hostport&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="添加前缀-代理某后端的-GET-请求-处理路径问题"><a href="#添加前缀-代理某后端的-GET-请求-处理路径问题" class="headerlink" title="添加前缀, 代理某后端的 GET 请求, 处理路径问题"></a>添加前缀, 代理某后端的 GET 请求, 处理路径问题</h2><ul><li><code>:8090/comm/?p=aaa</code> -&gt; <code>https://example.com/index.php?p=aaa</code></li><li>此处可以使用 <code>uri[1:]</code> 语法手动处理 <code>url</code></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-caddy" data-language="caddy"><code class="language-caddy">:8090 &#123;  handle_path &#x2F;comm&#x2F;* &#123;  rewrite * &#x2F;index.php&#123;uri[1:]&#125;  reverse_proxy https:&#x2F;&#x2F;example.com &#123;  header_up Host &#123;upstream_hostport&#125;  &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="一些排查问题的方法"><a href="#一些排查问题的方法" class="headerlink" title="一些排查问题的方法"></a>一些排查问题的方法</h1><p>使用 <code>apt install</code> 安装后，caddy 的服务配置文件默认放置在 <code>/lib/systemd/system</code>。</p><p><code>caddy</code> 会默认创建一个 <code>caddy</code> 用户用来执行服务，并将此用户的 <code>$HOME</code> 设置为 <code>/var/lib/caddy</code>，这意味着相关的证书、自动存储的配置文件会被保存在这里。</p><p>如果是排查和证书相关的问题，使用 <code>root</code> 用户和 <code>caddy</code> 用户的环境可能不同，此时可以切换到 <code>caddy</code> 用户检查：</p><p>先使用 <code>root</code> 授权，让普通用户也可以使用 <code>caddy</code> 程序占用 <code>80</code> 和 <code>443</code> 端口：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setcap <span class="token string">'cap_net_bind_service=+ep'</span> /usr/bin/caddy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>再进入 <code>caddy</code> 用户，手动运行程序，记得在配置文件前先打开 <code>debug</code> 显示：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">su</span> <span class="token parameter variable">-s</span> /bin/bash caddy<span class="token builtin class-name">cd</span> /etc/caddycaddy run <span class="token parameter variable">-c</span> Caddyfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>运维</tag>
      
      <tag>caddy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个自动投票的小工具</title>
    <link href="/%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%95%E7%A5%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7.html"/>
    <url>/%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%95%E7%A5%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7.html</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>公司要参加某个物联网展，展方为了宣传做了一个带拉票功能的宣传页，就是那种很常见的点开链接可以为自己支持的公司投票的那种。公司的前台姐姐把投票链接发到了群里，我很顺手的就投了一票，然后又顺手看了一眼网络请求：</p><span id="more"></span><p>投票动作是一个 POST 请求，请求体格式是 FormData，内容很简单</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">token: C791752B7C5342703C6B0635212FBAC309AAF52717C5557BAE2FB8D4FC3BE5E8BBBDD5D6F8CFBD15id: 980943910375260160<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>我就在群里说了一句：“好像可以刷票哦”，前台姐姐立刻给我安排了一波情绪价值：“哇，你好厉害哦”之类的。得了，这个活就算接下来了。</p><h1 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h1><ol><li>先拿 PostMan 胡乱测了一下，同样的请求内容不能再发，服务端会报错：<br><code>您已经投票</code><br>看来是对同一 <code>token</code> 投同一 <code>id</code> 的频率做了限制了。</li><li>修改 id 可以投票成功，但是就投给别的公司了 &#x3D;。&#x3D;，这显然不符合需求。</li><li>修改 <code>token</code> 以后调接口会报错，看来必须使用服务端生成的 <code>token</code> 才行。</li><li>用手机打开链接，又可以投一次，看来没有账号绑定之类的机制，换了设备就能投。</li><li>手机和电脑都连的公司的 Wifi，看来也没有 <code>IP</code> 地址限制。</li><li>用电脑换了个浏览器也能投，看来没有设备指纹之类的东西，应该就是认浏览器。</li><li>在浏览器里到处找，发现 <code>local_sotrage</code> 存了个这个：<figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">token:Qzc5MTc1MkI3QzUzNDI3MDNDNkIwNjM1MjEyRkJBQzMwOUFBRjUyNzE3QzU1NTdCQUUyRkI4RDRGQzNCRTVFOEJCQkRENUQ2RjhDRkJEMTU=<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>等号结尾，有点眼熟，base64解一下，果然和发请求的 <code>token</code> 对上了。</li><li>把这些乱七八糟的缓存都清了，重新打开页面，发现得到了一个新的 <code>token</code>，又能投一票。</li></ol><p>行了，路线通了，这下不会让前台姐姐失望了。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>本人不是 python 程序员，也没有什么爬虫经验，所有代码都是 AI 帮忙写的。</p><p>其实只有两个步骤，一个是打开浏览器获得新 <code>token</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><div class="caption"><span>获得token</span></div><code class="language-python"><span class="token keyword">def</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">global</span> token  options <span class="token operator">=</span> Options<span class="token punctuation">(</span><span class="token punctuation">)</span>  options<span class="token punctuation">.</span>headless <span class="token operator">=</span> <span class="token boolean">True</span>  driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span>options<span class="token operator">=</span>options<span class="token punctuation">)</span>  driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span>openUrl<span class="token punctuation">)</span>  <span class="token comment"># 拿 token</span>  script <span class="token operator">=</span> <span class="token string">"return localStorage.getItem('token');"</span>  tokenB64 <span class="token operator">=</span> driver<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span>script<span class="token punctuation">)</span>  driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 获取token</span>  decoded_bytes <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>tokenB64<span class="token punctuation">)</span>  token <span class="token operator">=</span> decoded_bytes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后就是投票：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><div class="caption"><span>投票</span></div><code class="language-python"><span class="token keyword">def</span> <span class="token function">vote</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">global</span> <span class="token builtin">id</span>  <span class="token keyword">global</span> token  <span class="token comment"># 刷票</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"准备投一票："</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># id 代表公司</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"id："</span><span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span>  <span class="token comment"># 获得的 token</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"token："</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span>  <span class="token comment"># 组装请求</span>  data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token builtin">id</span><span class="token punctuation">,</span>    <span class="token string">"token"</span><span class="token punctuation">:</span> token  <span class="token punctuation">&#125;</span>  headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment"># ":authority:": "api.iotexpo.com.cn",</span>    <span class="token comment"># ":method:": "POST",</span>    <span class="token comment"># ":path:": "/Expo/ProVoteByMinApp",</span>    <span class="token comment"># ":scheme:": "https",</span>    <span class="token string">"Accept"</span><span class="token punctuation">:</span> <span class="token string">"application/json, text/javascript, */*; q=0.01"</span><span class="token punctuation">,</span>    <span class="token string">"Accept-Encoding"</span><span class="token punctuation">:</span> <span class="token string">"gzip, deflate, br, zstd"</span><span class="token punctuation">,</span>    <span class="token string">"Accept-Language"</span><span class="token punctuation">:</span> <span class="token string">"zh-CN,zh;q=0.9"</span><span class="token punctuation">,</span>    <span class="token string">"Content-Length"</span><span class="token punctuation">:</span> <span class="token string">"108"</span><span class="token punctuation">,</span>    <span class="token string">"Content-Type"</span><span class="token punctuation">:</span> <span class="token string">"application/x-www-form-urlencoded; charset=UTF-8"</span><span class="token punctuation">,</span>    <span class="token string">"Origin"</span><span class="token punctuation">:</span> <span class="token string">"https://www.iotexpo.com.cn"</span><span class="token punctuation">,</span>    <span class="token string">"Priority"</span><span class="token punctuation">:</span> <span class="token string">"u=1, i"</span><span class="token punctuation">,</span>    <span class="token string">"Referer"</span><span class="token punctuation">:</span> <span class="token string">"https://www.iotexpo.com.cn/"</span><span class="token punctuation">,</span>    <span class="token string">"Sec-Ch-Ua"</span><span class="token punctuation">:</span> <span class="token string">"\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\""</span><span class="token punctuation">,</span>    <span class="token string">"Sec-Ch-Ua-Mobile"</span><span class="token punctuation">:</span> <span class="token string">"?0"</span><span class="token punctuation">,</span>    <span class="token string">"Sec-Ch-Ua-Platform"</span><span class="token punctuation">:</span> <span class="token string">"\"Windows\""</span><span class="token punctuation">,</span>    <span class="token string">"Sec-Fetch-Dest"</span><span class="token punctuation">:</span> <span class="token string">"empty"</span><span class="token punctuation">,</span>    <span class="token string">"Sec-Fetch-Mode"</span><span class="token punctuation">:</span> <span class="token string">"cors"</span><span class="token punctuation">,</span>    <span class="token string">"Sec-Fetch-Site"</span><span class="token punctuation">:</span> <span class="token string">"same-site"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36"</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span>  <span class="token comment"># 发送</span>  response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>voteUrl<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>  <span class="token comment"># 打印结果</span>  resp <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结果："</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后定时投票就行了。</p><p>很小的案例，关键是又成功刷了一波好感度 &#x3D;。&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>小玩具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小玩具</tag>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[译]GP2040-CE FAQ</title>
    <link href="/%5B%E8%AF%91%5DGP2040-CE%20FAQ.html"/>
    <url>/%5B%E8%AF%91%5DGP2040-CE%20FAQ.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://gp2040-ce.info/">GP2040-CE</a> 是一个基于树莓派（或其他） <a href="https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html">RP 2040</a> 微处理器的开源游戏控制器固件项目，支持多种输入模式，适配多个平台。<br>本文译自 GP2040-CE 项目官网，<a href="https://gp2040-ce.info/faq/faq-general">FAQ</a>  页面。</p></blockquote><span id="more"></span><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="我应该使用哪种输入模式？"><a href="#我应该使用哪种输入模式？" class="headerlink" title="我应该使用哪种输入模式？"></a>我应该使用哪种输入模式？</h2><p>这取决于您使用的平台：</p><ul><li>使用 <code>XInput Mode</code> 作为 PC 游戏和第三方主机适配的首选模式</li><li>在 PS4 或 PS5 中运行 PS4 游戏时，使用 <code>PS4 Mode</code></li><li>在 PS3 或 PS4 中使用传统模式时，使用 <code>PS3 Mode</code></li><li>在任天堂 Switch 上使用  <code>Switch Mode</code></li><li>在 MAME cabinets 或是 PC 音游等场景使用 <code>Keyboard Mode</code></li></ul><p>如果您配置了 USB 主机端口、启用了直通功能以及适当的验证设备，则可以在以下情况下使用 GP2040-CE 控制器。</p><ul><li>在支持 categorized 控制器（例如街机摇杆、赛车方向盘、飞行模拟操纵杆等）的 PS5 系统上的 PS5 游戏上使用 <code><a href="https://gp2040-ce.info/web-configurator/menu-pages/settings#additional-ps4-settings">PS4 Input Mode</a></code></li><li>在 Xbox One、Xbox Series X 和 Xbox Series S 上使用 <code><a href="https://gp2040-ce.info/web-configurator/menu-pages/settings#additional-xbox-one-settings">Xbox One Input Mode</a></code></li></ul><p>如果您使用的是经典或迷你主机，则还有其他 USB 输入模式可与这些模拟主机一起使用。</p><ul><li>Sega Genesis&#x2F;MegaDrive Mini</li><li>NEOGEO Mini</li><li>PC Engine&#x2F;Turbografx 16 Mini</li><li>EGRET II Mini</li><li>ASTROCITY Mini</li><li>Playstation Classic</li></ul><h2 id="GP2040-CE-是否原生支持-PS5，PS4-或-Xbox-Series-主机？"><a href="#GP2040-CE-是否原生支持-PS5，PS4-或-Xbox-Series-主机？" class="headerlink" title="GP2040-CE 是否原生支持 PS5，PS4 或 Xbox Series 主机？"></a>GP2040-CE 是否原生支持 PS5，PS4 或 Xbox Series 主机？</h2><p>这些主机实现了一些安全措施用来阻止未经授权的控制器接入，破解或绕过这些措施的过程可能涉及到一些法律问题。如果找到用户友好且完全合法的实现方法，例如 <code><a href="https://gp2040-ce.info/web-configurator/menu-pages/settings#additional-ps4-settings">PS4 Input Mode</a></code> 的实现，将来会支持这些主机。</p><p>目前通过直通身份验证支持 PS5、Xbox One 和 Xbox Series 主机</p><ul><li>PS5 目前仅支持使用直通身份验证；请参阅 <code><a href="https://gp2040-ce.info/web-configurator/menu-pages/settings#additional-ps5-settings">PS5 Input Mode</a></code>。</li><li>Xbox One 和 Xbox Series 主机仅支持使用直通身份验证；请参阅 <code><a href="https://gp2040-ce.info/web-configurator/menu-pages/settings#additional-xbox-one-settings">Xbox One Input Mode</a></code>。</li></ul><h2 id="我能在一个设备上使用多个-GP2040-CE-控制器吗？"><a href="#我能在一个设备上使用多个-GP2040-CE-控制器吗？" class="headerlink" title="我能在一个设备上使用多个 GP2040-CE 控制器吗？"></a>我能在一个设备上使用多个 GP2040-CE 控制器吗？</h2><p>是的！每个 GP2040-CE 板都被视为一个单独的控制器。但您需要注意，确保同一时间只运行了一个 Web 配置页面。</p><p>如果您需要在街机中安装基于 GP2040-CE 的控制板，请查看 <a href="https://gp2040-ce.info/add-ons/player-number">Player Number add-on</a> 用来强制指定每个玩家的编号。</p><h2 id="GP2040-CE-的输入延迟真的低于-1ms？"><a href="#GP2040-CE-的输入延迟真的低于-1ms？" class="headerlink" title="GP2040-CE 的输入延迟真的低于 1ms？"></a>GP2040-CE 的输入延迟真的低于 1ms？</h2><p>是的！如果您的平台支持 1000 Hz USB 轮询，输入延迟将小于 1 毫秒。GP2040-CE 在所有模式下默认配置为 1000 Hz&#x2F;1 ms 轮询，但某些系统会覆盖或忽略控制器请求的轮询速率。1000 Hz 轮询率已确认适用于 PC 和 MiSTer。即使您的平台不支持高速 USB 轮询，GP2040-CE 仍会以目标系统允许的最大速度读取和处理您的输入。</p><h2 id="RGB-LED、玩家-LED-和-OLED-显示屏等附加功能是否会影响性能？"><a href="#RGB-LED、玩家-LED-和-OLED-显示屏等附加功能是否会影响性能？" class="headerlink" title="RGB LED、玩家 LED 和 OLED 显示屏等附加功能是否会影响性能？"></a>RGB LED、玩家 LED 和 OLED 显示屏等附加功能是否会影响性能？</h2><p>完全不会！Pico 的 RP2040 处理器有两个内核，GP2040-CE 将其中一个核心专门用于读取、处理和发送玩家输入，所有辅助功能（例如 LED 和显示器）都在辅助核心上运行。无论集成了多少功能，GP2040-CE 都不会引入额外的输入延迟。</p><h2 id="为什么按键会使用-B3，A1，S2-这种奇怪的标签？"><a href="#为什么按键会使用-B3，A1，S2-这种奇怪的标签？" class="headerlink" title="为什么按键会使用 B3，A1，S2 这种奇怪的标签？"></a>为什么按键会使用 B3，A1，S2 这种奇怪的标签？</h2><p>GP2040-CE 使用通用系统来处理按钮输入，类似于带有一些额外按钮的传统 Play Station 控制器布局。</p><ul><li>4 方向键 (B1-B4)</li><li>4 肩键 (L1，L2，R1，R2)</li><li>选择和启动（S1，S2）摇杆按下（L3，R3）</li><li>两个辅助键（A1，A2）用于引导、PS键、触摸屏、Home 键或者截图键等</li></ul><p>GP2040-CE 文档和 Web 配置器都提供了一个下拉菜单，用于将按钮标签更改为更熟悉的控制器布局。您可以参考 <a href="https://gp2040-ce.info/usage#buttons">GP2040-CE 说明书</a> 上的按键映射表。</p><h1 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h1><h2 id="内建的-Web-配置页面是什么魔术？"><a href="#内建的-Web-配置页面是什么魔术？" class="headerlink" title="内建的 Web 配置页面是什么魔术？"></a>内建的 Web 配置页面是什么魔术？</h2><p>这里没有什么魔法，只是一些很酷的库一起工作：</p><ul><li>使用 React 和 Bootstrap 的单页应用程序嵌入在 GP2040-CE 固件中</li><li>TinyUSB 库通过 RNDIS 提供虚拟网络连接</li><li>lwIP 库提供了一个 HTTP 服务器，为嵌入式 React 应用程序和 Web 配置 API 提供服务</li><li>ArduinoJson 库用于Web API请求的序列化和反序列化</li></ul>]]></content>
    
    
    <categories>
      
      <category>豆知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>豆知识</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转][译]写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切 （SmallStep, 2018）</title>
    <link href="/%5B%E8%AF%91%5D%E5%86%99%E7%BB%99%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%AF%81%E4%B9%A6%EF%BC%88certificate%EF%BC%89%E5%92%8C%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%88PKI%EF%BC%89%E7%9A%84%E4%B8%80%E5%88%87%20%EF%BC%88SmallStep,%202018%EF%BC%89.html"/>
    <url>/%5B%E8%AF%91%5D%E5%86%99%E7%BB%99%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%9A%E5%85%B3%E4%BA%8E%E8%AF%81%E4%B9%A6%EF%BC%88certificate%EF%BC%89%E5%92%8C%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%88PKI%EF%BC%89%E7%9A%84%E4%B8%80%E5%88%87%20%EF%BC%88SmallStep,%202018%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<p>原作者：MIKE MALONE，发布于：</p><blockquote><p><a href="https://smallstep.com/blog/everything-pki/">Everything you should know about certificates and PKI but are too afraid to ask</a></p></blockquote><p>译者：ArthurChiao，发布于：</p><blockquote><p><a href="https://arthurchiao.art/blog/everything-about-pki-zh/">[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）</a></p></blockquote><!-- [译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）Published at 2021-10-07 | Last Update 2023-05-02译者序本文翻译自 2018 年的一篇英文博客： Everything you should know about certificates and PKI but are too afraid to ask， 作者 MIKE MALONE。这篇长文并不是枯燥、零碎地介绍 PKI、X.509、OID 等概念，而是从前因后果、历史沿革 的角度把这些东西串联起来，逻辑非常清晰，让读者知其然，更知其所以然。证书和 PKI 的目标其实很简单：将名字关联到公钥（bind names to public keys）。加密方式的演进： MAC         最早的验证消息是否被篡改的方式，发送消息时附带一段验证码  |          双方共享同一密码，做哈希；最常用的哈希算法：HMAC  |  \/ Signature   解决 MAC 存在的一些问题；双方不再共享同一密码，而是使用密钥对  |  |  \/ PKC         公钥加密，或称非对称加密，最常用的一种 Signature 方式  |          公钥给别人，私钥自己留着；  |          发送给我的消息：别人用 *我的公钥* 加密；我用我的私钥解密  \/ Certificate   公钥加密的基础，概念：CA/issuer/subject/relying-party/...    |          按功能来说，分为两种    |    |---用于 *签名*（签发其他证书） 的证书    |---用于 *加解密* 的证书证书（certificate）相关格式及其关系（沉重的历史负担）：  最常用的格式   |      信息比 X.509 更丰富的格式       |       其他格式  mTLS 等常用        Java 常用            微软常用                     .p7b .p7c          .pfx .p12  X.509 v3            PKCS#7               PKCS#12        SSH 证书    PGP 证书     =====>  证书格式      \                 |                    /                                           （封装格式，证书结构体）       \                |                   /        \               |                  /         \              |                 /          \-------------+----------------/                        |                       ASN.1 （类似于 JSON、ProtoBuf 等）                          =====>  描述格式                        |          /-------------+----------------\         /              |                 \        /               |                  \       /                |                   \      /                 |                    \   DER                 PEM                                                         =====>  编码格式二进制格式           文本格式                                                             （序列化）  .der            .pem .crt .cer一些解释：X.509 从结构上定义证书中应该包含的信息，例如签发者、秘钥等等； 但使用哪个格式（例如 JSON 还是 YAML 还是 ASN.1）来描述，并不属于 X.509 的内容；ASN.1 是 X.509 的描述格式（或者说用 ASN.1 格式来定义 X.509），类似于现在的 protobuf；ASN 中有很多数据类型，除了常见的整形、字符串等类型，还有一个称为 OID 的特殊类型，用点分整数表示，例如 2.5.4.3，有点像 URI 或 IP 地址，在设计上是全球唯一标识符，ASN.1 只是一种描述格式，并未定义如何序列化为比特流，因此又引出了 ASN.1 的编码格式； ASN.1 与其编码格式的关系，类似 unicode 与 utf8 的关系。ASN.1 的常见编码格式：DER：一种二进制编码格式PEM：一种文本编码格式，通常以 .pem、.crt 或 .cer 为后缀。某些场景下，X.509 信息不够丰富，因此又设计了一些信息更丰富（例如可以包含证书 链、秘钥）的证书封装格式，包括 PKCS #7 和 #12。仍然用 ASN.1 格式描述基本都是用 DER 编码以上提到的东西，再加上 CA、信任仓库、信任链、certificate path validation、CSR、证书生命周期管理、 SPIFFE 等还没有提到但也与加密相关的东西，统称为公钥基础设施（PKI）。翻译时调整了一些配图，也加了几张新图，以方便展示和理解。由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。以下是译文。译者序1 前言1.1 为什么要学习 PKI1.2 本文目的1.3 极简 TL; DR（太长不读）2 术语2.1 Entity（实体）2.2 Identity（身份）2.3 Identifier（身份标识符）2.4 Claim（声明） & Authentication（认证）2.5 Subscriber & CA & relying party (RP)2.6 小结3 MAC（消息认证码）和 signature（签名）3.1 MAC（message authentication code）和 HMAC（hash-based MAC）3.2 Signature（签名）与不可否认性3.3 小结4 Public key cryptography（公钥加密，或称非对称加密）4.1 秘钥对4.2 公钥加密系统使计算机能“看到”对方5 证书（certificate）：计算机和代码的驾驶证5.1 证书的内容：（subscriber 的）公钥+名字5.2 证书的本质：基于对 issuer 公钥的信任来学习其他公钥5.3 与驾照的类比5.4 证书内容解析举例6 证书编码格式及历史演进6.1 X.509 证书X.509 起源：电信领域6.2 ASN.1：数据抽象格式6.3 OID (object identitfier)6.4 ASN.1 编码格式DER (distinguished encoding rules)：二进制格式PEM (privacy enhanced email)：文本格式6.5 比 X.509 信息更丰富的证书打包（封装）格式PKCS #7：Java 中常用PKCS #12：微软常用6.6 秘钥编解码PEM 编码的 PKCS#8 格式私钥密码加密的私钥公钥、私钥常见扩展名6.7 小结7 PKI (Public Key Infrastructure)7.1 Web PKI vs Internal PKI7.2 有了 Web PKI，为什么还要使用自己的 internal PKI？8 Trust & Trustworthiness8.1 Trust Stores（信任仓库）预配置信任的根证书信任链根证书自签名信任仓库的来源操作系统的信任仓库8.2 Trustworthiness（可靠性）8.3 Federation证书欺骗的风险改进措施Internal PKI 使用单独的信任仓库Internal PKI 细粒度控制：CAA & SPIFFE9 什么是证书权威（Certificate Authority）？9.1 Web PKI 不能自动化签发证书9.2 Intermediates, Chains, and Bundling9.3 RP：Certificate path validation10 秘钥和证书的生命周期10.1 Naming things（命名相关）DN (distinguished names)SAN (subject alternative name)10.2 生成 key pairs10.3 Issuance（确保证书中的信息都是对的）10.3.1 Certificate signing requests（证书签名请求，PKCS#10）10.3.2 Identity proofing（身份证明过程）Web PKI 证明身份过程Internal PKI 证明身份过程10.4 Expiration（过期）10.5 Renewal（续期）10.5.1 Web PKI 证书续期10.5.2 Internal PKI 证书续期10.5.3 小结10.6 Revocation（撤销）10.6.1 主动撤销的困难10.6.2 Internal PKI：被动撤销机制10.6.3 主动检查机制：CRL（Certificate Revocation Lists）10.6.4 主动检查机制：OCSP（Online Certificate Signing Protocol）10.6.5 主动检查机制：OCSP stapling（合订，绑定）11 使用证书12 结束语13 延伸阅读（译注）1 前言证书（certificates）与 PKI（public key infrastructure，公钥基础设施）很难。我认识的很多非常聪明的人也会绕过这一主题。 我个人也很长时间没去碰这些内容，但说起来很讽刺，我没去碰的原因是不懂： 因为不懂，所以不好意思问 —— 然后更不懂，自然更不好意思问 —— 如此形成恶性循环。但最终，我还是硬着头皮学习了这些东西。1.1 为什么要学习 PKI我觉得 PKI 能使一个人在加解密层面（乃至更大的安全层面）去思考如何定义一个系统。 具体来说，PKI 技术，都是通用的、厂商无关的（universal and vendor neutral）；适用于任何地方，因此即使系统可分布在世界各地，彼此之间也能安全地通信；在概念上很简单，并且非常灵活；如果使用我们的 TLS everywhere 模型， 那甚至连 VPN 都不需要了。总之一句话：非常强大！1.2 本文目的在深入理解了 PKI 之后，我很后悔没有早点学这些东西。PKI 非常强大且有趣，虽然它背后的数学原理很复杂，一些相关标准也设计地非常愚蠢 （巴洛克式的复杂），但其 核心概念其实非常简单；证书是识别（identify）代码和设备的最佳方式， 而 identity（身份）对安全、监控、指标等很多东西都非常有用；使用证书并不是太难，不会难于学习一门新语言或一种新数据库。那为什么大家对这些内容望而却步呢？我认为主要是缺少很好的文档，所以经常看地云里雾里，半途而弃。本文试图弥补这一缺失。我认为大部分工程师花一个小时读完本文后，都将了解到 关于加解密的那些最重要概念和使用场景 —— 这正是本文的目的 —— 一小时只是很小的一个投资，而且这些内容是无法通过其他途径学到的。本文将用到以下两个开源工具：step CLIstep certificates1.3 极简 TL; DR（太长不读）证书和 PKI 的目的：将名字关联到公钥（bind names to public keys）。这是关于证书和 PKI 的最高抽象，其他都属于实现细节。2 术语本文将用到以下术语。2.1 Entity（实体）Entity 是任何存在的东西（anything that exists） —— 即使 只在逻辑或概念上存在（even if only exists logically or conceptually）。 例如，你用的计算机是一个 entity，你写的代码也是一个 entity，你自己也是一个 entity，你早餐吃的杂粮饼也是一个 entity，你六岁时见过的鬼也是一个 entity —— 即使你妈妈告诉你世界上并没有鬼，这只是你的臆想。2.2 Identity（身份）每个 entity（实体）都有一个 identity（身份）。 要精确定义这个概念比较困难，这么来说吧：identity 是使你之所以为你 （what makes you you）的东西，懂吗？具体到计算机领域，identity 通常用一系列属性来表示，描述某个具体的 entity， 这里的属性包括 group、age、location、favorite color、shoe size 等等。2.3 Identifier（身份标识符）Identifier 跟 identity 还不是一个东西：每个 identifier 都是一个唯一标识符， 也唯一地关联到某个有 identity 的 entity。例如，我是 Mike，但 Mike 并不是我的 identity，而只是个 name —— 虽然二者在我们 小范围的讨论中是同义的。2.4 Claim（声明） & Authentication（认证）一个 entity 能 claim（声明）说，它拥有某个或某些 name。其他 entity 能够对这个 claim 进行认证（authenticate），以确认这份声明的真假。一般来说，认证的目的是确认某些 claim 的合法性。Claim 不是只能关联到 name，还可以关联到别的东西。例如，我能 claim 任何东西： my age, your age, access rights, the meaning of life 等等。2.5 Subscriber & CA & relying party (RP)能作为一个证书的 subject 的 entity，称为 subscriber（证书 owner）或 end entity。对应地，subscriber 的证书有时也称为 end entity certificates 或 leaf certificates， 原因在后面讨论 certificate chains 时会介绍。CA（certificate authority，证书权威）是给 subscriber 颁发证书的 entity，是一种 certificate issuer（证书颁发者）。CA 的证书，通常称为 root certificate 或 intermediate certificate，具体取决于 CA 类型。Relying party 是 使用证书的用户（certificate user），它验证由 CA 颁发（给 subscriber）的证书是否合法。一个 entity 可以同时是一个 subscriber 和一个 relying party。 也就是说，单个 entity 既有自己的证书，又使用其他证书来认证 remote peers， 例如双向 TLS（mutual TLS，mTLS）场景。2.6 小结对于我们接下来的讨论，这些术语就够了。下面将进入正题，看如何在实际中实现 证书的声明和认证。想了解更多相关术语，可参考 RFC 4949。3 MAC（消息认证码）和 signature（签名）3.1 MAC（message authentication code）和 HMAC（hash-based MAC）MAC（消息认证码）是一小段数据，用于验证某个 entity 发送的消息未被篡改。 其基本原理如下图所示：MAC/HMAC 原理。图片来自：okta.com对消息（message）和双方都知道的一个密码 （shared secret，a password）做哈希，得到的哈希值就是 MAC；发送方将消息连带 MAC 一起发给接收方；接收方收到消息之后，用同一个密码来计算 MAC，然后跟消息中提供的 MAC 对比。如果相同，就证明未被篡改。关于哈希：哈希是单向的，因此无法从输出反推输入；这一点至关重要，否则截获消息的人就可以根据 MAC 和哈希函数反推 secrets。生成 MAC 的哈希算法选择也至关重要，本文不会展开，但提醒一点：不要试图用自己设计的 MAC 算法。最常用的 MAC 算法是 HMAC（hash-based message authentication code）。3.2 Signature（签名）与不可否认性讨论 MAC 其实是为了引出 signature（签名）这一主题。签名在概念上与 MAC 类似，但不是用共享 secret 的方式， 而是使用一对秘钥（key pair）：MAC 方式中，至少有两个 entity 需要知道共享的 secret，也就是消息的发送方和接 收方。双方都可以生成 MAC，因此给定一个合法的 MAC，我们是 无法知道是谁生成的。签名就不同了：签名能用公钥（public key）验证，但只能用相应的 私钥（private key）生成。 因此对于接收方来说，它只能验证签名是否合法，而无法生成同样的签名。如果只有一个 entity 知道秘钥，那这种特性称为 non-repudiation （不可否认性）：持有私钥的人无法否认（repudiate）数据是由他签名的这一事实。3.3 小结MAC 与 signature 都叫做签名，是因为它们和现实世界中的签名是很像的。例如，如果想 让某人同意某事，并且事后还能证明他们当时的确同意了，就把问题写下来，然后让他们 手写签字（签名）。4 Public key cryptography（公钥加密，或称非对称加密）证书和 PKI 的基础是公钥加密（public key cryptography）， 也叫非对称加密（asymmetric cryptography）。4.1 秘钥对公钥加密系统使用秘钥对（key pair）加解密。一个秘钥对包含：一个私钥（private key）：owner 持有，解密用，不要分享给任何人；这一点非常重要，值得重复一遍：公钥加密系统的安全性取决于私钥（private key）的机密性。一个公钥（public key）：加密用，可分发和共享给别人；秘钥可以做的事情：加解密：公钥（public key）加密，私钥（private key）解密。签名：私钥（private key）对数据进行签名（sign some data）； 任何有公钥的人都可以对签名进行验证，证明这个签名确实是私钥生成的。4.2 公钥加密系统使计算机能“看到”对方公钥加密是数学给计算机科学的神秘礼物， 其数学基础 显然很复杂，但如果只是使用，那并不需要理解它的每一步数学原理。 公钥加密使计算机能做一些之前无法做的事情：它们现在能看到对方是谁了。这句话的意思是说，公钥加密使一台计算（或代码）能向其他计算机或程序证明 不用直接分享某些信息，它也能知道该信息。更具体来说，以前要证明你有密码，就必须向别人展示这个密码。但展示之后，任何有这个密码的人就都能使用它了。私钥却与此不同。你能通过公钥对我的身份进行认证（authenticate my identity），但却无法假冒我。例如，你发给我一个大随机数，我对这个随机数进行签名，然后将再发送给你。 你能用公钥对这个签名进行认证，确认这个签名（消息）确实来自我。 这就是一种证明你在和我（而不是别的其他的人）通信的很好证据。这使得网络上的 计算机能有效地知道它们在和谁通信。这听起来是一件如此理所当然的事情，但仔细地想一下，网络上只有流动的 0 和 1， 你怎么知道消息来自谁，在和谁通信？因此公钥加密系统是一个非常伟大的发明。5 证书（certificate）：计算机和代码的驾驶证前面说道，公钥加密系统使我们能知道和谁在通信，但这个的前提是： 要知道（有）对方的公钥。那么，如果对方不知道我的公钥怎么办？ 这就轮到证书出场了。想一下，我们需求其实非常简单：首先要将公钥和它的 owner 信息发给对方；但光有这个信息还不行，还要让对方相信这些信息；证书就是用来解决这个问题的，解决方式是请一个双方都信任的权威机构 对以上信息作出证明（签名）。5.1 证书的内容：（subscriber 的）公钥+名字证书是一个数据结构，其中包含一个 public key 和一个 name；权威机构对证书进行签名，签名的大概意思是：public key xxx 关联到了 name xx；对证书进行签名的 entity 称为 issuer（或 certificate authority, CA）， 证书中的 entity 称为 subject。举个例子，如果某个 Issuer 为 Bob 签发了一张证书，其中的内容就可以解读如下：Some Issuer says Bob’s public key is 01:23:42…证书是权威机构颁发的身份证明，并没有什么神奇之处其中 Some Issuer 是证书的签发者（证书权威），证书是为了证明这是 Bob 的公钥， Some Issuer 也是这个声明的签字方。5.2 证书的本质：基于对 issuer 公钥的信任来学习其他公钥由上可知，如果知道 Some Issuer 的公钥，就可以通过验证签名的方式来 对它（用私钥）签发的证书进行认证（authenticate）。 如果如果你信任 Some Issuer，那你就可以信任这个声明。因此，证书使大家能基于对 issuer 公钥的信任和知识，来学习到其他 entity 的公钥 （上面的例子中就是 Bob）。这就是证书的本质。5.3 与驾照的类比证书就像是计算机/代码的驾照或护照。如果你之前从未见过我，但信任车管局，那你可以 用我的驾照做认证：首先验证驾照是真的（检查 hologram 等），然后人脸和照片上对的上，然后看名字是我，等等。计算机用证书做类似的事情：如果之前从未和其他电脑通信，但信任 一些证书权威，那可以用证书来认证：首先验证证书是合法的（用证书签发者的公钥检查签名等），然后提取证书中的（subscriber 的）公钥和名字，然后用 subscriber 的公钥，通过网络验证该 subscriber 的签名；查看名字是否正确等等。5.4 证书内容解析举例下面是个真实的证书：还是与驾照类比：驾照：描述了你是否有资格开车；证书：描述你是否是一个 CA，你的公钥能否用来签名或加密。二者都有有效期。上图中有大量的细节，很多东西将在下面讨论到。但归根结底还是本文最开始总结的那句话 ：证书不过是一个将名字关联到公钥（bind names to public keys）的东西。 其他都是实现细节。6 证书编码格式及历史演进接下来看一看证书在底层的表示（represented as bits and bytes）。这部分内容复杂且相当令人沮丧。事实上，我怀疑证书和秘钥诡异的编码方式 是导致 PKI 如此混乱和令人沮丧的根源。6.1 X.509 证书一般来说，人们提到“证书”而没有加额外限定词时，指的都是 X.509 v3 证书。更准确地说，他们指的是 RFC 5280 中描述、 CA/Browser Forum Baseline Requirements中进一步完善的 PKIX 变种。换句话说，指的是浏览器理解并用来做 HTTPS（HTTP over TLS）的那些证书。也有其他的证书格式，例如著名的 SSH 和 PGP 都有它们各自的格式。本文主要关注 X.509，理解了 X.509，其他格式都是类似的。 由于这些证书使用广泛，因此有很好的函数库，而且也用在浏览器之外的场景。毫无疑问，它们是 internal PKI 颁发的最常见证书格式。重要的是，这些证书在很多 TLS/HTTPS 客户端/服 务端程序中都是开箱即用的。X.509 起源：电信领域了解一点 X.509 的历史对理解它会有很大帮助。X.509 在 1988 年作为国际电信联盟（ITU）X.500 项目的一部分首次标准化。 这是通信（telecom）领域的标准，想通过它构建一个全球电话簿（global telephone book）。 虽然这个项目没有成功，但却留下了一些遗产，X.509 就是其中之一。如果查看 X.509 的证书，会看到其中包含了 locality、state、country 等信息， 之前可能会有疑问为什么为 web 设计的证书会有这些东西，现在应该明白了，因为 X.509 并不是为 web 设计的。6.2 ASN.1：数据抽象格式X.509 构建在 ASN.1 （Abstract Syntax Notation，抽象语法标注）之上，后者是另一个 ITU-T 标准 (X.208 and X.680)。ASN.1 定义数据类型，可以将 ASN.1 理解成 X.509 的 JSON，但实际上更像 protobuf、thrift 或 SQL DDL。RFC 5280 用 ASN.1 来定义 X.509 证书，其中包括名字、秘钥、签名等信息。6.3 OID (object identitfier)ASN.1 除了有常见的数据类型，如整形、字符串、集合、列表等， 还有一个不常见但很重要的类型：OID（object identifier，对象标识符）。OID 与 URI 有些像，但比 URI 要怪。OID （在设计上）是全球唯一标识符。在结构上，OID 是在一个 hierarchical namespace 中的一个整数序列（例如 2.5.4.3）。可以用 OID 来 tag 一段数据的类型。例如，一个 string 本来只是一个 string，但可 以 tag 一个 OID 2.5.4.3，然后就变成了一个特殊 string：这是 X.509 的通用名字（common name） 字段。6.4 ASN.1 编码格式ASN.1 只是抽象（abstract），因为这个标准并未定义在数据层应该如何表示（represented as bits and bytes）。 ASN.1 与其编码格式的关系，就像 unicode 与 utf8 的区别。 因此，有很多种编码规则（encoding rules），描述具体如何表示 ASN.1 数据。 原以为增加这层额外的抽象会有所帮助，但实际证明大部分情况下反而徒增烦恼。DER (distinguished encoding rules)：二进制格式ASN.1 有很多种编码规则， 但用于 X.509 和其他加密相关的，只有一种常见格式：DER —— 虽然有时也会用到 non-canonical 的 basic encoding rules (BER，基础编码规则) 。DER 是非常简单的 TLV（type-length-value）编码，但实际上用户无需 关心这些，因为函数库封装好了。但不要高兴得太早 —— 虽然我们不必关心 DER 的编解码， 但要能判断给定的某个 X.509 证书是 DER 还是其他类型编码的。这里的其他类型包括：一些比 DER 更友好的格式，封装了证书及其他额外信息的格式（something more than just a certificate）。DER 编码的证书通常以 .der 为后缀。PEM (privacy enhanced email)：文本格式DER 是二进制格式，不便复制粘贴。因此大部分证书都是以 PEM 格式打包的，这是 另一个历史怪胎。如果你熟悉 MIME 的话，二者是比较类似的： 由 header、base64 编码的 payload、footer 三部分组成。 header 中有标签（label）来描述 payload。例如下面是一个 PEM 编码的 X.509 证书：-----BEGIN CERTIFICATE-----MIIBwzCCAWqgAwIBAgIRAIi5QRl9kz1wb+SUP20gB1kwCgYIKoZIzj0EAwIwGzEZMBcGA1UEAxMQTDVkIFRlc3QgUm9vdCBDQTAeFw0xODExMDYyMjA0MDNaFw0yODExBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRc+LHppFk8sflIpm/XKpbNMwx3SDAfBgNVHSMEGDAWgBTirEpzC7/gexnnz7ozjWKd71lz5DAKBggqhkjOPQQDAgNHADBEAiAejDEfua7dud78lxWe9eYxYcM93mlUMFIzbWlOJzg+rgIgcdtU9wIKmn5qFU3iOiRP5VyLNmrsQD3/ItjUN1f1ouY=-----END CERTIFICATE-----但令人震惊的时，即便如此简单的功能，在实现上也已经出现混乱：PEM labels 在不同工具之间是不一致的。 RFC 7468 试图标准化 PEM 的使用规范， 但也并不完整，不是所有工具都遵循这个规范。PEM 编码的证书通常以 .pem、.crt 或 .cer 为后缀。 再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。下面介绍几个前面提到的“其他类型的打包格式”。6.5 比 X.509 信息更丰富的证书打包（封装）格式X.509 只是一种常用的证书格式，但有人觉得这种格式能装的信息不够多，因此 又定义了一些比 X.509 更大的数据结构（但仍然用 ASN.1）， 能将证书、秘钥以及其他东西封装（打包）到一起。因此，有时说我需要“一个证书”时，其 实真正说的是包（package）中包含的那个“证书”（a certificate in one of these envelopes），而不是这个包本身。PKCS #7：Java 中常用你可能会遇到的是一个称为 PKCS（Public Key Cryptography Standards，公钥加密标准）的标准的一部分， 它由 RSA labs 发布（真实历史要 更加复杂一些，本文不展开）。其中的第一个标准是 PKCS#7，后面被 IETF 重新冠名为 Cryptographic Message Syntax (CMS) ，其中可以包含多个证书（以 full certificate chain 方式编码，后面会看到）。PKCS#7 在 Java 中使用广泛。常见扩展名是 .p7b and .p7c。PKCS #12：微软常用另一个常见的打包格式 <a href=https://tools.ietf.org/html/rfc7292>PKCS#12</a>， 它能将一个证书链（这一点与 PKCS#7 类似）连同一个（加密之后的）私钥打包到一起。微软的产品多用这种格式，常见后缀.pfx and .p12。再次说明，PKCS#7 和 PKCS#12 envelopes 仍然使用 ASN.1，这意味着 它们都能以原始 DER、BER 或 PEM 的格式编码。 从我个人的经验来看，二者几乎都是 DER 编码的。6.6 秘钥编解码秘钥编码（Key encoding）的过程与以上描述的类似（复杂）：用某种 ASN.1 数据结构描述秘钥（key）；用 DER 做二进制编码，或用 PEM (hopefully with a useful header) 做一些稍微友好一些的表示。秘钥的解密过程（deciphering），一半是是科学，一半是艺术。如果足够幸运，根据 RFC 7468 就能找到其中的 PEM payload；椭圆曲线秘钥通常符合 RFC 7468 规范，虽然 这里看起来似乎也并没有什么标准。下面是一个 PEM 编码的椭圆曲线秘钥（PEM-encoded elliptic curve key）： $ step crypto keypair --kty EC --no-password --insecure ec.pub ec.prv $ cat ec.pub ec.prv -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEc73/+JOESKlqWlhf0UzcRjEe7inF uu2z1DWxr+2YRLfTaJOm9huerJCh71z5lugg+QVLZBedKGEff5jgTssXHg== -----END PUBLIC KEY----- -----BEGIN EC PRIVATE KEY----- MHcCAQEEICjpa3i7ICHSIqZPZfkJpcRim/EAmUtMFGJg6QjkMqDMoAoGCCqGSM49 AwEHoUQDQgAEc73/+JOESKlqWlhf0UzcRjEe7inFuu2z1DWxr+2YRLfTaJOm9hue rJCh71z5lugg+QVLZBedKGEff5jgTssXHg== -----END EC PRIVATE KEY-----其他秘钥，通常用 PEM label “PRIVATE KEY” 描述PEM 编码的 PKCS#8 格式私钥PEM label “PRIVATE KEY” 描述的秘钥，通常暗示这是一个 PKCS#8 payload， 这是一种私钥（private key）封装格式，其中包含秘钥类型和其他 metadata。密码加密的私钥用密码来加密私钥也很常见（private keys encrypted using a password），这里的密码可以是 a shared secret or symmetric key。 看起来大致如下（Proc-Type and DEK-Info 是 PEM 的一部分，表示这个 PEM 的 payload 是用 AES-256-CBC 加密的）：-----BEGIN EC PRIVATE KEY-----Proc-Type: 4,ENCRYPTEDDEK-Info: AES-256-CBC,b3fd6578bf18d12a76c98bda947c4ac9qdV5u+wrywkbO0Ai8VUuwZO1cqhwsNaDQwTiYUwohvot7Vw851rW/43poPhH07SosdLFVCKPd9v6F9n2dkdWCeeFlI4hfx+EwzXLuaRWg6aoYOj7ucJdkofyRyd4pEt+Mj60xqLkaRtphh9HWKgaHsdBki68LQbObLOz4c6SyxI=-----END EC PRIVATE KEY-----PKCS#8 对象也能被加密，这种情况下 header label 应该是 "ENCRYPTED PRIVATE KEY" per RFC 7468。 这种情况下不会看到 Proc-Type 和 Dek-Info headers，因为这些信息此时编码到了 payload 中。公钥、私钥常见扩展名公钥：.pub or .pem，私钥：.prv, .key, or .pem。但再次说明，有些工具或组织可能并不遵循业界惯例。6.7 小结ASN.1 用于定义数据类型，例如证书（certificate）和秘钥（key）—— 就像用 JSON 定义一个 request body —— X.509 用 ASN.1 定义。DER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。PKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其 中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。DER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它 用 base64 对 DER 进行编码，然后再加上自己的 label。私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。如果觉得以上内容理解起来很杂乱，那并不是你的问题，而是加密领域的现状就是如此。我已经尽力了。7 PKI (Public Key Infrastructure)至此我们已经知道了证书的来历和样子，但这仅仅是本文的一半。 下面看证书是如何创建和使用的。Public key infrastructure (PKI) 是一个统称，包括了我们在 如下与证书和秘钥管理及交互操作时需要用到的所有东西：签发、分发、存放、使用、验证、撤回等等。 就像“数据库基础设施” 一样，这个名词是有意取的这样模糊的。证书是大部分 PKI 的构建模块，而证书权威是其基础。PKI 包括了 libraries, cron jobs, protocols, conventions, clients, servers, people, processes, names, discovery mechanisms, and all the other stuff you’ll need to use public key cryptography effectively。自己从头开始构建一个 PKI 是一件极其庞大的工作， 但实际上 一些简单的 PKI 甚至并不使用证书。例如，编辑 ~/.ssh/authorized_keys 文件时，就是在配置 一个简单的无证书形式的（certificate-less）PKI，SSH 通过这种方式在扁平文件内 实现 public key 和 name 的绑定；PGP 用证书，但不用 CA，而是用一个 web-of-trust model；甚至可以 用区块链 来 assign name 并将它们 bind 到 public key。如果从头开始构建一个 PKI，唯一确定的事情是：你需要用到公钥（public keys）， 其他东西都随设计而异。下文将主要关注 web 领域使用的 PKI，以及基于 Web PKI 技术、遵循现有标准的 internal PKI。证书和 PKI 的目标其实很简单：将名字关联到公钥（bind names to public keys）。 在下面的内容中，不要忘了这一点。7.1 Web PKI vs Internal PKI浏览器访问 HTTPS 链接时会用到 Web PKI。虽然也有一些问题，但它大大提升了 web 的安全性，而且基本上对用户透明。在访问互联网 web 服务时，应该在所有可能的情 况下都启用它。Web PKI 由 RFC 5280 定义， CA/Browser Forum (a.k.a., CA/B or CAB Forum) 对其进行了进一步完善。有时也称为 “Internet PKI” 或 PKIX (after the working group that created it).PKIX 和 CAB Forum 文档涵盖了很大内容。 它们定义了前面讨论的各种证书、还定义什么是 “name” 以及位于证书中什么位置、能使用什么签名算法、 RP 如何判断 issuer 的证书、如何指定证书的 validity period (issue and expiry dates)、 撤回、certificate path validation、CA 判断某人是否拥有一个域名等等。Web PKI 很重要，是因为浏览器默认使用 Web PKI 证书。Internal PKI 是用户为自己的产品基础设施使用的 PKI，这些产品包括服务、容器、虚拟机等；企业 IT 应用；公司终端设备，例如笔记本电脑、手机等；其他需要识别的代码或设备。Internal PKI 使你能认证和建立加密通道，这样你的服务就可以安全地在公网上的任意位置互相通信了。7.2 有了 Web PKI，为什么还要使用自己的 internal PKI？首先，简单来说：Web PKI 设计中并没有考虑内部使用场景。 即使有了 Let’s Encrypt 这样的提供免费证书和自动化交付的 CA， 用户还是需要自己处理 rate limits 和 availability 之类的事情。 如果有很多 service，部署很频繁，就非常不方便。另外，Web PKI 中，用户对证书生命周期、撤回机制、续约过程、秘钥类型、算法等等很 多重要的细节都没有控制权，或只有很少控制权。而下文将会看到，这些都是非常重要的东西。最后，CA/Browser Forum Baseline Requirements 实际上禁止将 Web PKI CA 关联到 internal IPs (e.g., 10.0.0.0/8) 及 internal DNS names that aren’t fully-qualified and resolvable in public global DNS (e.g., you can’t bind a kubernetes cluster DNS name like foo.ns.svc.cluster.local)。 如果需要在证书中绑定到这些 name，或者签发大量证书，或者控制证书细节，就需要自己的 internal PKI.下面一节将看到，信任（或缺乏信任）是避免将 Web PKI 用于内部场景的另一个原因。总结起来，建议：面向公网的服务或 API，使用 Web PKI；其他所有场景，都使用 internal PKI。8 Trust & Trustworthiness8.1 Trust Stores（信任仓库）前面介绍到，证书可解读为一个 statement 或 claim，例如：Issuer（签发者）说，该 subject 的公钥是 xxx。Issuer 会对这份声明进行签名，relying party 能（通过 issuer 的公钥）验证（authenticate）签名是否合法。 但这里其实跳过了一个重要问题：relying party 是如何知道 issuer 的公钥的？预配置信任的根证书答案其实很简单：relying parties 在自己的 trust store（信任库）预先配置了一个它 信任的根证书（trusted root certificates，也称为 trust anchors）列表，预配置的具体方式（the manner in which this pre-configuration occurs）， 是 PKI 非常重要的一面：一种方式是从另一个 PKI 来 bootstrap：可以用一些自动化工具，通过 SSH 将 root 证 书拷贝到 relying party。这里用到里前面提到的 SSH PKI。如果是在 cloud 上，那 PKI 依赖层次（信任链）又深了一步：SSH PKI 是由 Web PKI 加上认证方式 来 bootstrap 的，这里的认证是你创建 cloud 账户时选择的认证方式。信任链如果沿着这个信任链（chain of trust）回溯足够远，最后总能找到人（people）：每个 信任链都终结在现实世界（meatspace）。下面这个图画地更清楚一些，Image credit: Cilium TLS inspection根证书自签名信任仓库中的根证书是自签名的（self-signed）：issuer 和 subject 相同。逻辑上，这种 statement 表示的是：Mike 说：Mike 的公钥是 xxx。自签名的证书保证了该证书的 subject/issuer 知道对应的私钥， 但任何人都可以生成一个自签名的证书，这个证书中可以写任何他们想写的名字（name）。因此证书的起源（provenance）就非常关键：一个自签名的证书，只有 当它进入信任仓库的过程是可信任时，才应该信任这个根证书。在 macOS 上，信任仓库是由 Keychain 管理的。在一些 Linux 发行版上，可能只是 /etc 或其他路径下面的一些文件。如果你的用户能修改这些文件，那最好先确认是你信任这些用户的。信任仓库的来源所以，信任仓库又从哪里来？对于 Web PKI 来说，最重要的 relying parties 就是浏览器。主流浏览器默认使用的信任仓库 —— 及其他任何使用 TLS 的东西 —— 都是由四个组织维护的：Apple’s root certificate：iOS/macOS 程序Microsoft’s root certificate program：Windows 使用Mozilla’s root certificate program： Mozilla 产品使用，由于其开放和透明，也作为其他一些信任仓库从基础 (e.g., for many Linux distributions)Google 未维护 root certificate program （Chrome 通常使用所在计算的操作系统的信任仓库），但 维护了自己的黑名单， 列出了自己不信任的根证书或特定证书。 (ChromeOS builds off of Mozilla’s certificate program)操作系统的信任仓库操作系统中的信任仓库通常都是系统自带的。Firefox 自带了自己的信任仓库（通过 TLS 从 mozilla.org 分发 —— bootstrapping off of Web PKI using some other trust store）。编程语言和其他非浏览器的东西例如 curl，通过默认用操作系统的信任仓库。因此，这个信任仓库通常情况下，会被该系统上预装的很多东西默认使用；通过软件更新（ 通常使用另一个 PKI 来签名）而更新。信任仓库中通常包含了超过 100 个由这些程序维护的常见证书权威（certificate authorities）。 其中一些著名的：Let’s EncryptSymantecDigiCertEntrust如果想编程控制：Cloudflare’s cfssl project maintains a github repository that includes the trusted certificates from various trust stores to assist with certificate bundling (which we’ll discuss momentarily).For a more human-friendly experience you can query Censys to see which certificates are trusted by Mozilla, Apple, and Microsoft.8.2 Trustworthiness（可靠性）这 100 多个证书权威在理论上是可信的（trusted） —— 浏览器和其他 一些软件默认情况下信任由这些权威颁发的证书。但是，这并不意味着它们是可靠的（trustworthy）。 已经出现过 Web PKI 证书权威向政府机构提供假证书的事故，以便 窥探流量（snoop on traffic）或仿冒某些网站。 这类“受信任的” CA 中，其中在司法管辖权之外的地方运营 —— 包括民主国家和专制国家。NSA 利用每个可能的机会来削弱 Web PKI。2011 年，两个“受信任的”证书权威 DigiNotar and Comodo 都 被攻陷了。 DigiNotar 证书泄露可能与 NSA 相关。此外，还有大量 CA 签发格式不对或不兼容的证书。因此，虽然按业界规范来说 这些 CA 是受信的，但按照经验来说它们是不可靠（不靠谱）的。我们很快就会看到，Web PKI 的安全性取决于安全性最弱的权威（the least secure CA）的安全性。 这显然不是我们希望的。浏览器社区已经在采取行动来解决这些问题。 CA/Browser Forum Baseline Requirements 规定了这些受信的证书权威在签发证书时应该遵守的规则。 作为 WebTrust audit 项目的一部分，在将 CA 加入到某些信任仓库（例如 Mozilla 的）之前，会对 CA 合规性进行审计。如果内部场景（internal stuff）已经在使用 TLS，你可能大部分情况下 并不需要信任这些 public CA。 如果信任了，就为 NSA 和其他组织打开了一扇地狱之门：你的系统安全性将取决于 100 多 个组织中安全性最弱的那一个。8.3 Federation证书欺骗的风险令事情更糟糕的是，Web PKI relying parties (RPs) 信任它们的信任仓库中任何 CA 签发给任何 subscriber 的证书。结果是 Web PKI 整体的安全性取决于所有 Web PKI CA 中最弱的那个。 2011 DigiNotar 攻击就说明了这个问题：作为攻击的一部分，给 google.com 签发了一个假证书， 这个证书被大部分浏览器和操作系统信任，而它们不管 google 和 DigiNotar 没有任何关系这一事实。还有类似的欺骗证书颁发给了 Yahoo!, Mozilla, The Tor Project。最终的解决方式是将 DigiNotar 的根证书从主流信任仓库中移除，但显然在此期间已经造成了大量破坏。最近，森海塞尔（Sennheiser）因为在它们的 HeadSetup APP 信任仓库中 安装了一个自签名的根证书 引起了一次重大安全事故，他们将相应的私钥（private key）嵌入在了 app 的配置中，任何人都能从中提取这个私钥，然后颁发证书给任何 domain，因此，任何在自己的信任仓库中添加了 Sennheiser 证书的，都将会信任这些欺骗证书。这完全摧毁了 TLS 带来的好处，太糟糕了！改进措施已经有一些机制来减少此类风险：Certificate Authority Authorization (CAA) allows you to restrict which CAs can issue certificates for your domain using a special DNS record.Certificate Transparency (CT) (RFC 6962) mandates that CAs submit every certificate they issue to an impartial observer that maintains a public certificate log to detect fraudulently issued certificates. Cryptographic proof of CT submission is included in issued certificateHTTP Public Key Pinning (HPKP or just “pinning”) lets a subscriber (a website) tell an RP (a browser) to only accept certain public keys in certificates for a particular domain.这里存在的问题是：缺少 RP 端的支持。CAB Forum now mandates CAA checks in browsers. Some browsers also have some support for CT and HPKP. 但对于 其他 RPs (e.g., most TLS standard library implementations) 这些东西几乎都是没有 贯彻执行的。This issue will come up repeatedly: a lot of certificate policy must be enforced by RPs, and RPs can rarely be bothered. If RPs don’t check CAA records and don’t require proof of CT submission this stuff doesn’t do much good.Internal PKI 使用单独的信任仓库在任何情况下，如果使用自己的 internal PKI，都应该为 internal 服务维护一个单独的信任仓库。 即，不要将你的根证书直接加到系统已有的信任仓库，而应该配置 internal TLS 只使用你自己的根证书。Internal PKI 细粒度控制：CAA & SPIFFE如果想在内部实现更好的联邦（federation） —— 例如限制 internal CA 能签发哪些证书，可以试试 CAA records 然后对 RPs 进行恰当配置。还可以看看 SPIFFE，这是一个还在不断发展的项目， 目标是对一些 internal PKI 相关的问题进行标准化。9 什么是证书权威（Certificate Authority）？前面已经讨论了很多 CA 相关的东西，但我们还没定义什么是 CA。一个证书权威（CA）就是一个受信任的证书颁发者。CA 通过对一个证书进行签名，对一个公钥和名字之间的绑定关系（binding）做担保。本质上来说，一个 CA 只不过是另一个证书加上用来签其他证书的相应私钥。显然需要一些逻辑和过程来将这些东西串联起来。CA 需要将它的证书分发到信任仓库，接受和处理 证书请求，颁发证书给 subscriber。一个暴露此类 API 给外部调用、自动化这些过程的 CA 称为在线证书权威（online CA）。在信任仓库中那些自签名的根证书 称为根证书权威（root CA）。9.1 Web PKI 不能自动化签发证书CAB Forum Baseline Requirements 4.3.1 明确规定：一个 Web PKI CA 的 root private key 只能通过 issue a direct command 来签发证书。换句话说，Web PKI root CA 不能自动化证书签名（certificate signing）过程。对于任何大的 CA operation 来说，无法在线完成都是一个问题。 不可能每次签发一个证书时，都人工敲一个命令。这样规定是出于安全考虑。Web PKI root certificates 广泛存在于信任仓库中，很难被撤回。截获一个 root CA private key 理论上将影响几十亿的人和设备。因此，最佳实践就是，确保 root private keys 是离线的（offline），理想情况下在一些 专用硬件 上，连接到某些物理空间隔离的设备上，有很好的物理安全性，有严格的使用流程。一些 internal PKI 也遵循类似的实践，但实际上并没有这个必要。如果能自动化 root certificate rotation （例如，通过配置管理或编排工具，更新信任仓库）， 你就能轻松地 rotate 一个 compromised root key。由于人们如此沉迷于 internal PKI 的根秘钥管理，导致 internal PKI 的部署效率大大 降低。你的 AWS root account credentials 至少也是机密信息，你又是如何管理它的呢？9.2 Intermediates, Chains, and Bundling在 root CA offline 的前提下，为使证书 issuance 可扩展（例如，使自动化成为可能）， root private key 只在很少情况下使用，用来签发几个intermediate certificates。然后 intermediate CA（也称为 subordinate CAs）用相应的 intermediate private keys 来签发 leaf certificates to subscribers。如下图所示：Image credit: Cilium TLS inspection下面这张图把签发关系展示地更清楚，Image credit: Cilium TLS inspectionIntermediates 通常并不包含在信任仓库中，所以撤回或 roate 比较容易， 因此通过 intermediate CA，就实现了 certificate issuance 的在线和自动化（online and automated）。这种 leaf、intermediate、root 组成的证书捆绑（bundle）机制， 形成了一个证书链（certificate chain）。leaf 由 intermediate 签发，intermediate 又由 root 签发，root 自签名（signs itself）。技术上来说，上面都是简化的例子，你可以创建更长的 chain 和更复杂的图（例如， cross-certification）。 但不推荐这么做，因为复杂性很快会失控。在任何情况下， end entity certificates 都是叶子节点，这也是称为叶子证书（leaf certificate）的原因。当配置一个 subscriber 时（例如，Apache、Nginx、Linkderd、Envoy）， 通常不仅需要叶子证书，还需要一个包含了 intermediates 的 certificate bundle。有时会用 PKCS#7 和 PKCS#12，因为它们能包含一个完整的证书链（certificate chain）。更多情况下，证书链编码成一个简单的空行隔开的 PEM 对象（sequence of line-separated PEM objects）。Some stuff expects the certs to be ordered from leaf to root, other stuff expects root to leaf, and some stuff doesn’t care. More annoying inconsistency. Google and Stack Overflow help here. Or trial and error.下面是一个例子：  $ cat server.crt  -----BEGIN CERTIFICATE-----  MIICFDCCAbmgAwIBAgIRANE187UXf5fn5TgXSq65CMQwCgYIKoZIzj0EAwIwHzEd  ...  MBsGA1UEAxMUVGVzdCBJbnRlcm1lZGlhdGUgQ0EwHhcNMTgxMjA1MTc0OTQ0WhcN  HO3iTsozZsCuqA34HMaqXveiEie4AiEAhUjjb7vCGuPpTmn8HenA5hJplr+Ql8s1  d+SmYsT0jDU=  -----END CERTIFICATE-----  -----BEGIN CERTIFICATE-----  MIIBuzCCAWKgAwIBAgIRAKBv/7Xs6GPAK4Y8z4udSbswCgYIKoZIzj0EAwIwFzEV  ...  BRvPAJZb+soYP0tnObqWdplmO+krWmHqCWtK8hcCIHS/es7GBEj3bmGMus+8n4Q1  x8YmK7ASLmSCffCTct9Y  -----END CERTIFICATE-----Again, annoying and baroque, but not rocket science.9.3 RP：Certificate path validation由于 intermediate certificates 并未包含在信任仓库中，因此需要与 leaf certificates 一样分发和验证。前面已经介绍，配置 subscriber 时需要提供这些 intermediates，subscribers 随后再将它们传给 RP。如果使用 TLS，那这个过程发生在 TLS 握手时。当一个 subscriber 将它的证书发给 relying party 时，其中会包含所有能证明来自信任的根证书的 intermediates。relying party 通过一个称为 certificate path validation 的过程来验证 leaf 和 intermediate certificates 。完整的 certificate path validation 算法比较复杂。包括了checking certificate expirationsrevocation statusvarious certificate policieskey use restrictionsa bunch of other stuff显然，PKI RP 准确实现这个算法是非常关键的。如果关闭 certificate path validation (例如，curl -k)，用户将面临重大风险，所以不要关闭。完成正确的 TLS 并没有那么难，certificate path validation 是 TLS 中完成认证（authentication）的部分。可能有人会说，channel 已经是加密的了，因此关闭没关系 —— 错，有关系。 没有认证（authentication）的加密是毫无价值的 —— 这就像在教堂忏悔： 你说的话都是私密的，但却并不知道帘幕后面的人是谁 —— 只不过这里不是教堂，而是互联网。10 秘钥和证书的生命周期在能通过 TLS 等协议使用证书之前，要先配置如何从 CA 获取一个证书。 逻辑上来说这是一个相当简单的过程：需要证书的 subscriber 自己先生成一个 key pair，然后通过请求发送给 CA，CA 检查其中关联的 name 是否正确，如果正确就签名并返回一个证书。证书会过期，过期的证书就不会被 RP 信任了。如果证书快过期了而还想继续用它，就需要 续期（renew ）并轮转（rotate）它。如果想在一个证书过期之前就让 RP 停止信任它，就需要执行撤销（revoke）。与 PKI 相关的大部分东西一样，这些看似简单的过程实际上都充满坑。 其中也隐藏了计算机科学中最难的两个问题：缓存一致性和命名（naming）。 但另一方面，一旦理解了背后的原理，再反过来看实际在用的一些东西就简单多了。10.1 Naming things（命名相关）DN (distinguished names)历史上，X.509 使用 X.500 distinguished names (DN) 来命名证书的使用者（name the subject of a certificate），即 subscriber。 一个 DN 包含了一个 common name （对作者我来说，就是 “Mike Malone”），此外还可以包含 locality、country、organization、organizational unit 及其他一些东西（数字电话簿相关）。没人理解 DN，它在互联网上也没什么意义。应该避免使用 DN。如果真的要用，也要尽量保持简单。无需使用全部字段，实际上，也不应该使用全部字段。common name 可能就是需要用到的全部字段了，如果你是一个 thrill seeker ，可以在用上一个 organization name。PKIX 规定一个网站的 DNS hostname 应该关联到 DN common name。最近，CAB Forum 已 经废弃了这个规定，使整个 DN 字段变成可选的（Baseline Requirements, sections 7.1.4.2）。SAN (subject alternative name)现代最佳实践使用 subject alternative name (SAN) X.509 extension 来 bind 证书中的 name。常用的 SAN 有四种类型，绑定的都是广泛使用的名字：domain names (DNS)email addresseIP addresseURI在我们讨论的上下文中，这些都是唯一的，而且它们能很好地映射到我们想识别的东西：email addresses for peopledomain names and IP addresses for machines and code,URIs if you want to get fancy应该使用 SAN。注意，Web PKI 允许在一个证书内 bind 多个 name，name 也也允许通配符。也就是说，一个证书可以有多个 SAN，也可以有类似 *.smallstep.com 这样的 SAN。这对有多个域名的的网站来说很有用。10.2 生成 key pairs有了 name 之后，需要先生成一个密钥对，然后才能创建证书。前面提到：PKI 的安全性 在根本上取决于一个简单的事实：只有与证书中的 subscriber name 对应的 entity，才应该拥有与该证书对应的私钥。 为确保这个条件成立，最佳实践是让 subscriber 生成它自己的密钥对，这样就只有它自己知道私钥。绝对应该避免通过网络发送私钥。生成证书时使用什么类型的秘钥？这一主题值得单独写一篇文章，这里 只提供一点快速指导（截止 2018.12）。如今有一个缓慢但清晰的从 RSA 转向椭圆曲线秘钥的趋势（ ECDSA 或 EdDSA）。如果决定使用 RSA 秘钥，确保它们至少是 2048 比特长，但也不要超过 4096 比特。如果使用 ECDSA，那 P-256 曲线可能是最好选择（secp256k1 or prime256v1 in openssl）， 除非你担心 NSA，这种情况下你可以选择更 fancier 一些的东西，例如 EdDSA with Curve25519（但对这些秘钥的支持还不是太好）。下面是用 openssl 生成一个椭圆曲线 P-256 key pair 的例子：$ openssl ecparam -name prime256v1 -genkey -out k.prv$ openssl ec -in k.prv -pubout -out k.pub# 也可以用 step 生成$ step crypto keypair --kty EC --curve P-256 k.pub k.prv还可以通过编程来生成这些证书，这样能做到证书不落磁盘。10.3 Issuance（确保证书中的信息都是对的）subscriber 有了一个 name 和一对 key 之后，下一步就是从 CA 获取一个 leaf certificate。 对 CA 来说，它需要认证（证明）两件事情：subscriber 证书中的公钥，确实是该 subscriber 的公钥（例如，验证该 subscriber 知道对应的私钥）；这一步通常通过一个简单的技术机制实现：证书签名请求（certificate signing request, CSR）。证书中将要绑定的 name，确实是该 subscriber 的 name。这一步要难很多。抽象来说，这个过程称为 identity proofing（身份证明）或 registration（注册）.10.3.1 Certificate signing requests（证书签名请求，PKCS#10）Subscriber 请求一个证书时，会向 CA 会提交一个 certificate signing request (CSR)。CSR 也是一个 ASN.1 结构，定义在 PKCS#10。与证书类似，CSR 数据结构包括一个公钥、一个名字和一个签名。CSR 是自签名的，用与 CRS 中公钥对应的私钥自签名。这个签名用于证明该 subscriber 有对应的私钥，能对任何用其公钥加密的东西进行解密。还使即使 CSR 被复制或转发，都没有能篡改其中的内容（篡改无效）。CSR 中包括了很多证书细节配置项。但在实际中，大部分配置项都会被 CA 忽略。大部分 CA 都使用自己的固定模板， 或提供一个 administrative 接口来收集这些信息。用 step 命令创建一个密钥对和 CSR 的例子：$ step certificate create -csr test.smallstep.com test.csr test.keyOpenSSL 功能也非常强大，但 用起来不够方便。10.3.2 Identity proofing（身份证明过程）CA 收到一个 CSR 并验证签名之后，接下来需要确认证书中绑定的 name 是否真的 是这个 subscriber 的 name。这项工作很棘手。 证书的核心功能是能让 RP 对 subscriber 进行认证。因此， 如果一个证书都还没有颁发，CA 如何对这个 subscriber 进行认证呢？答案是：分情况。Web PKI 证明身份过程Web PKI 有三种类型的证书，它们最大的区别就是如何识别 subscriber， 以及它们所用到的 identity proofing 机制。这三种证书是：domain validation (DV，域验证)DV 证书绑定的是 DNS name，CA 在颁发时需要验证的这个 domain name 确实是由该 subscriber 控制的。证明过程通常是通过一个简单的流程，例如给 WHOIS 记录中该 domain name 的管理员发送一封确认邮件。ACME protocol （最初由 Let’s Encrypt 开发和使用）改进了这种方式，更加自动化：不再用邮件验证 ，而是由 ACME CA 提出一个 challenge，该 subscriber 通过完成这个问题来证明它拥有 这个域名。challenge 部分属于 ACME 规范的扩展部门，常见的包括：在指定的 URL 上提供一个随机数（HTTP challenge）在 DNS TXT 记录中放置一个随机数（DNS challenge）organization validation (OV，组织验证)OV 和下面将介绍的 EV 证书构建在 DV 证书之上，它们包括了 name 和域名 所属组织的位置信息（location）。OV 和 EV 证书不仅仅将证书关联到域名，还关联到控制这个域名的法律实体（legal entity）。OV 证书的验证过程，不同的 CA 并不统一。为解决这个问题，CAB Forum 引入了 EV 证书。extended validation (EV，扩展验证)EV 证书包含的基本信息与 OV 是一样的，但强制要求严格验证（identity proofing）。EV 过程需要几天或几个星期，其中可能包括公网记录搜索（public records searches）和公司人员（用笔）签署的（纸质）证词。这些完成之后，当相应网站时，某些浏览器会在 URL 栏中显示该组织的名称。例如：但除了这个场景之外，EV certificates 并未得到广泛使用，Web PKI RP 也未强依赖它。本质上来说，每个 Web PKI RP 只需要 DV 级别的 assurance 就行了， 也就是确保域名是被该 subscriber 控制的。重要的是能理解一个 DV 证书在设计上的意思和在实际上做了什么：在设计上，希望通过它证明：请求这个证书的 entity 拥有对应的域名；在实际上，真正完成的操作是：在某个时间，请求这个证书的 entity 能读一封邮件，或配置一条 DNS 记录，或能通过 HTTP serve 一个指定随机数等等。但话说回来，DNS、电子邮件和 BGP 这些底层基础设施本身的安全性也并没有做到足够好， 针对这些基础设施的攻击还是 时有发生， 目的之一就是获取证书。Internal PKI 证明身份过程上面是 Web PKI 的身份证明过程，再来看 internal PKI 的身份证明过程。实际上，用户可以使用任何方式来做 internal PKI 的 identity proofing， 并且效果可能比 Web PKI 依赖 DNS 或邮件方式的效果更好。乍听起来好像很难，但其实不难，因为可以利用已有的受信基础设施： 用来搭建基础设施的工具，也能用来为这些基础设施之上的服务创建和证明安全身份。如果用户已经信任 Chef/Puppet/Ansible/Kubernetes，允许它们将代码放到服务器上， 那也应该信任它们能完成 identity attestations如果在 AWS 上，可以用 instance identity documents如果在 GCP：GCPAzureprovisioning infrastructure 必须理解 identity 的概念，这样才能将正确的代码放到正确的位置。 此外，用户必须信任这套机制。基于这些知识和信任，才能配置 RP 信任仓库、将 subscribers 纳入你的 internal PKI 管理范围。 而完成这些功能全部所需做的就是：设计和实现某种方式，能让 provisioning infrastructure 在每个服务启动时，能将它们的 identity 告诉你的 CA。 顺便说一句，这正是 step certificates 解决的事情。10.4 Expiration（过期）证书通常都会过期。虽然这不是强制规定，但一般都这么做。设置一个过期时间非常重要，证书都是分散在各处的：通常 RP 在验证一个证书时，并没有某个中心式权威能感知到（这个操作）。如果没有过期时间，证书将永久有效。安全领域的一条经验就是：时间过的越久，凭证被泄露的概率就越接近 100%。因此，设置过期时间非常重要。具体来说，X.509 证书中包含一个有效时间范围：issued atnot beforenot after：过了这个时间，证书就过期了。这个机制看起来设计良好，但实际上也是有一些不足的：首先，没有什么能阻止 RP 错误地（或因为糟糕的设计）接受一个过期证书；其次，证书是分散的。验证证书是否过期是每个 RP 的责任，而有时它们会出乱子。例如，RP 依赖的系统时钟不对时。 最坏的情况就是系统时钟被重置为了 unix epoch（1970.1.1），此时它无法信任任何证书。在 subscriber 侧，证书过期后，私钥要处理得当：如果一个密钥对之前是用来签名/认证的（例如，基于 TLS），应该在不需要这个密钥对之后，立即删除私钥。保留已经失效的签名秘钥（signing key）会导致不必要的风险：对谁都已经没有用处，反而会被拿去仿冒签名。如果密钥对是用来加密的，情况就不同了。只要还有数据是用这个加密过的，就需要留着这个私钥。这就是为什么很多人会说，不要用同一组秘钥来同时做签名和加密（signing and encryption）。 因为当一个用于签名的私钥过期时，无法实现秘钥生命周期的最佳管理： 最终不得不保留着这个私钥，因为解密还要用它。10.5 Renewal（续期）证书快过期时，如果还想继续使用，就需要续期。10.5.1 Web PKI 证书续期Web PKI 实际上并没有标准的续期过期：没有一个标准方式来延长证书的合法时间，一般是直接用一个新证书替换过期的。因此续期过程和 issuance 过程是一样的：生成并提交一个 CSR，然后完成 identity proofing。10.5.2 Internal PKI 证书续期对于 internal PKI 我们能做的更好。最简单的方式是：用 mTLS 之类的协议对老证书续期。CA 能对 subscriber 提供的客户端证书进行认证（authenticate），重签一个更长的时间，然后返回这个证书。这使得续期过程很容易自动化，而且强制 subscriber 定期与中心权威保持沟通。基于这种机制能轻松构建一个证书的监控和撤销基础设施。10.5.3 小结证书的续期过程其实并不是太难，最难的是记得续期这件事。几乎每个管理过公网证书的人，都经历过证书过期导致的生产事故，例如这个。 我的建议是：发现问题之后，一定要全面排查，解决能发现的所有此类问题。另外，使用生命周期比较短的证书。这会反过来逼迫你们优化和自动化整个流程。Let’s Encrypt 使自动化非常容易，它签发 90 天有效期的证书，因此对 Web PKI 来说非常合适。 对于 internal PKI，建议有效期签的更短：24 小时或更短。有一些实现上的挑战 —— hitless certificate rotation 可能比较棘手 —— 但这些工作是值得的。用 step 检查证书过期时间：step certificate inspect cert.pem --format json | jq .validity.endstep certificate inspect https://smallstep.com --format json | jq .validity.end将这种命令行封装到监控采集脚本，就可以实现某种程度的监控和自动化。10.6 Revocation（撤销）如果一个私钥泄露了，或者一个证书已经不再用了，就需要撤销它。即希望：明确地将其标记为非法的，所有 RP 都不再信任这个证书了，即使它还未过期。但实际上，撤销证书过程也是一团糟。10.6.1 主动撤销的困难与过期类似，执行撤回的职责在 RP。与过期不同的是，撤销状态无法编码在证书中。RP 只能依靠某些带外过程（out-of-band process） 来判断证书的撤销状态。除非显式配置，否则大部分 Web PKI TLS RP 并不关注撤销状态。换句话说，默认情况下， 大部分 TLS 实现都乐于接受已经撤销的证书。10.6.2 Internal PKI：被动撤销机制Internal PKI 的趋势是接受这个现实，然后试图通过被动撤销（passive revocation）机制来弥补， 具体来说就是签发生命周期很短的证书，这样就使撤销过程变得不再那么重要了。 想撤销一个证书时，直接不给它续期就行了，过一段时间就会自动过期。可以看到，这个机制有效的前提就是使用生命周期很短的证书。具体有多短？取决于你的威胁模型（安全专家说了算）。24 小时是很常见的，但也有短到 5 分钟的。如果生命周期太短，显然也会给可扩展性和可用性带来挑战：每次续期都需要与 online CA 交互， 因此 CA 有性能压力。如果缩短了证书的生命周期，记得确保你的时钟是同步的，否则就有罪受了。对于 web 和其他的被动撤销不适合的场景，如果认真思考之后发现真的 需要撤销功能，那有两个选择：CRL（，证书撤销列表，RFC 5280）OCSP（Online Certificate Signing Protocol，在线证书签名协议，RFC 2560）10.6.3 主动检查机制：CRL（Certificate Revocation Lists）CRL 定义在 RFC 5280 中，这是一个相当庞杂的 RFC，还定义了很多其他东西。 简单来是，CRL 是一个有符号整数序列，用来识别已撤销的证书。这个维护在一个 CRL distribution point 服务中，每个证书中都包含指向这个服务的 URL。 工作流程：每个 RP 下载这个列表并缓存到本地，在对证书进行验证时，从本地缓存查询撤销状态。 但这里也有一些明显的问题：CRL 可能很大，distribution point 也可能失效。RP 的 CRL 缓存同步经常是天级的，因此如果一个证书撤销了，可能要几天之后才能同步到这个状态。此外，RP fail open 也很常见 —— CRL distribution point 挂了之后，就接受这个证书。 这显然是一个安全问题：只要对 CRL distribution point 发起 DDoS 攻击，就能让 RP 接受一个已经撤销的证书。因此，即使已经在用 CRL，也应该考虑使用短时证书来保持 CRL size 比较小。 CRL 只需要包含已撤销但还未过期的证书的 serial numbers，因此 证书生命周期越短，CRL 越短。10.6.4 主动检查机制：OCSP（Online Certificate Signing Protocol）主动检查机制除了 CRL 之外，另一个选择是 OCSP，它允许 RP 实时查询一个 OCSP responder： 指定证书的 serial number 来获取这个证书的撤销状态。与 CRL distribution point 类似，OCSP responder URL 也包含在证书中。 这样看，OCSP 似乎更加友好，但实际上它也有自己的问题。对于 Web PKI，它引入了验证的隐私问题：每次查询 OCSP responder，使得它能看到我正在访问哪个网站。此外，它还增加了每个 TLS 连接的开销：需要一个额外请求来检查证实的撤销状态。与 CRL 一样，很多 RPs (including browsers) 会在 OCSP responder 失效时直接认为证书有效（未撤销）。10.6.5 主动检查机制：OCSP stapling（合订，绑定）OCSP stapling 是 OCSP 的一个变种，目的是解决以上提到的那些问题。相比于让 RP 每次都去查询 OCSP responder，OCSP stapling 中让证书的 subscriber 来做这件事情。 OCSP response 是一个经过签名的、时间较短的证词（signed attestation），证明这个证书未被撤销。attestation 包含在 subscriber 和 RP 的 TLS handshake (“stapled to” the certificate) 中。 这给 RP 提供了相对比较及时的撤销状态，而不用每次都去查询 OCSP responder。 subscriber 可以在 signed OCSP response 过期之前多次使用它。这减少了 OCSP 的负担，也解决了 OCSP 的隐私问题。但是，所有这些东西其实最终都像是一个 鲁布·戈德堡装置（Rube Goldberg Device） ，鲁布·戈德堡机械（Rube Goldberg machine）是一种被设计得过度复杂的机械组合，以 迂回曲折的方法去完成一些其实是非常简单的工作，例如倒一杯茶，或打一只蛋等等。 设计者必须计算精确，令机械的每个部件都能够准确发挥功用，因为任何一个环节出错 ，都极有可能令原定的任务不能达成。解释来自 知乎。如果让 subscribers 去 CA 获取一些生命周期很短的证词（signed attestation）来证明对应的证书并没有过期， 为什么不直接干掉中间环节，直接使用生命周期很短的证书呢？11 使用证书虽然理解 PKI 需要以上长篇大论，但在实际中用证书其实是非常简单的。下面以 TLS 为例，其他方式也是类似的：配置 PKI relying party 使用哪个根证书；对于 Web PKI，通常已经默认配置了正确的根证书，这一步可以跳过。配置 PKI subscriber 使用哪个证书和私钥（或如何生成自己的密钥对、如何提交 CSR）；某个 entity (code, device, server, etc) 既是 RP 又是 subscriber 是很常见的。 这样的 entities 需要同时配置根证书、证书和私钥。下面是个完整例子，展示 certificate issuance, root certificate distribution, and TLS client (RP) and server (subscriber) configuration:希望这展示了使用 internal PKI 和 TLS 是如何简单直接。有了这样的基础，就无需使用自签名的证书或做一些危险的事情，例如禁用 certificate path validation（curl -k）。几乎每个 TLS client/server 都支持这些参数；但是，它们又几乎都不关注秘钥和证书 的声明周期：都假设证书会出现在磁盘上的恰当位置，有人或服务会帮它们完成 rotate 等工作。这项生命周期相关的工作才是难点。12 结束语公钥加密系统使计算机能在网络上看到对方（”see” across networks）。如果我有公钥，就能“看到”你有对应的私钥，但我自己是无法使用这个私钥的。如果还没有对方的公钥，就需要证书来帮忙。证书将公钥和私钥拥有者的名字（name）相关联， 它们就像是计算机和代码的驾照。证书权威（CA）用它们的私钥对证书进行签名，对这些绑定关系作出担保，它们就像是车管局（DMV），如果你出示一张车管局颁发的驾照，脸长得也和驾照上的照片一样，那别人就可以认为你就是驾照上这个人（名字）。 同理，如果你是唯一知道某个秘钥的 entity，你给我的证书也是从我信任的某个 CA 来的，那我就认为证书中的 name 就是你。现实中，大部分证书都是 X.509 v3 证书，用 ASN.1 格式定义，通常序列化为 PEM-encoded DER。相应的私钥通常表示为 PKCS#8 objects，也序列化为 PEM-encoded DER。如果你用 Java 或微软的产品，可能会遇到 PKCS#7 and PKCS#12 封装格式。加密领域有沉重的历史包袱，使当前的这些东西学起来、用起来非常让人沮丧，这比一项技术因为太难而不想学更加令人沮丧。PKI 是使用公钥基础设施时涉及到的所有东西的统称：names, key types, certificates, CAs, cron jobs, libraries 等。Web PKI 是浏览器默认使用的 PKI。Web PKI CA 是受信但不可靠的（trusted but not trustworthy）。Internal PKI 是用户自己构建和维护的 PKI。需要它是因为 Web PKI 并不是针对 internal 使用场景设计的， Internal PKI 更易于自动化和扩展，并且能让用户控制很多细节，例如 naming and certificate lifetime。建议公网上使用 Web PKI，内网使用自己的 internal PKI （例如，use TLS 来替代 VPN）。Smallstep Certificate Manager 使构建 internal PKI 非常简单。要获得一个证书，需要命令和生成证书。建议 name 用 SAN：DNS SANs for code and machinesEMAIL SANs for people如果这些都不能用，就用 URI SAN秘钥类型（key type）是很大一个主题，但几乎不重要：你可以随便修改秘钥类型， 而且实际上加密本身（crypto）并不是 PKI 中最弱的一环。要从 CA 获取一个证书，需要提交一个 CSR 并证明申请者的身份（identity）。 使用生命周期较短的证书和 passive revocation。 自动化证书续期过程。不要禁用 certificate path validation。最后还是那句话：证书和 PKI 将名字关联到公钥（bind names to public keys）。 其他都是细节。13 延伸阅读（译注）更多相关内容或实践，推荐：Illustrated X.509 Certificate，2020超详细图解 X.509 证书。Cilium TLS inspection，2021图解 X.509 证书、信任链，及 Cilium/hubble L7 实战。 -->]]></content>
    
    
    <categories>
      
      <category>HTTPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单实现windows下的应用热备</title>
    <link href="/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0windows%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E7%83%AD%E5%A4%87.html"/>
    <url>/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0windows%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E7%83%AD%E5%A4%87.html</url>
    
    <content type="html"><![CDATA[<p>在项目开发中遇到了应用系统需要热备的需求，于是按照以前做过 VRRP 的经验，在 IP 地址可以切换的前提条件下设计了一些应用层的切换方式，等到应用层都准备完毕、项目即将上线的时候，突然傻眼了，发现 Windows 不支持 VRRP。</p><span id="more"></span><p>我当然知道，强大的 WindowsServer 系统肯定是能支持这种 IP 地址切换的功能的，只是我确实对 WindowsServer 的管理一无所知，上网搜索一番后也没有什么收获，又觉得自己需要的切换功能实在很简单，于是决定自己做一个简单的实现。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>大概需求是这样：</p><ul><li>有两台服务器，主机和备机。</li><li>有三个IP地址，主机IP，备机IP，业务IP。</li><li>客户通过业务IP访问服务。</li><li>业务IP平时配置在主机上，当主机不可用（断电或断网）时则配置在备机上。</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>有了这样的需求，思路就很简单了，主机始终保持自己有业务IP，备机持续对主机 ping 包，在主机不可用时给自己配置业务IP，在主机可用后把自己的业务IP删除就行了。那么需要解决的问题就变成了这些：</p><ul><li>程序通过配置文件了解自己是主机还是备机</li><li>程序可以添加或者删除IP配置</li><li>程序可以ping包并了解结果</li></ul><p>上网搜了一下，添加或者删除 IP 配置都可以通过命令解决：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netsh interface <span class="token function">ip</span> <span class="token function">add</span> address <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"Ethernet"</span> <span class="token assign-left variable">addr</span><span class="token operator">=</span><span class="token number">192.168</span>.34.200 <span class="token assign-left variable">mask</span><span class="token operator">=</span><span class="token number">255.255</span>.255.0 <span class="token assign-left variable">gateway</span><span class="token operator">=</span><span class="token number">192.168</span>.34.1netsh interface <span class="token function">ip</span> delete address <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"Ethernet"</span> <span class="token assign-left variable">addr</span><span class="token operator">=</span><span class="token number">192.168</span>.34.200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>而 ping 包这件事可以通过一个库来解决</p><p><a href="https://github.com/tatsushid/go-fastping">go-fastping</a></p><p>按照以上思路，很快一个可以切换 IP 的程序就制作完成了，再使用 nssm 把他和应用服务什么的都注册到一起，轻松完成需求。</p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>测试过程中发现，主机切换到备机始终正常，备机切换主机一直失败。</p><p>观察发现，备机切换主机的过程中，会有短时间的主备机同时在线且同时拥有虚IP的情况。切换主机后（也就是备机删除虚 IP 配置），主机虚 IP 不可用，主机本机也 ping 不通虚 IP。</p><p>并不清楚原理，可能是 windows 系统会自己禁用这种地址冲突的子 IP。</p><p>发现只要主机重新配置一次子 IP 就可以正常使用，于是给主机添加了一个接收通知的接口，当备机让出虚拟 IP 的所有权后，给主机发送一条通知，主机收到通知后执行一次把虚拟 IP 删除再重新添加的动作，随后虚拟 IP 可以正常使用。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>最终的实现也放到 github 啦，在这里<a href="https://github.com/vitsumoc/vwinvrrp">vwinvrrp</a>。</p>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用garble混淆Go程序</title>
    <link href="/%E4%BD%BF%E7%94%A8garble%E6%B7%B7%E6%B7%86Go%E7%A8%8B%E5%BA%8F.html"/>
    <url>/%E4%BD%BF%E7%94%A8garble%E6%B7%B7%E6%B7%86Go%E7%A8%8B%E5%BA%8F.html</url>
    
    <content type="html"><![CDATA[<p>最近在做的一个产品，走的是私有化部署的路线，需要给很多客户部署服务，然后卖 License 的模式。</p><p>很自然的，就遇到了如何防止客户破解的问题，毕竟一个 License 也不便宜，客户破解的动机和经费还是很充足的。</p><span id="more"></span><p>最后决定使用这个库：</p><blockquote><p><a href="https://github.com/burrowers/garble">https://github.com/burrowers/garble</a></p></blockquote><p>可以对 Go 项目编译出的可执行程序进行混淆，删除额外信息，混淆代码中的明文字符串等等。</p><p>当然，我也知道没有什么方案能够完全防止软件破解，只是这种方法可以增大破解难度，只要黑客的报价比我的 License 更贵就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql bin_log 塞满了磁盘</title>
    <link href="/mysql%20bin_log%20%E5%A1%9E%E6%BB%A1%E4%BA%86%E7%A3%81%E7%9B%98.html"/>
    <url>/mysql%20bin_log%20%E5%A1%9E%E6%BB%A1%E4%BA%86%E7%A3%81%E7%9B%98.html</url>
    
    <content type="html"><![CDATA[<p>项目制的开发就是这样，你能从中获得一些宝贵的一手经验，但代价是每一次经验背后都有一个“事故”。</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>客户告诉我，服务器磁盘增长速度异常，项目上线二十天，mysql 文件夹的磁盘占用就超过 700G。</p><p><em>非常非常感谢这位能够提前帮我们发现问题的客户，责任心和专业性都很强。</em></p><p>经检查，是 mysql&#x2F;data 文件夹中出现了大量的 binlog.xxxxxx 文件，每个文件大小大约 1GB，每天产生若干个文件。</p><p>查阅资料后，发现该文件是 mysql 的二进制日志，可以用来进行数据恢复、数据备份等操作。（在我这个项目中用不到，另有备份机制）。</p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>解决方案是这样的：</p><ol><li>在 mysql 命令行中查找 log_bin 相关的配置 <code>show variables like &#39;%log_bin%&#39;;</code></li></ol><p>发现输出包括 <code>log_bin ON</code>，表示二进制日志功能已经被打开。</p><ol start="2"><li>通过 <code>PURGE BINARY LOGS BEFORE &#39;2024-06-26 10:00:00&#39;;</code> 删除原有的日志文件</li></ol><p><strong>必须在日志功能开启的情况下执行上述命令删除文件，否则命令无效</strong></p><ol start="3"><li>在 mysql 启动脚本中添加参数 <code>--disable-log-bin</code>，重启 mysql 服务，再次检查 log_bin 配置</li></ol><p>发现输出包括 <code>log_bin OFF</code>，表示二进制日志功能已经被关闭，后续不再产生日志。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html">Binary Logging Options and Variables</a></li><li><a href="https://www.cnblogs.com/luckly-hf/p/14324957.html">MySQL的binlog日志详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关闭Windows程序弹窗</title>
    <link href="/%E5%85%B3%E9%97%ADWindows%E7%A8%8B%E5%BA%8F%E5%BC%B9%E7%AA%97.html"/>
    <url>/%E5%85%B3%E9%97%ADWindows%E7%A8%8B%E5%BA%8F%E5%BC%B9%E7%AA%97.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录了一个使用工具寻找弹窗、分析弹窗、修改程序的过程，对于理解 Windows 编程有一些作用<br>本文中的内容全部来自于此 <a href="https://www.bilibili.com/video/BV1YM4m1m7qc">视频</a></p></blockquote><span id="more"></span><h1 id="通过-spy-获得弹窗的窗口类"><a href="#通过-spy-获得弹窗的窗口类" class="headerlink" title="通过 spy++ 获得弹窗的窗口类"></a>通过 spy++ 获得弹窗的窗口类</h1><p>spy++ 随着 Visual Studio 一同安装，在工具菜单中。</p><p>通过其中的窗口搜索功能，可以搜索到弹出窗口的窗口名称和窗口类，例如在我的 WinRAR 中：</p><p>广告弹窗可以看到窗口类为 RarReminder</p><ul><li>句柄：001E0A8C</li><li>窗口名称：WinRAR 6.24b1 Expired Notification | Your Free Trial Period has Ended!</li><li>窗口类：RarReminder</li></ul><p>注册弹窗是 Dialog，</p><ul><li>句柄：007A0950</li><li>窗口名称：Please purchase WinRAR license</li><li>窗口类：#32770 (对话框)</li></ul><h1 id="通过-apimonitor-截取软件对系统-api-的调用"><a href="#通过-apimonitor-截取软件对系统-api-的调用" class="headerlink" title="通过 apimonitor 截取软件对系统 api 的调用"></a>通过 apimonitor 截取软件对系统 api 的调用</h1><p>从 <a href="http://www.rohitab.com/">这里</a> 下载工具。</p><p>查找并监控 CreateWindow 相关函数，Dialog 相关函数。</p><p>选择被监控程序 WinRAR 并启动，可以看到程序调用 api 的所有记录。</p><p>广告弹窗调用类为：</p><ul><li>RarReminder</li></ul><p>注册弹窗的调用为：</p><ul><li>DialogBoxParamW ( 0x00007ff643070000, “REMINDER”, 0x0000000000600b84, 0x00007ff64316d600, 0 )</li></ul><p>查看堆栈，记录顶部偏移地址，分别为：</p><ul><li>0xbf3cc</li><li>0xbf46d</li></ul><h1 id="使用-IDA-Pro-修改对应位置的机器码"><a href="#使用-IDA-Pro-修改对应位置的机器码" class="headerlink" title="使用 IDA Pro 修改对应位置的机器码"></a>使用 IDA Pro 修改对应位置的机器码</h1><p>使用 IDA Pro 查找对应位置的机器码，应该是创建窗口或弹窗的内容。</p><p>使用十六进制编辑器，编辑可执行文件，将此处的机器码全部修改为 0x90 （空转）</p>]]></content>
    
    
    <categories>
      
      <category>豆知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>豆知识</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的Linux服务管理</title>
    <link href="/%E7%AE%80%E5%8D%95%E7%9A%84Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.html"/>
    <url>/%E7%AE%80%E5%8D%95%E7%9A%84Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.html</url>
    
    <content type="html"><![CDATA[<p>在这里记录一些基础的 <code>Linux</code> 服务管理维护方式，作为程序员，总是会用到的。</p><span id="more"></span><h1 id="手动运行"><a href="#手动运行" class="headerlink" title="手动运行"></a>手动运行</h1><p>以一个 Java Web 项目为例，手动运行 Jar 包可能是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token function">java</span> <span class="token parameter variable">-jar</span> YongWang-1.0-SNAPSHOT.jar <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这样程序就可以在后台运行，但是有一些缺点：</p><ul><li>系统重启后程序不会启动</li><li>只能通过 <code>ps</code> 查询进程状态</li><li>想要关闭程序的话，需要通过 <code>ps</code> 查找进程号，然后手动 <code>kill</code></li><li>难以接入各种自动化工具</li></ul><p>因此，将程序注册为服务是一个更好的选择。</p><h1 id="使用-root-用户操作系统级服务"><a href="#使用-root-用户操作系统级服务" class="headerlink" title="使用 root 用户操作系统级服务"></a>使用 root 用户操作系统级服务</h1><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><p>如果想将我们的程序注册为服务，首先需要编写一个配置文件，这个文件可以放在 <code>/etc/systemd/system/</code> 路径下。</p><p>文件的名称一般参考服务的名称，并以 <code>.server</code> 结尾，因此在这个例子中，我的文件名为 <code>yongwang.service</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>yongwang.service</span></div><code class="language-text">[Unit]Description=YongWang Server[Service]WorkingDirectory=/home/vc/ywyl/server/ExecStart=java -jar YongWang-1.0-SNAPSHOT.jar[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>之后，需要通过命令注册服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="服务管理命令"><a href="#服务管理命令" class="headerlink" title="服务管理命令"></a>服务管理命令</h2><p>后续我们对服务的管理，一般包括：</p><ul><li>启动服务</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start yongwang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>停止服务</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop yongwang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>查看服务状态</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status yongwang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>设置开机自启</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> yongwang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>取消开机自启</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl disable yongwang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="使用普通用户注册用户级服务"><a href="#使用普通用户注册用户级服务" class="headerlink" title="使用普通用户注册用户级服务"></a>使用普通用户注册用户级服务</h1><h2 id="注册服务-1"><a href="#注册服务-1" class="headerlink" title="注册服务"></a>注册服务</h2><p>对于非 root 用户，也可以使用自身的权限注册用户级服务，将配置文件编写在 <code>/etc/systemd/user/</code> 路径下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>yongwangapp.service</span></div><code class="language-text">[Unit]Description=YongWang Server[Service]WorkingDirectory=/home/lenovo/vc/ywyl/server/ExecStart=java -jar YongWang-1.0-SNAPSHOT.jar[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="服务管理命令-1"><a href="#服务管理命令-1" class="headerlink" title="服务管理命令"></a>服务管理命令</h2><p>普通用户的服务管理命令与 root 用户相似，但都需要添加 <code>--user</code> 参数，例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token parameter variable">--user</span> start yongwang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Jenkins自动部署项目</title>
    <link href="/%E4%BD%BF%E7%94%A8Jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE.html"/>
    <url>/%E4%BD%BF%E7%94%A8Jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者近期遭遇了一些运维上的困扰。</p><span id="more"></span><p>当项目实例部署到很多站点以后，每一次想要更新项目都需要远程连接进入服务器，进行一系列繁琐的运维操作，这样很耽误时间，而且容易犯错，当服务器网络环境不好的时候更是让人非常狂躁。</p><p>当时就想做一个简易的部署工具来解决这个问题，后来又意识到这应该是一个普遍的需求，很可能已经拥有了成熟的工具，向朋友打听后，朋友推荐了 jenkins。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>jenkins 是一个自动化运维工具，在业内应该是被称为 <code>持续集成(Continuous integration)</code> 工具，还有一些什么持续部署，持续交付之类的概念，总之就是一套把程序员的代码变成产品交付给客户的东西。</p><p>jenkins 是一个 JavaWeb 程序，支持非常丰富的插件，而且绝大部分 <code>动作</code> 都是由插件来完成，对了，<code>动作</code> 是我随便用的词，总之就是我们手动部署中的每一个最小化步骤，例如拉代码、打包、上传，我都称为 <code>动作</code>。</p><p>jenkins 里有 <code>项目(Project)</code> 的概念，其实就是一个完整的项目部署过程啦，显而易见的，项目是顺序 <code>动作</code> 的集合。</p><p>jenkins 中的 <code>项目</code> 可以被 <code>执行(Build)</code>，<code>执行</code> 一般就是从代码仓库拉代码、构建项目、部署项目这样三个大的步骤（当然是自动的），每一次 <code>执行</code> 都会有自己的执行结果，执行日志。</p><p>jenkins 中很重要的部分是 <code>插件(plugin)</code>，<code>插件</code> 也是由全世界各地的开发者开发的，很多 <code>动作</code> <code>环境</code> 甚至 <code>项目</code> 还有很多其他各种各样的东西，都是由 <code>插件</code> 提供的，因此当你想使用 jenkins 进行某事情的时候，往往会以 装个插件 作为起点。</p><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><h3 id="拉-SVN-代码，通过-npm-打包，部署到-windows-服务器"><a href="#拉-SVN-代码，通过-npm-打包，部署到-windows-服务器" class="headerlink" title="拉 SVN 代码，通过 npm 打包，部署到 windows 服务器"></a>拉 SVN 代码，通过 npm 打包，部署到 windows 服务器</h3><p>这个例子是一个前端项目，代码存放在 SVN，通过 npm 打包成 dist 文件夹，之后部署到境外的 Windows 服务器上。</p><p>这个例子里，jenkins 直接被安装在了目标服务器上，因此部署操作只需替换文件夹即可。</p><h4 id="svn-相关"><a href="#svn-相关" class="headerlink" title="svn 相关"></a>svn 相关</h4><ul><li>安装 Subversion Plug-in 插件</li><li>全局配置可用账号密码</li><li>在项目中配置代码仓库</li></ul><h4 id="npm-打包相关"><a href="#npm-打包相关" class="headerlink" title="npm 打包相关"></a>npm 打包相关</h4><ul><li>安装 Node 插件</li><li>全局添加 Node 版本环境</li><li>在项目中选择 Node 环境</li><li>配置打包指令 <code>npm -g install</code> <code>npm run build</code></li><li>对于麻烦的 npm 依赖问题，可以直接把开发环境的 node_modules 拷贝到 jenkins 的工作目录</li></ul><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li>删除原文件夹的内容 <code>del /f /s /q D:\arctech-3.1-pak\server\arctech\dist 1&gt;nul</code></li><li>删除原文件夹 <code>rd /s /q D:\arctech-3.1-pak\server\arctech\dist</code>(老版本的windowsServer系统可能有点问题，必须先删内容后删文件夹，参考 <a href="https://stackoverflow.com/questions/22948189/how-to-solve-the-directory-is-not-empty-error-when-running-rmdir-command-in-a">这里</a>)</li><li>复制新文件夹 <code>echo d | xcopy dist D:\arctech-3.1-pak\server\arctech\dist /E</code></li></ul><h3 id="拉-SVN-代码，使用-maven-打-jar-包，部署到-windows-服务器"><a href="#拉-SVN-代码，使用-maven-打-jar-包，部署到-windows-服务器" class="headerlink" title="拉 SVN 代码，使用 maven 打 jar 包，部署到 windows 服务器"></a>拉 SVN 代码，使用 maven 打 jar 包，部署到 windows 服务器</h3><p>从 SVN 拉代码，使用 maven 构建，部署到本机 windows 系统。</p><p>拉代码步骤略过。</p><h4 id="maven相关"><a href="#maven相关" class="headerlink" title="maven相关"></a>maven相关</h4><ul><li>安装 Maven Integration plugin 插件</li><li>配置 pom 文件路径</li><li>配置 mvn 命令 <code>install</code></li><li>配置 Post Steps，仅当 maven 构建成功时执行后续的步骤</li></ul><h4 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h4><ul><li>停用服务 <code>net stop arctech-scada-server</code></li><li>替换文件 <code>copy /Y target\ZXBoPlatform-3.1-SNAPSHOT.jar D:\vc\arctech-3.0-pak\server\ZXBoPlatform\ZXBoPlatform-3.1-SNAPSHOT.jar</code></li><li>启动服务 <code>net start arctech-scada-server</code></li></ul><h3 id="通过-SSH-部署到-Linux-服务器"><a href="#通过-SSH-部署到-Linux-服务器" class="headerlink" title="通过 SSH 部署到 Linux 服务器"></a>通过 SSH 部署到 Linux 服务器</h3><p>通过 SVN 拉代码，使用 maven 构建，部署到远端 Linux 系统。</p><p>拉代码和构建步骤略过。</p><h4 id="通过SSH部署"><a href="#通过SSH部署" class="headerlink" title="通过SSH部署"></a>通过SSH部署</h4><ul><li>安装 SSH 部署插件 <code>Publish Over SSH</code></li><li>在 jenkins system 下，配置 SSH 服务器</li><li>在 maven 项目的构建后步骤中，添加 <code>Send build artifacts over SSH</code></li><li>设置源文件 <code>target/YongWang-1.0-SNAPSHOT.jar</code></li><li>设置目标路径 <code>/ywyl/server_temp</code></li><li>设置部署命令 <code>mv /home/vc/ywyl/server_temp/target/YongWang-1.0-SNAPSHOT.jar /home/vc/ywyl/server/YongWang-1.0-SNAPSHOT.jar &amp;&amp; systemctl restart yongwang</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将打包部署工作自动化以后，对于笔者而言获得了这些收益：</p><ol><li>省去了打包，部署的时间</li><li>降低了项目部署中犯错的可能性</li><li>对于网络环境较差的服务器，提升了部署的成功率</li><li>能够将多个项目实例集中管理起来</li><li>让大家更爱提交代码</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jenkins.io/">jenkins</a></li><li><a href="https://blog.csdn.net/qq_54796785/article/details/133899251">通过SVN钩子，实现提交触发部署</a></li><li><a href="https://blog.csdn.net/sixeleven611/article/details/119664695">使用maven插件构建maven项目</a></li><li><a href="https://blog.csdn.net/liaomingwu/article/details/123483289">使用SSH插件，向目标服务器部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用tun2socks进行全局网络代理</title>
    <link href="/%E4%BD%BF%E7%94%A8tun2socks%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%B1%80%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86.html"/>
    <url>/%E4%BD%BF%E7%94%A8tun2socks%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%B1%80%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86.html</url>
    
    <content type="html"><![CDATA[<p><code>tun2socks</code> (tunnel to socks) 是一种将 tunnel 流量转发到 socks 代理的工具，通常可以用来进行全局流量代理，也可以配合路由表设置，进行一些特定网段的流量代理。</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在介绍 <code>tun2socks</code> 之前，需要先了解一些基本概念的含义：</p><ul><li>tunnel：来自于 TUN&#x2F;TAP，其中的 TUN 表示 tunnel，可以理解为三层代理，而 TAP 可以被理解为二层代理。</li><li>socks：一种应用层代理技术，将进入其中的流量代理到远端服务器。</li><li>虚拟网卡：由 TUN&#x2F;TAP 实现的，操作系统创建的虚拟网络设备，可以像普通网卡一样处理应用程序的流量。</li><li>tunnel2socks：连通虚拟网卡和 socks 服务的工具。</li></ul><p>以下是 <a href="https://github.com/xjasonlyu/tun2socks">xjasonlyu&#x2F;tun2socks</a> 项目中的功能介绍，后续的示例中我们也会使用该项目作为例子：</p><ul><li>全局代理: 处理来自本设备的任意网络应用的所有网络流量并通过代理转发。</li><li>代理协议: 通过 HTTP&#x2F;Socks4&#x2F;Socks5&#x2F;Shadowsocks 远程连接且支持鉴权。</li><li>跨平台性: 具有 Linux&#x2F;macOS&#x2F;Windows&#x2F;FreeBSD&#x2F;OpenBSD 特定优化的多平台支持。</li><li>网关模式: 作为第三层网关处理来自同一网络中其他设备的所有网络流量。</li><li>IPv6 支持: 所有功能都可以在 IPv6 中工作，允许通过 IPv6 代理转发 IPv4 连接，反之亦然。</li><li>TCP&#x2F;IP 栈: 由来自 Google 容器应用程序内核 <a href="https://github.com/google/gvisor">gVisor</a> 的用户空间 TCP&#x2F;IP 网络栈强力驱动。</li></ul><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>为了方便理解，介绍一下笔者所在的网络环境，和本次实验相关的设备共有 3 台：</p><ul><li>笔记本：<ul><li>windows系统</li><li>地址 <code>192.138.34.17/24</code></li><li>网关 <code>192.168.34.1</code>，网关是一台普通路由器</li><li>有互联网连接</li></ul></li><li>内网服务器：<ul><li>linux系统</li><li>地址 <code>192.168.34.197/24</code></li><li>网关为 <code>192.168.34.1</code></li><li>有互联网连接</li><li>运行着一个 socks5 服务，服务地址为 <code>0.0.0.0:1080</code>，socks5 服务和远端服务器已连接</li></ul></li><li>外网服务器：<ul><li>linux系统</li><li>地址为 <code>xx.xx.xx.xx</code>，负责处理通过内网服务器 socks5 服务发来的流量</li></ul></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>接下来的测试按照 xjasonlyu&#x2F;tun2socks 项目提供的 <a href="https://github.com/xjasonlyu/tun2socks/wiki/Examples">示例</a> 进行。</p><h4 id="下载-wintun"><a href="#下载-wintun" class="headerlink" title="下载 wintun"></a>下载 wintun</h4><p><a href="https://www.wintun.net/">wintun</a> 是一个在 windows 系统中创建三层 TUN 的库，只需下载 dll 文件并放在 <code>tun2socks</code> 同文件夹下。</p><h4 id="创建虚拟网卡并设置代理"><a href="#创建虚拟网卡并设置代理" class="headerlink" title="创建虚拟网卡并设置代理"></a>创建虚拟网卡并设置代理</h4><blockquote><p>tun2socks -device wintun -proxy socks5:&#x2F;&#x2F;192.168.34.197:1080 -interface “以太网”</p></blockquote><p>以上命令会开启 <code>tun2socks</code> 进程，创建名为 <code>wintun</code> 的虚拟网卡，并将通过此网卡的流量通过指定的 <code>socks5</code> 服务器代理，通过原有 <code>以太网</code> 网卡转发。</p><h4 id="配置虚拟网卡"><a href="#配置虚拟网卡" class="headerlink" title="配置虚拟网卡"></a>配置虚拟网卡</h4><p>在新的命令行窗口中键入命令，进行虚拟网卡配置：</p><blockquote><p>netsh interface ipv4 set address name&#x3D;”wintun” source&#x3D;static addr&#x3D;192.168.123.1 mask&#x3D;255.255.255.0</p></blockquote><blockquote><p>netsh interface ipv4 set dnsservers name&#x3D;”wintun” static address&#x3D;8.8.8.8 register&#x3D;none validate&#x3D;no</p></blockquote><p>上述两条命令设置网卡的地址、掩码、DNS 服务器，让他看起来像一个正常的网卡。</p><h4 id="配置默认路由"><a href="#配置默认路由" class="headerlink" title="配置默认路由"></a>配置默认路由</h4><blockquote><p>netsh interface ipv4 add route 0.0.0.0&#x2F;0 “wintun” 192.168.123.1 metric&#x3D;1</p></blockquote><p>通过上述命令添加一条经过虚拟网卡的默认路由，之后全局流量都会通过虚拟网卡转发。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>测试时使用了一个不支持 UDP 的 socks5 代理，导致 DNS 解析功能受阻，如果想使用完整全局代理功能，需要另选 socks5 代理软件。</li></ul><p>后来使用支持 udp_over_tcp 的代理套了一层，解决了惯用 socks 代理不能代理 UDP 的问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/xjasonlyu/tun2socks">tun2socks</a></li><li><a href="https://www.wintun.net/">wintun</a></li><li><a href="https://tachyondevel.medium.com/%E6%95%99%E7%A8%8B-%E5%9C%A8-windows-%E4%B8%8A%E4%BD%BF%E7%94%A8-tun2socks-%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86-aa51869dd0d">[教程] 在 Windows 上使用 tun2socks 进行全局代理</a></li><li><a href="https://en.wikipedia.org/wiki/TUN/TAP">TUN&#x2F;TAP</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Go中嵌入静态文件</title>
    <link href="/%E5%9C%A8Go%E4%B8%AD%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6.html"/>
    <url>/%E5%9C%A8Go%E4%B8%AD%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文内容来自于 <a href="https://pkg.go.dev/embed">embed</a></p></blockquote><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>embed 包提供了在 Go 程序中嵌入静态文件以及访问 Go 程序中静态文件的能力。</p><p>Go 程序可以通过引入 embed 包并使用 &#x2F;&#x2F;go:embed 指令在编译期将类型为 string、[]byte 或 FS 的变量初始化为文件或文件夹的内容。</p><p>例如，这里提供了三种嵌入 hello.txt 文件并打印内容的示例。</p><p>将单个文件嵌入为 string：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token boolean">_</span> <span class="token string">"embed"</span><span class="token comment">//go:embed hello.txt</span><span class="token keyword">var</span> s <span class="token builtin">string</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>将单个文件嵌入为 bytes 切片：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token boolean">_</span> <span class="token string">"embed"</span><span class="token comment">//go:embed hello.txt</span><span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>将一个或多个文件嵌入为文件系统（FS）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"embed"</span><span class="token comment">//go:embed hello.txt</span><span class="token keyword">var</span> f embed<span class="token punctuation">.</span>FSdata<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>变量声明上方的 &#x2F;&#x2F;go:embed 指令使用一条或多条 path.Match 模板指定要嵌入的文件。</p><p>指令必须直接位于单个变量声明的上方，在指令和变量声明之间只允许存在空行或 &#x2F;&#x2F; 开头的行注释。</p><p>变量的类型必须是 string、byte 切片或者 FS（或者 FS 的别名）。</p><p>例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> server<span class="token keyword">import</span> <span class="token string">"embed"</span><span class="token comment">// content holds our static web server content.</span><span class="token comment">//go:embed image/* template/*</span><span class="token comment">//go:embed html/index.html</span><span class="token keyword">var</span> content embed<span class="token punctuation">.</span>FS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Go 构建系统将识别指令并安排声明的变量（在上面的示例中为 content）用文件系统中的匹配文件填充。</p><p>为了简洁起见，&#x2F;&#x2F;go:embed 指令允许在一行中使用多个空格分隔的模板，同时为了避免当模板太多时造成过长的行，指令也允许被分为多行。模板使用源文件包所在的相对路径解析，使用 &#x2F; 分隔路径，即便在 Windows 系统中也是如此。模板不能包含 ‘.’ ‘..’ 或空路径元素，也不能以 &#x2F; 开始或结尾。如果需要匹配当前路径中的所有元素，请使用 ‘*’ 而不是 ‘.’。为了允许支持名称中包含空格的文件，可以将模板写为 Go 格式的双引号或反引号字符串。</p><p>如果模板内容是文件夹名称，则文件夹中所有的内容都会被嵌入（递归），除了以 ‘.’ 或 ‘_’ 开头的文件。因此上述例子中的变量声明等同于：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// content is our static web server content.</span><span class="token comment">//go:embed image template html/index.html</span><span class="token keyword">var</span> content embed<span class="token punctuation">.</span>FS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>区别在于 ‘image&#x2F;*’ 嵌入了 ‘image&#x2F;.tempfile’ 而 ‘image’ 不会嵌入，两种写法都不会嵌入 ‘image&#x2F;dir&#x2F;.tempfile’。</p><p>如果模板使用 ‘all:’ 前缀开头，则在遍历时会加入 ‘.’ 和 ‘_’ 开始的文件，例如，’all:image’ 既可以嵌入 ‘image&#x2F;.tempfile’ 也可以嵌入 ‘image&#x2F;dir&#x2F;.tempfile’。</p><p>&#x2F;&#x2F;go:embed 指令既可以用于导出的或不导出的变量，这取决于包是否想将数据内容提供给其他包使用。指令只能被用于包层级的变量，不能被用于本地变量。</p><p>模板不能用来匹配包之外的文件，例如 ‘.git&#x2F;*’ 或是应用链接，模板不能用来匹配名称带有特殊字符的文件，<code>" * < > ? ` ' | / \ :</code>，对空文件夹的匹配会被忽略，此外，每个 &#x2F;&#x2F;go:embed 行中的模板至少需要匹配到一个文件或者一个非空的文件夹。</p><p>如果模板无效或匹配内容无效，构建将会失败。</p><h2 id="Strings-和-Bytes"><a href="#Strings-和-Bytes" class="headerlink" title="Strings 和 Bytes"></a>Strings 和 Bytes</h2><p>匹配 string 或 []byte 类型变量的 &#x2F;&#x2F;go:embed 指令必须只包含一个模板，而且模板必须只匹配到一个文件。string 或 []byte 变量的值将被初始化为文件的内容。</p><p>使用 &#x2F;&#x2F;go:embed 指令需要先引入 embed 包，即便是仅使用 string 或 []byte，不使用 embed.FS。此时可以使用空标识符引入（import _ “embed”）。</p><h2 id="File-Systems"><a href="#File-Systems" class="headerlink" title="File Systems"></a>File Systems</h2><p>对于单个文件的嵌入，最佳方式往往是 string 或 []byte。FS 类型允许嵌入一组树状结构的文件，例如一个静态 WEB 服务器的内容，就像上文中例子里提到过的那样。</p><p>FS 实现了 io&#x2F;fs 包中的 FS 接口，因此它可以被任何理解该接口的包使用，例如 net&#x2F;http，text&#x2F;template 和 html&#x2F;template。</p><p>例如，通过使用上文例子中的 content 变量，我们可以：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/static/"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">StripPrefix</span><span class="token punctuation">(</span><span class="token string">"/static/"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">FileServer</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">FS</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>template<span class="token punctuation">.</span><span class="token function">ParseFS</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"*.tmpl"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>为了支持 Go 包分析工具，&#x2F;&#x2F;go:embed 指令中的模板也会在 “go list” 输出中可见，请查看 “go help list” 中的 EmbedPatterns，TestEmbedPatterns 和 XTestEmbedPatterns 部分。</p><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"embed"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token comment">//go:embed internal/embedtest/testdata/*.txt</span><span class="token keyword">var</span> content embed<span class="token punctuation">.</span>FS<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">FileServer</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">FS</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]无痛功能规格说明书——Part4：提示</title>
    <link href="/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part4%EF%BC%9A%E6%8F%90%E7%A4%BA.html"/>
    <url>/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part4%EF%BC%9A%E6%8F%90%E7%A4%BA.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.joelonsoftware.com/2000/10/15/painless-functional-specifications-part-4-tips/">Painless Functional Specifications – Part 4: Tips</a></p></blockquote><span id="more"></span><head>  <style>    .greenTitle {      color: #008000;    }  </style></head><p>我们已经讨论过了 <a href="https://www.joelonsoftware.com/articles/fog0000000036.html">为什么您需要规格说明</a>，<a href="https://www.joelonsoftware.com/articles/fog0000000035.html">规格说明中应该有什么</a>，以及 <a href="https://www.joelonsoftware.com/articles/fog0000000034.html">谁负责编写规格说明</a>。在本系列的第四章也是最终章，我将要分享一些关于编写规格说明的建议。</p><p>在一个经常编写规格说明的团队中，您常常能听到最大抱怨是“压根没人去读他们”，如果规格说明真的没人读，那么负责编写规格说明的人难免会变得愤世嫉俗。这就像一个经典的 Dilbert 漫画，里面工程师们用厚达 4 英寸的规格说明文档堆砌成隔板来扩展他们的工作隔间。在典型的大公司里，每个人都要花上好几个月的时间来撰写枯燥乏味的规格说明。一旦规格说明完成，他就会被束之高阁，再也不会被翻阅，最终产品会从头开始开发，完全不顾及规格说明的内容，因为根本没人会去读他，因为他实在让人昏昏欲睡。撰写规格说明的过程本身可能是一项有益的练习，因为他迫使每个人至少都去思考相关的问题。但问题在于，当规格说明完成后，他失去了作用（无人阅读，无人喜爱），这会让人觉得所有付出的努力都白费了。</p><p>另外，如果您的规格说明从未被仔细阅读，那么最终产品交付时就会带来很多争论。 某个人（可能是管理层、营销人员或客户）会说：“等等！你答应过我会有一个蛤蜊蒸锅功能！蛤蜊蒸锅呢？” 程序员则会回应：“不，实际上，如果你查看规格说明的第 3 章、第 4 小节、第 2.3.0.1 段，你会发现他明确写着‘没有蛤蜊蒸锅’。” 但这并不能让客户满意，因为“顾客永远是对的”，所以脾气暴躁的程序员不得不回去给产品强行添加一个蛤蜊蒸锅功能（这让他们更加愤世嫉俗地看待规格说明）。同样的情况也可能发生在管理层身上。例如，一位经理可能会说：“所有对话框里的文字都太冗长了，每个对话框顶部都应该放一个广告。” 然后沮丧的程序员会辩解道：“但是你批准了规格说明，里面精确地列出了每个对话框的布局和内容！” 然而，经理当然没有真正读过规格说明，因为在他尝试阅读时，他大脑里的内容满的都快要从眼眶里渗出来，而且这还影响了他周二的打高尔夫球计划。</p><p>综上所述，规格说明书是好东西，但是如果没人阅读他就毫无作用。作为一名规格说明的编写者，您必须引诱别人来阅读您的作品，您还必须小心谨慎，不要向别人小小的脑袋里塞太多东西，避免那些东西从他们的眼眶里渗出来。</p><p>引诱别人来阅读您的作品意味着您需要写出好作品，但是如果我只是撂下一句“要成为一个好作者”那显然有些不公。这里有四条规则，您 <em>必须</em> 要遵守，这样才能写出容易被人阅读的规格说明书。</p><p><span class="greenTitle">规则一：有趣</span></p><p>引诱别人来阅读您的规格说明的第一条规则就是要让阅读体验变得有趣，别跟我说什么您天生无聊，我不买这个帐。每个人在每个时刻都有一些有趣的想法，他们只是自我审查一番之后觉得这些东西“上不得台面”，emmm，有时您必须打破规则。</p><p>如果您阅读过我在本站上写的 <a href="https://www.joelonsoftware.com/navLinks/fog0000000247.html">volumes of garbage</a>，您就会发现我零星散落着一些各种搞笑的尝试，就在几段话前我还在调侃管理人员的脑容量和他们打高尔夫的事情。即使我不是真的很有趣，我也在努力的去尝试，而且这种笨拙的搞笑尝试本身也会让别人觉得好笑，就像是悲伤的小丑一样。当您编写规格说明时，一个很容易逗笑读者的地方是示例部分。每当您需要通过一个故事来阐述某种功能原理时，不要这样：</p><ul><li>用户输入 Ctrl+N 以创建新的雇员表，并开始输入雇员名称。</li></ul><p>而是应该这样：</p><ul><li>佩奇小姐用眼线笔戳着键盘，因为她胖乎乎的小手指太胖了，无法按单个按键，她键入 Ctrl+N 创建一个新的男友表，并键入单个记录“Kermit”。</li></ul><p>如果您曾大量阅读过 <a href="http://www.miami.com/mld/miamiherald/living/columnists/dave_barry/">Dave Barry</a>，您会发现有一种简单的搞笑方式就是在不必要的情况下加入大量具体的细节。“精力充沛的哈巴狗”比“狗”更有趣、“佩奇小姐”比“用户”更有趣，与其说“利益相关方”，不如说“左撇子的鳄梨农夫”，与其说“那些拒绝清理狗屎的人应该收到惩罚”，不如说他们应该被“关进那种孤独到让他们想上自己的狗的监狱”。</p><p>哦，对了，如果您认为加入幽默元素显得不够专业，那很遗憾，只能说您没有幽默感。（别否认了，没有幽默感的人总是会否认，你骗不了我。）如果您所在的公司因为您的规格说明轻松有趣、易于阅读而降低了对您的尊重，那么就去 <a href="http://www.fogcreek.com/">找另一家公司</a> 吧，因为人生苦短，实在没必要在如此严肃悲惨的环境里浪费宝贵的时间。</p><p><span class="greenTitle">规则二：编写规格说明就像是编写大脑可执行的代码</span></p><p>这就是我觉得程序员在编写规格说明的路上可能遇到的阻碍。</p><p>当您编写 <em>代码</em> 时，您的受众是 <em>编译器</em>，是的，我知道别人也可以去读代码，但是这 <a href="https://www.joelonsoftware.com/articles/fog0000000069.html">对他们来说很难</a>。对于大部分程序员来说编写能够被编译器正确阅读和解释的代码已经足够难了，而编写人类能够阅读的代码更是成了一种奢求。无论是您编写：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">print_count</span><span class="token punctuation">(</span> FILE<span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span>  <span class="token operator">*</span>  b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> “there are <span class="token operator">%</span>d <span class="token operator">%</span>s\n”<span class="token punctuation">,</span> c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> n <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token function">print_count</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> “employees”<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token comment">/* codedeliberately obfuscated */</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>还是</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span>“there are <span class="token number">10</span> employees\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>您得到的输出都是 <em>相同的</em>，这就是为什么，如果您仔细想想，您会发现程序员往往会写出这种东西：</p><blockquote><p>假设函数 AddressOf(x) 定义为基于 RFC-822 说明的合法的 ANSI 字符串邮箱地址对用户 x 的映射。假设有用户 A 和用户 B，当用户 A 想要发送邮件给用户 B 时，A 初始化一个新的消息（使用别处定义的，但并非使用全部的技术），之后将 AddressOf(B) 输入至 To: 编辑框。</p></blockquote><p>这段话也可以这样写：</p><blockquote><p>佩奇小姐想要去吃午饭了，因此她创建了一封新邮件并将 Kermit 的邮箱地址输入到 To: 中。</p><p><strong>技术旁注：</strong>邮箱地址必须符合 RFC-822 规范。</p></blockquote><p>理论上，他们都“表达”相同的一件事，但是第一个例子您必须仔细 <em>解码</em> 后才能理解，而第二个例子则非常容易理解。程序员往往喜欢把规格说明写得像学术论文。他们总是觉得一份“正确”的规格说明必须做到“技术上”正确，这样他们就精准的完成了自己的工作（也无需承担更多责任）。</p><p>这里的关键在于当您编写一个规格说明时，除了要保持正确之外，还必须 <em>能够被理解</em>，用程序员的术语来说的话，意思是规范必须被编写的能够被人脑“编译”。电脑和人脑的最大区别之一就是电脑会坐在那里静静的等待您进行各种各样的预定义，而除非您激发了读者的兴趣，否则人脑根本不会知道您在说啥。人们压根不想进行任何解码理解，他们只想要按顺序阅读下去并且理解全部事情。对于人类来说，您必须先和他们描绘一幅模糊的总体图景之后再填充细节，而对于电脑程序来说，您可以让代码从头一直执行到底，细节内容出现在他们需要的地方。电脑不会在意您的变量名是否具有含义，而人脑则更适合通过故事来理解一幅生动的图景，即便是一个故事的片段，因为我们的大脑已经进化到了可以理解故事的程度。</p><p>如果您摆出一副实战中局的棋盘，一位经验丰富的棋手只需要花一两秒钟就可以记住每个棋子的位置。但是如果您将几个棋子移动到了正常情况下他们不会出现的位置（例如，把一些兵放在第一行，或者将两个黑象都放在黑格中），对于棋手来说记忆这个棋盘就变得困难了很多很多，这就是人脑和电脑思维方式的差别，对于记录棋盘的电脑程序来说，棋子的位置合理与否与他的记忆功能毫无关系。人脑的工作方式不是随机存取的，在面对常见的情况时，我们的大脑通路会得到加强，理解事情的能力也会变强。</p><p>因此，编写规格说明时，请尝试想象您的目标读者是谁，并设身处地思考他们理解每个步骤需要哪些信息。逐句审视，扪心自问读者是否能深刻理解该句子，以及它和您之前所述内容之间的关联。如果目标受众中的一部分人不知道什么是 RFC-822，那么您既可以定义它，或者至少将它放在技术注释中，这样管理层在阅读规格说明时，就算遇到生僻的技术术语也不会放弃继续阅读。</p><p><span class="greenTitle">规则三：尽可能地简单</span></p><p>不要由于您认为使用简单的句子写作显得不够专业而刻意的使用呆板、正式的语言，您要尽可能的使用简单的语言。</p><p>有些人使用“功能规格说明书”这种词汇是因为他们觉得“功能文档”看起来不专业。（这里又一次提及到了词汇“不专业”，任何时候当有人告诉您不应该做某事只是因为他“看起来不专业”时，您就应该知道他们已经找到不到您事实上的缺陷了）。事实上我观察发现<strong>很多人觉得把文档写的简单易读就意味着有问题</strong>。</p><div style="display: flex;justify-content:space-around;">  <p>    把事情分解成短句，如果一句话解释不清楚，就用两三句话。    <br/>    避免文本墙（整页都是文字），读者会被你吓到然后“太长不看”。您上次在时尚杂志或者新闻报纸上看到整页都是文本是多久以前的事了？杂志甚至会从文章中引用并以巨大的字体打印在页面中间，只是为了避免出现整页文本。使用编号或项目符号列表、图片、图表、表格和大量空白，使阅读“看起来”更蓬松。  </p>  <div style="width:40%;"></div>  <p style="flex-shrink: 0.5;color: #000080">    “杂志甚至会从文章中引用并以巨大的字体打印在页面中间，只是为了避免出现整页文本。”  </p></div><p>没有什么比大量的截屏更能提升规格说明的可读性，一图胜千言。任何为 Windows 上运行的软件编写规格说明的人都应该买一份 Visual Basic，学习如何使用他 <em>至少</em> 能用来表达原型设计，（对于 Mac 电脑，可以使用 REAL Basic；对于 Web 页面，可以使用 Front Page 或者 Dreamweaver），之后截图并把图片放在您的文档中。</p><p><span class="greenTitle">规则四：多次校对</span></p><p>emmm，好吧，我本来打算在这里对这个规则进行长篇大论的描述，但是这个规则实在是太简单了，多校对几次，就这样就行。当您觉得某句话难以理解时，就把他改写的简单一些。</p><p>规则四实在太简单了，我打算加一个规则五。</p><p><span class="greenTitle">规则五：有害的模板</span></p><p>要拒绝制作一个标准规格说明模板的诱惑，一开始您可能只是觉得让“每个规格说明都具有相同的格式”这很重要，但事实上：不要。但为什么不应如此呢？您家书架上的每本书看起来是否相同呢？您是否想让他们看起来相同呢？</p><p>更糟糕的是，一旦您拥有了模板，您就会开始有一些每个功能点都需要填写的“必备章节”。例如：Bill 老大规定，从现在开始，每个 Microsquish 产品都应该有互联网组件，因此现在规格说明书模板被添加了被称为“互联网组件”的章节，任何时候只要有人在编写规格说明，不管是否相关，他都必须填写这个被称为“互联网组件”的章节，即使他所写的规格说明只是用来描述 Microsquish 键盘。（您开始疑惑为什么那些无用的互联网商城按钮像蘑菇一样开始在键盘上疯长）。</p><p>随着这种章节的累计，模板会变得越发庞大。（这里有一个非常非常坏的规格说明书的 <a href="http://www.construx.com/survivalguide/desspec.htm">例子</a>，老天，谁需要带着参考书看规范？或者说带着词汇表？）这种大模板带来的麻烦之一就是会吓跑那些需要写规格说明的人，这份工作看起来实在是太可怕了。</p><p>归根结底，规格说明就是一份您希望别人去阅读的文档，他和《纽约客》上的散文或者大学里的论文没什么本质上区别。您是否听说过大学教授为学生发放论文模板？您是否听说过两篇优秀的散文能套入同一个模板？放弃这种念头吧。</p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>软件项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]无痛功能规格说明书——Part3：谁去做？</title>
    <link href="/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part3%EF%BC%9A%E8%B0%81%E5%8E%BB%E5%81%9A%EF%BC%9F.html"/>
    <url>/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part3%EF%BC%9A%E8%B0%81%E5%8E%BB%E5%81%9A%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.joelonsoftware.com/2000/10/04/painless-functional-specifications-part-3-but-how/">Painless Functional Specifications – Part 3: But… How?</a></p></blockquote><span id="more"></span><head>  <style>    .greenTitle {      color: #008000;    }  </style></head><p>现在，您应该已经阅读了 <a href="https://www.joelonsoftware.com/2000/10/02/painless-functional-specifications-part-1-why-bother/">为什么要写规格说明</a> 和 <a href="https://www.joelonsoftware.com/2000/10/03/painless-functional-specifications-part-2-whats-a-spec/">什么是规格说明</a>，接下来让我们聊聊谁去编写规格说明。</p><p><span class="greenTitle">谁去编写规格说明？</span></p><p>允许我和您谈一点微软的历史，在微软认真发展的 1980 年代，微软的每个人都阅读过 <a href="http://www.amazon.com/exec/obidos/ASIN/0201835959/ref=nosim/joelonsoftware">人月神话</a>，那是软件管理领域的经典著作（如果您还没有读过，我强烈推荐您阅读）。那本书中的主要观点之一就是当您向一个延误的项目增加程序员人手时，项目反而会延误的更加严重。假设您的开发团队有 n 个程序员，那么沟通路径的条数会是 n(n-1)&#x2F;2，以 O(n^2) 的速度增长。</p><p>因此，如何去编写越来越庞大的软件成了微软的一个挑战，当时流行的观点是增加程序员的数目会让事情变得更糟。</p><p>Charles Simonyi，彼时微软的“首席架构师”，提出了一个名为 <em>大师级程序员</em> 的概念。基本理论是一个大师级程序员应该负责编写所有的代码，但是他可以组织一帮初级程序员作为他的“码农”，这样他就不必要操心调试每个函数，大师级程序员只需要进行每个函数的原型设计、创建简单的程序轮廓，之后丢给码农们去实现。（当然，Simonyi 自己会是“特级大师级程序员”）。考虑到“大师级程序员”这个词过于中世纪，微软将他改名为“程序经理”（Program Manager）。</p><p>理论上说，这应该可以解决人月神话问题，因为程序员之间不再必须相互沟通——每个码农只需要和他的程序经理沟通，因此沟通成本的增速度从 O(n^2) 降低到了 O(n)。</p><p>好吧，Simonyi 可能非常了解 <a href="http://msdn.microsoft.com/library/techart/hunganotat.htm">匈牙利命名法</a>，但是他不太了解人心，没人甘于当个码农，这套系统根本没法运作。最终，微软意识到尽管据称他们打破了人月神话，他们确实可以通过向团队里增加聪明的小伙子来增加产出，但是这种效果是边际递减的。在我还在那边工作的时候，Excel 团队拥有 50 名程序员，这个团队的生产力比 25 人团队要高一些——但是远远不到两倍。</p><p>这种 编程大师&#x2F;码农 的架构备受指责，但是微软仍然保留了程序经理这个岗位名称。一个叫做 Jabe Blumenthal 的聪明人基本上重塑了程序经理的定位。从他以后，程序经理将负责产品设计和产品规格说明书。</p><p>从那时开始，微软的程序经理负责收集需求，搞清楚代码究竟需要用来支持什么，并 <em>编写功能规格说明书</em>。一般来说每个程序经理会配有 5 个程序员，这些程序员负责使用代码实现程序经理已经在规格说明中使用文档实现的内容。程序经理还需要去协调市场、文档、测试、本地化，等等一切程序员不该浪费时间的工作。最后，微软的程序经理需要顾全公司的“大局”，而程序员则可以自由的专注于让他们的代码完全正确。</p><p>程序经理至关重要。如果您曾经抱怨过程序员只考虑代码实现而根本不懂市场影响，您需要一个程序经理。如果您曾经抱怨过能写出好代码的人为什么总是写不出好文档，您需要一个程序经理。如果您曾经抱怨过您的产品方向似乎总是左右摇摆，您需要一个程序经理。</p><p><span class="greenTitle">您如何雇佣一位程序经理？</span></p><p>让我感到失望的一点是，大部分公司甚至都还没有程序经理的概念。在我上班的时候，由强大的程序经理带领的微软团队制作了很多成功的产品：Excel、Windos 95、Access 等等。但是有些其他的团队（例如 MSN 1.0 或者 Windows NT 1.0）在开发的过程中则忽略了他们的程序经理（这些程序经理能力一般，被忽略也许情有可原），他们的产品就没有这么成功。</p><p>这里是需要避免的三件事。</p><p><strong>1. 不要直接将程序员晋升为程序经理</strong> 程序经理的核心能力（清晰的文档表达、外交能力、市场意识、用户同理心和UI设计能力）和成长为一名优秀程序员没有什么关系，确实，有些人既是优秀的程序员，也具备这些能力，但是这种人很稀缺。把优秀的程序员 <em>晋升</em> 到一个他不熟悉的领域，本来他是写 C++ 的，现在开始写文档了，这是 <a href="http://www.amazon.com/exec/obidos/ASIN/1568491611/ref=nosim/joelonsoftware">Peter Principle</a> 的经典案例：人们会被晋升到他实际上不擅长的岗位。</p><p><strong>2. 不要让市场部的员工去当程序经理</strong> 无意冒犯，但是我认为我的读者会赞同这个观点：市场部的员工通常无法掌握产品设计过程中的技术问题。</p><p>基本上，程序经理是一个单独的路径，所有的程序经理都必须对技术了如指掌，但是他们不必成为优秀的程序员。程序经理需要学习 UI 设计，会见客户，<em>编写规格说明</em>。他们需要与各种各样的人相处——从“白痴”客户，到穿着《星际迷航》cos服上班的二次元程序员，到穿着 2000 美元西装套装的浮夸销售人员。从某些方面来说，程序经理是软件团队的粘合剂，他的个人魅力至关重要。</p><p><strong>3. 不要让程序员向程序经理汇报</strong> 这是一个很容易被忽视的错误。我在微软担任程序经理时，设计了 Excel 的 Visual Basic 应用程序 (VBA) 策略，并详细制定了 VBA 在 Excel 中的实现规范，这份规格说明书细致到每个细节，足足有 500 多页。在 Excel 5.0 开发高峰期，我估计每天早上有 250 人上班后，基本上都是参照我写的那份庞大规范工作的。我根本不知道这些人是谁，但仅 Visual Basic 团队就有大约十几个人专门负责这项工作的文档编写（更不用说 Excel 团队的文档编写人员，以及负责帮助文件中超链接的全职人员了）。奇怪的是，我在汇报架构中处于“底层”，是的，<strong>没人</strong>向我汇报工作。如果我想让人们做某件事，我必须说服他们，让他们相信这是正确的做法。当首席开发人员 Ben Waldman 不想做我规格说明中的某些内容时，他直接就可以不做。当测试人员抱怨我设计的内容无法完全测试时，我就得进行简化。<strong>如果这里的任何一个人需要向我汇报，那么产品都不会像最终成功那么出色。</strong>有些人可能会认为质疑上级是不合适的，另一些时候，我可能会出于自负或目光短浅，直接命令他们按照我的方式去做。但实际情况是，我别无选择，只能努力达成共识，这种决策方式才是做出<em>正确决定</em>的最佳途径。</p><p>我关于规格说明系列文章的 <a href="https://www.joelonsoftware.com/articles/fog0000000033.html">最后一篇</a> 讨论了如何编写一个人们愿意去阅读的规格说明书。</p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>软件项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]无痛功能规格说明书——Part2：什么是规格说明书？</title>
    <link href="/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part2%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%9F.html"/>
    <url>/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part2%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.joelonsoftware.com/2000/10/03/painless-functional-specifications-part-2-whats-a-spec/">Painless Functional Specifications – Part 2: What’s a Spec?</a></p></blockquote><span id="more"></span><head>  <style>    .greenTitle {      color: #008000;    }  </style></head><p>(您是否已经阅读了 Part1？如果没有，请点击 <a href="https://www.joelonsoftware.com/2000/10/02/painless-functional-specifications-part-1-why-bother/">这里</a>。)</p><p>这一系列文章探讨的内容是 <em>功能规格说明书</em>，而非 <em>技术规格说明书</em>，人们总是混淆这两个概念。我不太清楚是否有标准化术语，但是当 <em>我</em> 提到这两个词时，意思分别是：</p><ol><li><p><em>功能规格说明书</em> 描述了在用户视角中的产品如何工作，他并不在意具体实现方式。他讨论的是产品功能，他决定了屏幕上的显示内容、菜单内容、弹窗，等等这些。</p></li><li><p><em>技术规格说明书</em> 描述了程序内部的实现，他讨论的是数据结构、关系型数据库模型、编程语言和框架的选择、算法，等等这些。</p></li></ol><p>当您设计一个产品时，无论他是内部的还是对外的，最要紧的事情就是锁定用户体验：屏幕上显示的是什么、用户可以如何使用、用户用产品做什么，随后，您开始考虑无处不在的弹窗和组件细节。在您完全决定这些内容之前根本不需要考虑使用什么编程语言，在这一系列文章中，我只讨论这一部分，也就是 <em>功能规格说明书</em>。</p><p>我写了一个简短的功能规格说明书示例，用来给您演示。在我们进行下一步之前，请 <a href="%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part2%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%9F/WhatTimeIsIt.pdf">阅读示例</a>。（示例中的 <a href="%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part2%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%9F/%E6%B5%81%E7%A8%8B%E5%9B%BE.png">流程图</a>）</p><p>您已经阅读了吗？</p><p>您还没读吧&#x3D;。&#x3D;，去 <a href="%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part2%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%9F/WhatTimeIsIt.pdf">读完示例</a> 再回来，这样我们才能去聊一个好的规格说明应该包含什么或者不包含什么。我会在这里等着你的，感谢。</p><p>（耐心等待中…）</p><p>啊，太好了，您回来了。</p><p>以下是一些我在每个规格说明书中都惯例添加的内容。</p><p><span class="greenTitle">免责申明</span> 纯粹的自我保护作用，如果您写了一段类似于“这个规格说明书尚未完整”，人们才不会冲进你的办公室咬你的头。随着时间的推移，当规格说明逐渐完整的时候，您可以将其改为“按照我目前的了解，该规格说明书已经完成，但如果我遗漏了任何事情，请联系我。”，这也提醒了我，每一个规格说明书都需要：</p><p><span class="greenTitle">有且只有一个作者</span> 有些公司觉得文档应该由一个 <em>团队</em> 完成，但是如果您尝试过集体写作，您就应该知道这事有多操蛋。把集体写作这个活留给那些拥有大批哈佛应届生军团的管理咨询公司吧，他们需要做大量忙碌的工作来证明他们的收费是合理的，而您的规格说明只需要 <em>一个人</em> 负责编写，如果您有一个大项目，那就把他拆成小块，每一块由一个人负责编写规格说明。还有些公司觉得让某一个人在规格说明上署名是一种“自负”或者说“窃取了团队的荣誉”，废话，对某件事 <em>负责任</em> 的人理所当然的拥有对这件事的 <em>处置权</em>。如果规格说明中的有些内容写错了，就必须有一个该规格说明的拥有者，一个把自己名字写在规格说明上的人，负责去修复他。</p><p><span class="greenTitle">应用场景</span> 当您在设计产品时，您需要在脑海中设想一些人们在现实生活中使用您产品的场景。否则您最终只会设计出对现实世界没有任何作用的产品（例如 <a href="https://www.joelonsoftware.com/articles/fog0000000037.html">Cue?Cat</a>）。考虑您的产品受众，为您产品的每种类型用户假设一个虚构的、完全基于想象的刻板印象。在我的 UI 设计书（免费在线 <a href="https://www.joelonsoftware.com/uibook/chapters/fog0000000057.html">阅读</a>）的 <a href="https://www.joelonsoftware.com/uibook/chapters/fog0000000065.html">第九章</a> 谈到了如何创建虚构的用户和场景。将这些基于想象的用户带入您的场景，场景越生动具体，您为用户设计的细节就会越好，这就是为什么我倾向于设置大量虚拟细节。</p><p><span class="greenTitle">非目标</span> 当您与一个团队一起开发产品时，每个人都倾向于往里塞一些他们最钟爱的、赖以生存的、真实的或者基于想象的宠物功能，如果您接受了所有这些功能，您的产品开发只会需求无限的工期和无限的金钱。您必须立刻开始剔除这些功能，而做这件事最好的方法就是在规格说明中添加“非目标”章节，明确的表示不打算做的事。非目标可以用来表达您不计划实现的功能（“不支持脑电波交互！”）或者更常规的（“我们不在乎这个版本的性能。这个产品运行的很慢，但是只要能用就行。如果我们有时间开发 2.0，我们会找机会修一下。”）这些非目标的内容可能会引起一些争议，但是重要的是赶快明确并公开。“我们没打算做这个！”就像 George Sr. 说过的。</p><p><span class="greenTitle">总览</span> 这就像您规格说明中的内容目录，可以是一个简单的流程图，也可以是一个架构的细致讨论。每个人都会阅读总览部分来了解整体架构，然后再去阅读细节部分才会更容易理解。</p><p><span class="greenTitle">细节，细节，还有细节</span> 最终，您开始处理细节，在需要了解某些具体的细节实现前，大部分读者不会仔细的阅读这些内容。当您在设计一个基于 web 的服务时，一个很好的做法是给每一个页面分配一个规范的名称，并使用一个单独的章节来描述这个页面中所有令人麻木的细节。</p><p><em>细节</em> 是规格说明书中最重要的内容。您应该已经注意到了在示范的规格说明书中我如何使用 <em>令人发指的</em> 详细方式来描述登录中的错误处理。当 email 地址不合法时如何处理？当密码不正确时如何处理？所有这些情况都对应着后续实施中真的需要编写的代码，而且，更重要的是，这些情况对应着事情该怎么做的决定。总有人需要负责决定当用户忘记密码以后该如何处理，如果没有决定，代码就无法编写，规格说明的职责之一就是记录这些决定。</p><p><span class="greenTitle">开放讨论</span> 在初版规格说明放置开放讨论是完全没有问题的，当我编写第一版的草稿时，我通常会放置大量开放问题，但我会标记他们（使用某种特殊的格式以便我后期检索），而且如果合适的话，我会加一些自己的建议方案。在程序员开始工作之前，所有这些开放讨论都必须被拍板。（您可能觉得可以让程序员先从简单、已经明确的部分开始施工，随后您再去解决剩下的开放问题，但这其实是个蠢主意，因为除了那些您事先已经了解到而且应该解决的问题外，随着代码实现工作的开始，您还会遇到无数个新的需要解决的问题。另外，您对任何问题解决方式的决议都有可能对代码的设计和编写产生影响）。</p><p><span class="greenTitle">旁注</span> 当您在编写规格说明时，请记住您的读者群体是多样化的：程序员、测试员、市场同事、文档哥等等。在您编写规格说明时，您可能会想到一些只对其中某一组人有用的内容。例如，我通常把写个程序员的一些关于技术实现细节的探讨标记为 “技术旁注”，这样市场方向的同事就会忽略这些内容，而程序员则会阅读他们。我的规格说明中常常充满了类似于 “测试旁注”，“市场旁注” 或者 “文档旁注” 之类的内容。</p><p><span class="greenTitle">规格说明是活的</span> 有些编程队伍采用“瀑布式”流程：一次性搞定程序设计，编写规范，打印出来，扔给程序员然后下班回家。对于这种团队我想说：“呵呵”。</p><p>这种工作方式就是规格说明书声名不好的原因。有很多人这样对我说过：“规格说明书没啥用，因为根本没有人会去遵守，他们最后总是过时的，根本无法反映出产品。”</p><p>抱歉啊，也许 <em>您的</em> 规格说明书过时了，而且没法反应产品情况。但是 <em>我的</em> 规格说明书可是更新的十分频繁。我的规格说明书随着产品的开发进度和新的决策不断更新，我的规格说明书随时可以反映团队对于产品方向的最佳共识，只有当产品代码已经完成时（所有功能开发完成，仍然遗留有测试和 debug 工作）他才会被冻结。</p><p>为了让大家活的轻松点，我不会每天更新规格说明。我常常是在服务器上保持一个最新的版本，以便团队可以将其视作引用的参考。在偶尔的里程碑中，我会打印一份带有修订标记的规范副本，这样人们就不必重新阅读整个内容——他们可以扫描修订标记以查看进行了哪些更改。</p><p>那么谁应该负责写规格说明？请参考 <a href="https://www.joelonsoftware.com/articles/fog0000000034.html">Part3</a>。</p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>软件项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]无痛功能规格说明书——Part1：何必麻烦？</title>
    <link href="/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part1%EF%BC%9A%E4%BD%95%E5%BF%85%E9%BA%BB%E7%83%A6%EF%BC%9F.html"/>
    <url>/%E6%97%A0%E7%97%9B%E5%8A%9F%E8%83%BD%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E2%80%94%E2%80%94Part1%EF%BC%9A%E4%BD%95%E5%BF%85%E9%BA%BB%E7%83%A6%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.joelonsoftware.com/2000/10/02/painless-functional-specifications-part-1-why-bother/">Painless Functional Specifications – Part 1: Why Bother?</a></p></blockquote><span id="more"></span><p>当 <a href="https://www.joelonsoftware.com/articles/fog0000000043.html">Joel测试</a> 刚面市的时候，读者反馈的最大痛点之一就是写规格说明。写规格说明看起来就像是用牙线：大家都知道自己应该写文档，但是大家都不写。</p><p>为什么人们不写规格说明？他们声称不写规格说明可以节约时间，他们表现得就好像编写规格说明这件事是专门为了 NASA 航天飞机工程师或者是大型保险公司人员保留的奢侈品，扯淡。首先，不编写规格说明就是你引入项目的 <em>最大不必要风险</em>，这就像只穿着T恤就出发去穿越莫哈韦沙漠，然后寄希望于“车到山前必有路”一样愚蠢。不写规格说明就直接开始进行项目的程序员以为自己是很酷的枪手，随手掏枪就能击中目标，但实际上他们不是。他们只是编写糟糕的代码，生产劣质的软件，通过承担完全没有必要的风险来威胁他们的项目。</p><p>我相信，在任何重要的项目上（指的是超过一周的编码时间或者超过一个程序员的投入），如果您没有编写规格说明，那么您 <em>一定</em> 会最终花费更多的时间，而且收获低质量的代码。原因如下。</p><p>规格说明最重要的功能是去 <em>设计</em> 程序，即便是程序中所有的代码都由您独立完成，您编写的规格说明只有您自己一位读者，编写规格说明的过程——在微小的细节层面描述程序的原理——也会强制您真正的设计去设计程序。</p><p>让我们来采访我想象中的两位来自不同公司的程序员。Speedy，来自 Hasty Bananas Software，她从来不写规格说明，“规格说明？我们用不着那种东西！”。与此同时，Rogers 先生，是一位来自 The Well-Tempered Software Company 的程序员，他在规格说明定稿前坚决不会写代码。这两位只是我想象中众多朋友中的其中之二。</p><p>Speedy 和 Rogers 先生有一个共同点：他们都在负责各自产品 2.0 版本的向后兼容性。</p><p>Speedy 认为保证向后兼容的最佳方案就是写一个可以把 1.0 版本文件转换成 2.0 版本文件的转换器。她迅速开工，热火朝天，大约两周后，她确实完成了一个可用的转换器，但她的客户不太满意，Speedy 的代码迫使他们必须将公司里每一个人的软件都升级到新版本。Speedy 的最大客户 Nanner Splits Unlimited 甚至拒绝购买这个新版软件。Nanner Splits 要求软件的 2.0 版本应该直接兼容 1.0 版本的文件，而非必须进行转换。Speedy 决定再写一个向后兼容的转换器，并且把他集成到“保存”功能里。这里开始有点混乱，因为当客户使用 2.0 版本的特性数据后，使用 2.0 版本格式保存是没有问题的，但使用 1.0 格式保存时可能会提示客户编写的数据不兼容 1.0 版本的保存格式（此时客户已经在软件上奋战了半个小时，最后却可能无法保存）。总之后面这个版本的转换又使用了两个星期的时间，而且也不是很好用，整个项目的耗时是四周。</p><p>现在，就职于 Well-Tempered Software Company（简称 “WellTemperSoft”）的 Rogers 先生，他是著名的不懂变通之人，他 <em>拒绝</em> 在明确规格说明之前编写任何代码。他大概花了 20 分钟设计了一个和 Speedy 相同的向后兼容方案，并编写了一份规格说明，内容非常简单：</p><ul><li>当使用新版本软件打开旧版本文件时，文件立刻被转换为新版本的格式。</li></ul><p>这份规格说明书被发给了客户，客户立刻反馈：“稍等！我们并没有打算让每个人都立刻升级新版软件！”，Rogers 先生进行了一些思考，之后修改了他的规格说明：</p><ul><li>当使用新版本软件打开旧版本文件时，文件在内存中被改为新格式。当保存文件时，用户可以选择是否将其保存为旧格式。</li></ul><p>至此再次花费了 20 分钟。</p><p>Rogers 先生的老板是一位面向对象程序员，他看了这个说明书后感觉有些地方不太对，然后提出了一种他建议的架构。</p><ul><li>将代码拆分成两种接口：V1 和 V2。V1 包括了所有 1.0 版本软件的功能，V2 继承了 V1，添加了新的功能。这样 V1::Save 可以用来保证向上兼容，V2::Save 可以用来存储新的数据。当客户打开 V1 版本的文件而视图使用 V2 版本的新功能时，程序会立刻提醒客户，客户必须选择将文件转换为 V2 版本或者放弃使用 V2 版本的新功能。</li></ul><p>这里又花费了 20 分钟。</p><p>Rogers 先生感到有点暴躁，因为这种重构需要消耗他 3 周的工时，他自己的方案原本只需要 2 周！但是这个方案确实使用一种优雅的方式解决了所有客户的问题，所以 Rogers 还是这样做了。</p><p>最终，Rogers 先生耗时 3 周零 1 小时，Speedy 耗时 4周，而且 Speedy 的代码更糟糕。</p><p>这个故事的寓意是，通过编造的例子，你可以证明任何事。emmm，No，我不是这个意思。这个故事的意思是当您使用人类语言描述您的产品时，只需要几分钟的时间您就可以思考多种可能性，修改或改进您的设计。没有人会因为删除文档中的一段话而感到失落，但当您通过编程语言设计您的产品时，这意味着每次您需要花费数周的时间来迭代设计。更糟糕的是，往往一个只花了两周时间编写代码的程序员会非常执着于他的代码，无论代码有多么糟糕。不管 Speedy 的老板或者客户说什么都没办法说服她丢掉她的转换器代码，即使那些代码被设计的很糟糕。最终导致的结果就是，交付的产品往往是最初的错误设计和后续的理想设计中间的折中方案，最后就是“这是我们能做到的最好方案，因为我们不能丢掉我们的老代码”，这显然不如“这就是我们最好的方案，句号”。</p><p>以上，就是需要写规格说明的第一个原因。第二个原因是规格说明有助于节约沟通时间，当您编写了一份规格说明，您只需要写一次文档，表述程序如何正确的工作。随后团队中的每个人都可以阅读这份规格说明，QA 同事阅读后了解了程序预期中应该如何工作以及如何测试程序；市场同事阅读后可以编写一些模糊的产品白皮书并发布到网站上；商务开发同事误读了它，对这个产品如何治疗秃头、疣之类的东西产生了奇怪的幻想，但他吸引了投资者，所以没关系；程序员同事阅读后了解了代码应该怎么写；客户阅读了以后知道了我们正在创造一个他们会愿意付款的产品；文档哥（反正就是团队里负责写技术文档的人）阅读后会去写一篇漂亮的手册（最后会丢掉或者扔掉，但那就是 <a href="https://www.joelonsoftware.com/uibook/chapters/fog0000000062.html">另一个故事</a> 了）；经理们阅读后可以在管理会议上假装自己对一切了如指掌；诸如此类。</p><p>而当您没有编写规格说明时，这些沟通仍然会发生，但他们是多次偶发的。QA 同事随意的探索程序，当程序看起来有点怪时，他们就会跑过来 <em>一次又一次</em> 的打断程序员并且 <em>一遍又一遍</em> 的询问一些关于程序预期运行状态的愚蠢问题。这除了会 <a href="https://www.joelonsoftware.com/articles/fog0000000068.html">破坏程序员的生产力</a> 外，程序员还倾向于给出符合他们代码预期的答案，而非“正确答案”。因此 QA 实际上是在依据程序来测试程序，而非依据设计来测试程序，这显然不太靠谱。</p><p>当您没有编写规格说明时，可怜的文档哥的遭遇是最好笑的（以一种悲伤的方式）。文档哥一般不被允许打断程序员的工作，在很多公司里，如果文档哥养成了打断程序员的工作去问问题的习惯，程序员就会跑去找他们的经理哭诉说都是因为[脏话删除]的文档哥打断工作，搞得他根本没法完成任务，经理出于对项目进度的考虑，只能命令文档哥 <em>再也不要</em> 去打扰那些程序员的 <em>宝贵</em> 时间。您可以轻松的识别出这种公司，因为他们的帮助文件和用户手册中提供的信息并不会比您在软件屏幕上自己看到的多。比如当您在屏幕上看到这样一条消息：</p><ul><li>是否开启 LRF-1914 支持?</li></ul><p>… 然后您就点击 “帮助”，随后弹出一个可悲又可笑的帮助内容，比如：</p><ul><li>允许您选择开启 LRF-1914 支持（默认）或是关闭 LRF-1914 支持。如果您希望开启 LRF-1914 支持，请点击 YES 或是输入 Y，如果您不希望开始 LRF-1914 支持，请点击 No 或是输入 N。</li></ul><p>emmm，感谢帮助，但是此处文档哥想要掩盖他其实并不了解 LRF-1914 的意图太明显了。他们也没办法跑去问程序员，因为：（a）他们很内向，或者（b）程序员在海得拉巴然后文档哥在伦敦，或者（c）他们被禁止打扰程序员的工作，当然或者是由于各种各样的公司病，不胜枚举，但是最最根本的问题是 <em>没有规格说明书</em>。</p><p>需要编写规格说明的第三个原因是，如果没有详细的规格说明，那么就不可能制作项目进度表。如果您是在读博士或者是想花 14 年时间来成就某些事情的话，那么不做项目进度表也无所谓（或者说您正在开发《毁灭公爵》续作，“we’ll ship when we’re good and ready”）。但是对于几乎所有现实中的生意来说，您就是需要知道事情需要多少时间，因为开发项目需要花钱。您不可能在不问价格的情况下去买牛仔裤，那么又怎么可能在不知道产品需要多少开发时间，或者说不知道需要投入多少钱的情况下，去做一个可靠的商业决策？关于项目进度表的更多信息，可以阅读 <a href="https://www.joelonsoftware.com/articles/fog0000000245.html">Painless Software Schedules</a>。</p><p>一个常见的错误是在设计阶段对一件事情进行讨论，但 <em>永远得不到结论</em>。Windows 2000 的开发领导人 Brian Valentine 有一句出名的 <a href="http://www.microsoft.com/presspass/features/2000/02-16brianv.asp">座右铭</a>，“Decisions in 10 minutes or less, or the next one is free”（必须在 10 分钟内做出决定）。</p><p>在太多太多的编程组织中，每当出现了关于设计的争执，通常是处于政治的原因，没有人能够做出定论，因此程序员只能先去做没有争议的工作。随着时间的推移，所有的艰难选择都被留在了最后，这种项目是 <em>最可能失败</em> 的项目。如果您在围绕着某种新技术创建了一家新公司，而且您发现您的公司很难以做出决策，您最好尽早关门，把钱还给投资者，因为您最终无法交付任何产品。</p><p>编写规格说明是给这些争议（无论大小）下定论的最好方法，如果您不编写规格说明，有些争议甚至无法被发现。即使是细枝末节的决定也可以通过文档来规范。例如，如果您在创建一个会员制的 web 系统，您一定会赞成在用户忘记密码时可以通过邮件找回。很好，但是这些不足以支撑代码，为了编写代码，您甚至必须精确到邮件中的文本内容。在大多数公司里，程序员并不会被赋予撰写用户可见文本信息的任务 (这通常也是合理的)。因此，产品文案通常需要由市场营销人员、公关人员或其他擅长英语表达的人员来完成。“亲爱的用户，这里是您丢失的密码，以后请别这么粗心了。”当您开始强迫自己编写一个明确且全面的规格说明（关于这个，随后我会聊很多）时，您会注意到所有的这些细节，要么您会解决他们，要么至少打一个大大的红标。</p><p>好的，我们现在达成共识了。规格说明就像美国苹果饼一样，人人爱吃。我相信大多数人都理解这一点，我的一番抱怨虽然有趣，但并没有教给你任何新知识。那么为什么人们不写规格说明呢？这并不是为了节省时间，因为这并不能节省时间，而且我认为大多数程序员其实心里有数。（在大多数组织中，唯一存在的“规格说明”都是程序员在编写代码并向三百个人解释该功能之后，用记事本敲出的一段简短的文本。）</p><p>我认为本质原因就是大多数人讨厌写作，在一片空白的屏幕上从头开始码字会让人感到沮丧。就我个人来说，我是通过在大学里参加了每周需要提交 3-5 页论文的课程克服了我对写作的恐惧。写作就像是肌肉训练，您写的越多，您的写作能力就会越强。如果您需要去写规格说明但是您没有这方面的能力，开始写日记，开始写 <a href="http://www.weblogs.com/about">weblog</a>，报一个创意写作班，或者给您已经四年没联系过的大学室友写一封信。任何需要将文字写到纸上的事情都能提升您写规格说明的水平。如果您是软件开发部门经理，然后您手下的小弟对于写文档一窍不通，您可以把他们送去参加两个星期的封闭式写作训练营。</p><p>如果您在一家从来不写功能规格说明书的公司工作，也许您确实没见过功能规格说明书长什么样。在本系列的下一章中，我会给您展示一个简短的功能规格说明书，并且和您一起探讨一个好的功能规格说明书的写作要点。<a href="https://www.joelonsoftware.com/articles/fog0000000035.html">继续阅读</a>！</p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>软件项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Joel测试：12步获得更好的代码</title>
    <link href="/Joel%E6%B5%8B%E8%AF%95%EF%BC%9A12%E6%AD%A5%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81.html"/>
    <url>/Joel%E6%B5%8B%E8%AF%95%EF%BC%9A12%E6%AD%A5%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a></p></blockquote><blockquote><p>本文写于 2000 年，文中的很多理念值得我们学习，但文中的一些软件和硬件早已不是现在的主流</p></blockquote><span id="more"></span><p>您是否听说过 <a href="http://www.sei.cmu.edu/sema/welcome.html">SEMA</a>？那是一个相当深奥的系统，用于衡量软件团队的优秀程度。但是， <em>等等！别去学那套东西！</em> 理解那套东西大概需要您 <em>六年</em> 的时间。因此，我想出了我自己的、非常不负责任的、草率的测试来评估软件团队的质量。最重要的是，整个过程只需要 3 分钟，省下来的时间足够您读一个医学学位。</p><p><strong>Joel测试</strong></p><ul><li>您是否使用了源码控制？</li><li>您能否一键构建？</li><li>您是否进行每日例行构建？</li><li>您是否拥有 bug 数据库？</li><li>您是否在写新代码之前修复 bug？</li><li>您是否拥有最新的的项目进度表？</li><li>您是否拥有规格说明？</li><li>程序员的工作环境是否安静？</li><li>您是否在使用最先进的生产工具？</li><li>团队中有测试人员吗？</li><li>招募新人的时候会让他们在面试时写代码吗？</li><li>您会进行走廊可用性测试吗？</li></ul><p>Joel 测试的妙处在于，每个问题都可以使用 <strong>是</strong> 或 <strong>否</strong> 来回答。您压根不用去计算每日平均代码数或者每版本平均BUG数什么的，只需每个 <strong>是</strong> 计一分。当然，Joel 测试的坏处在于，您 <em>不应该</em> 用他来确保您的核电站控制软件的安全性。</p><p>12 分是完美结果，11 分也可以接受，但是 10 分或以下就意味着您已经遭遇了一些严肃的问题。实际上大部分软件组织的得分只有 2 或者 3，他们需要 <em>严肃的</em> 帮助，因为像微软这样的公司会在任何时候都以 12 分的状态运行。</p><p>当然，这些不是决定成败的唯一因素：在现实中，如果您拥有一个伟大的团队但是在制造一个没人需求的产品，那么，确实也不会有市场。同时，也可以想象一群才华横溢的“枪手”，他们虽然不遵循这些流程，却能做出改变世界的惊人软件。但是，在其他条件相同的情况下，如果您把这 12 件事做好，您就会拥有一支纪律严明、能够持续交付的团队。</p><h1 id="1-您是否使用了源码控制？"><a href="#1-您是否使用了源码控制？" class="headerlink" title="1. 您是否使用了源码控制？"></a>1. 您是否使用了源码控制？</h1><p>我曾经用过商用的代码控制软件，也用过免费的 CVS，我会告诉您，免费的 CVS 也很好用。但是如果您没有源码控制的话，您会在让程序员协同工作的过程中遇到各种阻碍。程序员们无法知道别人做了些什么，错误也没办法被回滚。源码控制系统带来的另一个优点是，源码会被检出到每一个程序员的硬盘上——我从未听说过使用了源码控制的项目遭遇大量源码丢失的事故。</p><h1 id="2-您能否一键构建？"><a href="#2-您能否一键构建？" class="headerlink" title="2. 您能否一键构建？"></a>2. 您能否一键构建？</h1><p>这里我的意思是：从最新的代码到可交付产品需要多少个步骤？在一个好的团队中，会有一个单独的脚本，他可以从头开始检查代码、重新构建代码、为所有的分支版本和语言或者 #ifdef 约束条件构建可执行文件，创建安装包，然后将其发送到最终的媒介——光盘或者下载网站等等。</p><p>如果这个过程无法一键执行，那就带来了犯错的机会。而且您的项目越接近交付，您往往需要更快速的迭代部署来处理“最后的” bug，创建最终的可执行文件，等等。如果这个过程需要耗费20步，相信我，您一定会感受到痛苦，而且会犯下很多愚蠢的操作错误。</p><p>正是因为这个原因，我工作的上一家公司从 WISI 转向了 InstallShield：我们希望安装程序能在夜间使用 NT scheduler 通过一个脚本自动运行，而 WISE 无法在夜间自动运行，因此我们淘汰了他。（WISE 的开发人员向我保证他们的最新版本已经支持了夜间构建。）</p><h1 id="3-您是否进行每日例行构建？"><a href="#3-您是否进行每日例行构建？" class="headerlink" title="3. 您是否进行每日例行构建？"></a>3. 您是否进行每日例行构建？</h1><p>当您在使用了源码控制后，有时某个程序员无意中提交了一些错误的代码导致项目无法构建。例如，他添加了一个新的源文件，在他自己的机器上编译都没有问题，但是他忘记把他的文件提交到代码库了。之后这哥们关机回家了，浑然不觉，心满意足。但是其他人就没法干活了，因此其他人也被迫回家了。</p><p>导致项目无法构建的错误非常的糟糕（但是也非常常见），这导致了我们需要进行每日构建，用来检查有没有构建错误。在一个大团队中，一个用来定位构建问题的很好的方式是在每天的午餐时间进行每日例行构建。每个团队成员都在午餐前尽可能多的提交代码，而当他们吃完饭回来时，构建已经完成了。如果例行构建成功，那非常好，每个人都可以将代码更新到最新版本然后继续工作。如果构建失败，您需要修复问题，但是其他人仍然可以在上次成功构建的版本上继续工作。</p><p>在开发 Excel 时我们定下了一个规则，谁的代码打破了构建，那么作为“惩罚”，就由他负责处理构建过程，直到另一个程序员又打破了构建。这是一个鼓励大家不要打破构建的好办法，也是一个让大家轮流参与构建过程，了解构建过程工作原理的好办法。</p><p>可以在我的文章 <a href="https://www.joelonsoftware.com/articles/fog0000000023.html">Daily Builds are Your Friend</a> 中了解更多和每日例行构建相关的内容。</p><h1 id="4-您是否拥有-bug-数据库？"><a href="#4-您是否拥有-bug-数据库？" class="headerlink" title="4. 您是否拥有 bug 数据库？"></a>4. 您是否拥有 bug 数据库？</h1><p>无论您做何辩解，但是只要您是在写代码，无论是团队工作还是独立开发，如果没有一个数据库来组织所有的已知 bug 的话，您的代码交付质量一定不高。有很多程序员觉得他们可以吧 bug 列表记在脑子里，这完全不靠谱。我的脑子现在连三个 bug 都记不住，而且每次睡一觉过后，或者是随着交付的压力，程序员早就把 bug 列表忘的一干二净了。你绝对需要使用工具正式的进行 bug 追踪。</p><p>Bug 数据库可以设计的复杂一点或者简单一点，但是最简单的可以用 bug 数据库也应该为每个 bug 包含下列字段：</p><ul><li>完整的复现步骤</li><li>预期行为</li><li>观察到的（出bug的）行为</li><li>分配给谁处理</li><li>是否已经修复</li></ul><p>如果说 bug 追踪软件的复杂度导致了您不想使用他们，那您可以使用上述五列的简单表格来开始您的 bug 追踪工作。</p><p>更多关于 bug 追踪的知识，可以阅读 <a href="https://www.joelonsoftware.com/articles/fog0000000029.html">Painless Bug Tracking</a>。</p><h1 id="5-您是否在写新代码之前修复-bug？"><a href="#5-您是否在写新代码之前修复-bug？" class="headerlink" title="5. 您是否在写新代码之前修复 bug？"></a>5. 您是否在写新代码之前修复 bug？</h1><p>第一个版本的微软 Windows 版 Word 被称为“死亡竞速”项目。整个过程漫长而坎坷，一再延期。整个团队都加班加点到离谱的地步，项目一次又一次地推迟，压力也大得让人难以置信。这该死的项目最终在发布时已经比原计划晚了数年。微软公司把整个团队送到坎昆去度假放松一下，随后坐下来进行深刻的反省。</p><p>他们认识到，项目经理们一直如此执着于遵守“进度表”，以至于程序员们为了赶进度，只匆匆完成了编码过程，写出了非常糟糕的代码，因为修复漏洞并不是正式进度表的一部分，恰恰相反，当时并没有指标尝试控制漏洞数量。据传闻，一位程序员需要编写计算文本行高的代码，他干脆直接写了“return 12;” 这段代码，然后等着关于这个函数并不总是正确的漏洞报告出现。进度表变成了一份等待变成漏洞的功能清单。在事后分析中，这种做法被戏称为“无限缺陷方法论”。</p><p>为了纠正这个问题，微软在整个公司范围内实施了一种名为“零缺陷方法论”的东西。公司里的许多程序员都对此嗤之以鼻，因为这听起来像是管理层认为他们可以通过行政命令来减少漏洞数量。实际上，“零缺陷”意味着在任何给定时间，最高优先级都是在编写任何新代码之前消除漏洞。原因如下：</p><p>普遍上，修复 bug 前等待的时间越长，修复的成本（时间和金钱）就越高。</p><p>例如，当您犯了编译器捕获的拼写错误或语法 bug 时，修复它基本上是微不足道的。</p><p>当您第一次尝试运行代码时发现代码中有 bug 时，您将能够立即修复它，因为所有代码在您的脑海中仍然记忆犹新。</p><p>如果您在几天前编写的某些代码中发现 bug，您将需要一段时间才能找到它，但是当您重读您编写的代码时，您会记住所有内容，并且能够在合理的时间内修复该 bug。</p><p>但是如果您发现的 bug 是在您 <em>几个月</em> 前编写的代码中出现的，您很可能基本上已经把代码中的事情忘光了，这样 bug 修复工作就会变的很难，这种感觉就像是在修复其他人的代码，而且那哥们现在正在阿鲁巴度假。在这种情况下，修复 bug 就像是一种考古工作：您必须缓慢的，有条理的，细致的处理，而且您还无法确定需要多长时间才能取得成果。</p><p>如果您在已经交付的产品中发现了 bug，那么您可能需要花费相当高昂的代价来修复他。</p><p>这就是为什么要立刻修复 bug 的原因：因为这样最省时间。这里还有另一个原因，关乎到一个事实情况，就是编写新代码所消耗的工时比修复 bug 消耗的工时更加容易预测。例如，如果我请您预测需要花费多少时间来编写一个对列表进行排序的代码，您可以反馈给我一个精准的评估。但是如果我请您预测需要花费多少时间来处理您的代码在用户安装了 Internet Explorer 5.5 后无法运行的 bug，您可能无法估算，因为您压根不知道 bug 发生的原因。寻找 bug 的成因也许需要三天，也有可能只需要两分钟。</p><p>这意味着如果您拥有一个项目进度表，但是表上的完成项目都包含有大量需要被处理的 bug，那么这个项目进度表就完全不靠谱。但是如果您已经处理了所有已知的 bug，剩余的工作只有新需求的开发，那么您的项目进度表就会更加精准。</p><p>将未处理 bug 数量保持为 0 的另一大好处是您可以更快速的响应竞争，有些程序员认为这种行为表示产品随时处于<em>可交付</em>状态。如果您的竞争对手发布了一个杀手级的功能来偷取您的客户，您可以立刻实现该功能并且随后马上跟进发布，无需等待处理堆积如山的遗留 bug。</p><h1 id="6-您是否拥有最新的的项目进度表？"><a href="#6-您是否拥有最新的的项目进度表？" class="headerlink" title="6. 您是否拥有最新的的项目进度表？"></a>6. 您是否拥有最新的的项目进度表？</h1><p>既然我们已经聊到了项目进度表，如果您的代码交付和商务有关，那么商务同事会有无数个理由来询问您的项目进度。程序员在制定进度表时的暴躁众所周知 “等我做完了就能交付了！” 他们用这样的语言回怼他们的商务同事。</p><p>不幸的是，这样没法解决问题。在代码交付前，商务同事需要做很多很多的事：demo 展示、举办展会、投放广告，等等。这些事情都需要项目进度表的支持，而且项目进度表要尽可能的更新而且准确。</p><p>关于使用项目进度表的另一个至关重要的原因是，他可以帮助你决定接下来需要开发哪些软件功能，而且他还会强迫你筛选出最不重要的功能，移除他们，而不是陷入功能炎（<a href="http://www.netmeg.net/jargon/terms/c/creeping_featuritis.html">featuritis</a>）（也被称为 scope creep）。</p><p>保持您的项目进度表简单易读，参考我的文章 <a href="https://www.joelonsoftware.com/articles/fog0000000245.html">Painless Software Schedules</a>，这里描述了如何通过简单的方式运用项目进度表。</p><h1 id="7-您是否拥有规格说明？"><a href="#7-您是否拥有规格说明？" class="headerlink" title="7. 您是否拥有规格说明？"></a>7. 您是否拥有规格说明？</h1><p>编写规格说明书就像使用牙线：每个人都赞成这是件好事，但就是没人去做。</p><p>我不确定这事的成因，但是最大的可能性就是大部分程序员仇恨写文档。因此，当仅由程序员组成的团队解决问题时，他们更喜欢用代码而不是文档来表达他们的解决方案。他们更愿意深入研究并编写代码，而不是先制定规范。</p><p>在设计阶段，当您发现问题时，只需要寥寥几行文本就可以将问题解决。一旦代码已经完成，修复问题的开销就急剧增加，无论是情感上的（人们厌恶抛弃已经完成的代码），还是时间上的，因此程序员会产生对抗情绪。没有规格说明的项目往往以糟糕的设计和无法控制的进度收场。这似乎是 Netscape 犯过的错误，前四个版本变得如此混乱，以至于管理层 <a href="https://www.joelonsoftware.com/articles/fog0000000069.html">愚蠢地决定</a> 扔掉代码并重新开始。然后他们在 Mozilla 上再次犯了这个错误，创造了一个失控的怪物，花了 <em>好几年</em> 才进入 alpha 阶段。</p><p>我的理论是，这个问题可以通过把程序员送去参加 <a href="http://www.yale.edu/engl450b/">写作集中培训</a> 来降低他们对写文档的抵触情绪，或者是聘用有能力的项目经理来编写规格说明。无论如何，您都需要遵循简单的规则“先写规范后写代码”。</p><p>了解更多如何书写规格说说明的支持，参考我的另一篇 <a href="https://www.joelonsoftware.com/articles/fog0000000036.html">文章</a>。</p><h1 id="8-程序员的工作环境是否安静？"><a href="#8-程序员的工作环境是否安静？" class="headerlink" title="8. 程序员的工作环境是否安静？"></a>8. 程序员的工作环境是否安静？</h1><p>关于为知识工作者提供空间、安静和隐私能够提升生产效率的文章已经很广泛了，经典的软件管理书籍 <a href="http://www.amazon.com/exec/obidos/ASIN/0932633439/ref=nosim/joelonsoftware/">Peopleware</a> 大量记载了这些关于生产力提升的理论。</p><p>这里有个小问题。我们都知道知识工作者的最佳工作状态是“心流”，或者被称为“在领域中”，这种情况下他们完全专注于工作而且屏蔽外界的环境。他们忘记了时间，通过绝对的专注创造出伟大的作品。这是他们完成所有富有成效的工作的时候。作家、程序员、科学家甚至篮球运动员都会告诉你这种心流的感觉。</p><p>问题在于，进入心流状态并不简单。当您尝试观测时，您会发现平均需要 15 分钟才能进入最高效率的工作状态。有时候，如果您累了或者那天已经做了很多创造性的工作，您就是无法进入状态，您就把工作日剩下的时间花在闲逛、阅读网页、玩俄罗斯方块上。</p><p>另一个问题是，心流状态非常容易被打断。噪音、电话、出门吃午饭、需要出去买咖啡，或者被同事打扰——特别是被同事打扰——这些情况都会打断您的心流状态。如果同事问您一个问题，只造成了 1 分钟的中断，但这会让您脱离心流状态，需要半个小时才能再次恢复工作效率，那么你的整体工作效率就会遇到严重问题。如果您处于一个嘈杂的牛棚环境中，就像含有咖啡因的网络公司所喜欢创造的那样，营销人员在程序员旁边打电话尖叫，那么您的生产力将会下降，因为知识工作者一次又一次地被打扰，永远无法进入状态。</p><p>对于程序员来说，这种情况尤为严重。生产力依赖于能够同时处理短期记忆中的许多小细节。任何微小的打扰都会造成这些细节的崩溃。当您恢复工作时，您无法无法完整的回忆起这些细节（例如本地的变量名称，或者您正在实现该搜索算法时要达到的目的）您必须不断地寻回这些细节，在此之前您的工作速度都会被严重降低。</p><p>这是个简单的代数问题，我们认为（基于我们观测到的证据）只要我们打断了程序员的工作，哪怕只有一分钟，我们至少浪费了十五分钟的生产力。例如，有两个程序员，Jeff 和 Mutt， 待在标准 Dilbert 小牛育肥农场中彼此相邻的开放式小隔间中。Mutt 忘记了 strcpy 函数的 Unicode 版本的名称，他可以选择自己查询，这会消耗他 30 秒，他也可以选择询问 Jeff，这会消耗他 15 秒。由于他的座位就在 Jeff 旁边，他选择了询问 Jeff。Jeff 由于被打断工作而损失了 15 分钟的生产力（用来为 Mutt 节省 15 秒）。</p><p>现在，让我们把他们搬到有墙壁和门的单独办公室去。此时当 Mutt 记不得函数的名称时，他可以选择自己查询，这依然会消耗他 30 秒，或者他也可以选择询问 Jeff，但这次需要消耗他 45 秒，而且他还必须站起来（考虑到程序员的平均身体素质，这不是一件容易的事！），因此他选择了自己查询。这次 Mutt 损失了 30 秒的生产力，但是 Jeff 节约了 15 分钟。</p><h1 id="9-您是否在使用最先进的生产工具？"><a href="#9-您是否在使用最先进的生产工具？" class="headerlink" title="9. 您是否在使用最先进的生产工具？"></a>9. 您是否在使用最先进的生产工具？</h1><p>使用编译型语言写代码是最后仍然无法立刻在普通家用计算机上完成的事情之一。如果您的编译过程超过了几秒钟，改用最新款的电脑可以节省您的时间。如果编译过程达到了 15 秒，程序员就会等的无聊然后跑去刷 <a href="https://www.theonion.com/">洋葱新闻</a>，一不留神就会刷好几个小时。</p><p>使用单个显示器对 GUI 软件进行 Debug 也不是不可能，但是过程非常痛苦。如果您在编写 GUI 代码，两台显示器会让事情变的简单许多。</p><p>大部分程序员最终都必须操作位图来制作图标和菜单，然而大部分程序员并没有一个好用的位图编辑器。“用 Windows 画图来处理位图”听起来像个笑话，但是实际上很多程序员都不得不这样做。</p><p>在 <a href="https://www.joelonsoftware.com/articles/TwoStories.html">我的最后一份工作</a> 中，运维老大持续的给我发垃圾邮件来抱怨我在服务器上使用了超过（大约）220M的硬盘空间。我则是这样告诉他，考虑到现在的硬盘价格，我使用这些硬盘来存储的成本明显要低于我使用<em>卫生纸</em>来存储。即便是花 10 分钟来让我清理一下我的文件夹，那也是对我生产力的一种浪费。</p><p><strong>顶尖的开发团队不会折磨他们的程序员。</strong>即使是由于工具不好用带来的微小挫败感，积累起来也会让程序员变得暴躁和不开心。而一个带有负面情绪的程序员实际上就是一个毫无生产力的程序员。</p><p>除此之外…其实程序员很容易被最新最酷的电子产品吸引。用这种方式引诱他们为你工作比起涨工资便宜的多。</p><h1 id="10-团队中有测试人员吗？"><a href="#10-团队中有测试人员吗？" class="headerlink" title="10. 团队中有测试人员吗？"></a>10. 团队中有测试人员吗？</h1><p>如果您的团队没有专职的测试人员，或者没有至少为每两到三个项目配一个测试员，那么要么你就是在交付充满 BUG 的产品，要么你就是在让时薪 100 美金的程序员在干时薪 30 美金的测试员的活。在测试员身上降低支出是一种令人发指的“虚假节约”，很多人没有意识到这一点，这让我很震惊。</p><p>阅读 <a href="https://www.joelonsoftware.com/articles/fog0000000067.html">Top Five (Wrong) Reasons You Don’t Have Testers</a>，这篇文章里我详细介绍了这个主题。</p><h1 id="11-招募新人的时候会让他们在面试时写代码吗？"><a href="#11-招募新人的时候会让他们在面试时写代码吗？" class="headerlink" title="11. 招募新人的时候会让他们在面试时写代码吗？"></a>11. 招募新人的时候会让他们在面试时写代码吗？</h1><p>您会在雇佣一名魔术师的时候不让他为您展示一些魔术技巧吗？当然不是。</p><p>您会在雇佣婚礼厨师的时候不品尝他们的食物吗？我觉得也不是。（除非您雇佣的是 Marge 阿姨，而且如果您不让她制作她“出名的”碎肝饼的话，她会恨您一辈子的）。</p><p>然而，每时每刻，都有程序员会因为他感人的简历或者在面试时表现出的言谈举止被雇佣。或者他们只是被问了一些无关紧要的编程细节（“CreateDialog() 和 DialogBox() 的区别是什么？”），这种东西只要查查文档就行了。您不应该在乎他能否记得住成百上千个细节，您应该在乎的是他有没有能力写代码。或者说，更糟糕的情况下，他们会被询问“AHA！”问题：就是那种您知道了答案就特别简单，但是不知道答案也完全无所谓的问题。</p><p>请不要再做这种事情了。您可以在面试的时候安排任何环节，但千万记得要让受试者写一些代码。（参考我的文章 <a href="https://www.joelonsoftware.com/articles/fog0000000073.html">Guerrilla Guide to Interviewing</a>，了解更多建议）。</p><h1 id="12-您会进行走廊可用性测试吗？"><a href="#12-您会进行走廊可用性测试吗？" class="headerlink" title="12. 您会进行走廊可用性测试吗？"></a>12. 您会进行走廊可用性测试吗？</h1><p><em>走廊可用性测试</em>指的是您在走廊随便抓一个人，让后强迫他试用您刚写完的代码。如果您对五个人这样做，您就会学到关于代码可用性问题中 95% 的知识。</p><p>好的 UI 设计没有您想的那么难，而这对于客户选择并钟情您的产品至关重要。您可阅读我的 <a href="https://www.joelonsoftware.com/uibook/chapters/fog0000000057.html">free online book on UI design</a>，这是为程序员准备的一个简短的入门书籍。</p><p>但是关于 UI 最重要的一点是，只需将您的程序展示给几个用户（实际上，五到六个人就完全足够了），您立刻就会发现用户关注的最大问题。这篇文章 <a href="http://www.useit.com/alertbox/20000319.html">Jakob Nielsen’s article</a> 阐述了这个现象的成因。即便您缺乏关于 UI 设计的技巧，只要您坚持进行走廊测试（这也没啥成本），您的 UI 就会变得好很多，很多。</p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>软件项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Windows 环境使用 proxifyre 代理应用程序</title>
    <link href="/%E5%9C%A8%20Windows%20%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%20proxifyre%20%E4%BB%A3%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.html"/>
    <url>/%E5%9C%A8%20Windows%20%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%20proxifyre%20%E4%BB%A3%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/wiresock/proxifyre">wiresock&#x2F;proxifyre 项目链接</a></p></blockquote><span id="more"></span><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>proxifyre 适用于，当您已经拥有一个可用的 socks5 代理，但却不了解如何让某个应用程序通过此代理收发包的情况。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>proxifyre 用于指定一些应用程序的网络流量通过 socks5 代理。</p><p>proxifyre 是基于 Windows 包过滤器 <a href="https://github.com/wiresock/ndisapi/tree/master/examples/cpp/socksify">socksify</a> demo 做的增强，加入了 UDP 能力，简化了配置。</p><p>proxifyre 支持被注册为 Windows 服务。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>使用 proxifyre 前需要安装两个依赖：</p><ol><li>Windows Packet Filter (<a href="https://github.com/wiresock/ndisapi/releases">WinpkFilter</a>)</li><li>Visual Studio Runtime Libraries(<a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170">Visual Studio 2022 redistributable download page</a>)</li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>proxifyre 默认配置文件名为 app-config.json，将配置文件放到 proxifyre 执行目录下会被直接使用，配置文件示例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span> <span class="token property">"logLevel"</span><span class="token operator">:</span> <span class="token string">"None"</span><span class="token punctuation">,</span> <span class="token property">"proxies"</span><span class="token operator">:</span> <span class="token punctuation">[</span>         <span class="token punctuation">&#123;</span>         <span class="token property">"appNames"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"chrome"</span><span class="token punctuation">,</span> <span class="token string">"C:\\Program Files\\WindowsApps\\ROBLOXCORPORATION.ROBLOX"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token property">"socks5ProxyEndpoint"</span><span class="token operator">:</span> <span class="token string">"158.101.205.51:1080"</span><span class="token punctuation">,</span>         <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"username1"</span><span class="token punctuation">,</span>         <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"password1"</span><span class="token punctuation">,</span>         <span class="token property">"supportedProtocols"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"TCP"</span><span class="token punctuation">,</span> <span class="token string">"UDP"</span><span class="token punctuation">]</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>logLevel: 日志等级，可选项为：<code>None</code> <code>Info</code> <code>Deb</code> <code>All</code></li><li>proxies：代理配置列表</li><li>appNames：被代理程序名，采用模糊匹配，例如 <code>chrome</code> 会匹配到包含 <code>chrome</code> 字符串的所有程序。如果使用路径则可以精确匹配。</li><li>socks5ProxyEndpoint：socks5 服务位置，地址+端口。</li><li>username：如果 socks5 服务用户名，可不填。</li><li>password：socks5 服务密码，可不填。</li><li>supportedProtocols：被代理的网络协议，支持 TCP UDP。</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>完成配置后，直接运行 ProxiFyre.exe 即可使用，日志文件会生成在 <code>/logs</code> 路径。</p><p>也可以通过下列命令进行服务的注册、启动、停止和卸载，通过 Windows 服务管理：</p><ul><li>ProxiFyre.exe install</li><li>ProxiFyre.exe start</li><li>ProxiFyre.exe stop</li><li>ProxiFyre.exe uninstall</li></ul><p>当然也可以通过 nssm 工具将 ProxiFyre.exe 注册为 Windows 服务。</p>]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Go教程：泛型入门</title>
    <link href="/Go%E6%95%99%E7%A8%8B%EF%BC%9A%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8.html"/>
    <url>/Go%E6%95%99%E7%A8%8B%EF%BC%9A%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></p></blockquote><span id="more"></span><head>  <style>    .indentation {      margin-left: 2rem;    }  </style></head><p>这篇教程介绍了 Go 中泛型的基础。通过泛型，您可以定义和使用一些函数或类型，这些函数或类型可以用于处理调用代码提供的任意类型集合。</p><p>在这个教程中，您将声明两个简单的非泛型函数，随后在一个单一的泛型函数中实现同样的逻辑。</p><p>您将按照如下步骤进行：</p><ol><li>为您的代码创建文件夹。</li><li>一个非泛型的函数。</li><li>添加一个可以处理多种类型的泛型函数。</li><li>在调用泛型函数时删除类型参数。</li><li>声明一个类型约束。</li></ol><p><strong>备注：</strong>其他教程请查看<a href="https://go.dev/doc/tutorial/index.html">链接</a>。</p><p><strong>备注：</strong>如果您需要的话，您也可以使用 <a href="https://go.dev/play/?v=gotip">“Go dev branch” 模式的 Go playground</a> 来编辑和运行您的程序。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><strong>Go 1.18 及以上。</strong>有关安装说明，请参考 <a href="https://go.dev/doc/install">Installing Go</a>。</li><li><strong>代码编辑工具。</strong>任何文本编辑器均可。</li><li><strong>命令行终端。</strong>Go 可以在 Linux 和 Mac 的终端中运行，也可以在 Windows 的 PowerShell 或 cmd 中运行。</li></ul><h1 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h1><p>为了开始一切，先创建文件夹用来存放您即将编写的代码。</p><ol><li>打开一个命令提示符并切换到您的家目录。</li></ol><div class="indentation"><p>在 Linux 或者 Mac 上：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在 Windows 上：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">C:\&gt; cd %HOMEPATH%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>教程的剩余部分我们都会将 $ 作为提示符。您使用的命令在 Windows 中也会生效。</p></div><ol start="2"><li>在命令提示符中，为您的代码创建名为 generics 的文件夹。</li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> generics$ <span class="token builtin class-name">cd</span> generics<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></div><ol start="3"><li>为您的代码创建一个模块。</li></ol><div class="indentation"><p>运行 <code>go mod init</code> 命令，为他提供您的新代码的模块路径。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go mod init example/genericsgo: creating new go.mod: module example/generics<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>备注：</strong>对于用于生产的代码，您最好根据您的需要去选择模块路径。有关更多消息，请参考<a href="https://go.dev/doc/modules/managing-dependencies">Managing dependencies</a>。</p></div><p>接下来，您会添加一些处理 map 的简单代码。</p><h1 id="非泛型函数"><a href="#非泛型函数" class="headerlink" title="非泛型函数"></a>非泛型函数</h1><p>在这一步中，您会创建两个函数，他们都会将 map 中的值加总，并返回结果。</p><p>您声明两个函数，而非一个，因为您需要处理两种不同类型的 map：一个存储 int64 类型的值，另一个存储 float64 类型的值。</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><ol><li><p>使用您的文本编辑器，在 generics 文件夹中创建一个名为 main.go 文件。您将要在这里编写您的 Go 代码。</p></li><li><p>打开 main.go，粘贴如下包声明。</p></li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>独立的程序（而非库）始终使用 main 包。</p></div><ol start="3"><li>在包声明下方，粘贴如下两个函数声明。</li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// SumInts adds together the values of m.</span><span class="token keyword">func</span> <span class="token function">SumInts</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s <span class="token builtin">int64</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span class="token comment">// SumFloats adds together the values of m.</span><span class="token keyword">func</span> <span class="token function">SumFloats</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s <span class="token builtin">float64</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在上述代码中，您完成了：</p><ul><li>声明了两个将 map 中的值加总并返回的函数。<ul><li>SumFloats 接收类型为 [string]float64 的 map。</li><li>SumInts 接收类型为 [string]int64 的 map。</li></ul></li></ul></div><ol start="4"><li>在 main.go 文件的顶部，包声明的下方，粘贴 main 函数，他初始化两个 map，并将他们当作您之前声明的函数的参数来使用。</li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Initialize a map for the integer values</span>    ints <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int64</span><span class="token punctuation">&#123;</span>        <span class="token string">"first"</span><span class="token punctuation">:</span>  <span class="token number">34</span><span class="token punctuation">,</span>        <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Initialize a map for the float values</span>    floats <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">&#123;</span>        <span class="token string">"first"</span><span class="token punctuation">:</span>  <span class="token number">35.98</span><span class="token punctuation">,</span>        <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token number">26.99</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Non-Generic Sums: %v and %v\n"</span><span class="token punctuation">,</span>        <span class="token function">SumInts</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">SumFloats</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在上述代码中，您：</p><ul><li>初始化了 float64 值的 map 和 int64 值的 map，每个都有两条数据。</li><li>调用之前定义的两个函数，查询两个 map 各自的总值。</li><li>打印结果</li></ul></div><ol start="5"><li>在 main.go 的顶部附近，在包声明的下方，引入您代码中需要的包。</li></ol><div class="indentation"><p>将文件顶部修改为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure></div><ol start="6"><li>保存 main.go。</li></ol><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>在命令行中，main.go 文件所在的文件夹路径下，运行命令。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go run <span class="token builtin class-name">.</span>Non-Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>通过泛型，您可以只编写一个函数，而非两个。接下来，您会添加一个单独的泛型函数，他可以用于 int64 类型的 map 或 float64 类型的 map。</p><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><p>在这一节中，您将要添加一个泛型函数，他可以接收整数或者浮点数类型的 map 作为参数，他可以用来替代您之前编写的两个函数。</p><p>为了同时支持两种类型的值，这个函数需要通过一种方式来声明他支持的类型。从另一方面来说，调用代码需要有一种方式来指定他使用何种类型的 map 来调用该函数。</p><p>为了实现这个目标，您声明的函数除了有普通的函数参数外，还需要有 <em>类型参数（type parameters）</em>。正是这些类型参数支撑了泛型函数，让他们能够应付不同类型的参数。您在调用泛型函数时需要同时传入类型参数和函数参数。</p><p>每个类型参数都有一个 <em>类型约束（type constraint）</em> 来扮演他的元类型。每个类型约束指定了调用函数在传入各类型参数时允许使用的类型参数范围。</p><p>虽然类型参数约束往往提供了多种类型，但在编译时类型参数只代表一种类型——调用代码所提供的类型。如果调用代码提供的类型不满足类型参数约束，那么编译就会失败。</p><p>请记住，类型参数必须支持泛型代码中的任何操作。例如，如果您泛型函数中的代码包含字符串的操作（例如取索引），但您的类型参数约束包括了数字类型，那么编译就会失败。</p><p>在您接下来要编写的代码中，您将实现供同时允许整数和浮点数的类型参数约束。</p><h2 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h2><ol><li>在您之前添加的两个函数下方，粘贴如下泛型函数。</li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// SumIntsOrFloats sums the values of map m. It supports both int64 and float64</span><span class="token comment">// as types for map values.</span><span class="token keyword">func</span> SumIntsOrFloats<span class="token punctuation">[</span>K comparable<span class="token punctuation">,</span> V <span class="token builtin">int64</span> <span class="token operator">|</span> <span class="token builtin">float64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span>V<span class="token punctuation">)</span> V <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s V    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这段代码中，您：</p><ul><li>声明了带有两个类型参数（在中括号中）的 SumIntsOrFloats 函数，类型参数是 K 和 V，同时声明了一个使用类型参数定义的函数参数 m，他的类型是 map[K]V。函数返回值的类型也是 V。</li><li>将类型参数 K 的类型约束指定为可比较的（comparable）。Go 中的 comparable 约束就是专门为了这种情况定义的，他表示允许所有支持 &#x3D;&#x3D; 和 !&#x3D; 的类型。Go 要求 map 的键必须是可比较的，因此您必须将 K 声明为 comparable，他才可以作为 map 中的 key。这也同时确保了调用代码需要使用合理的类型作为 map 的键。</li><li>将类型参数 V 的类型约束指定为两种类型，int64 和 float64。使用 | 分隔两种类型，表示这两种类型都可以被使用。在调用代码中使用任何一种都可以成功编译。</li><li>指定函数参数 m 的类型为 map[K]V，其中 K 和 V 是之前指定的类型参数。请注意，我们现在知道 map[K]V 是一个合法的 map，因为 K 必须是一个可比较类型。如果我们之前没有将 K 声明为可比较类型，编译器会拒绝引用 map[K]V。</li></ul></div><ol start="2"><li>在 main.go 中，您已有代码的下方，粘贴如下代码。</li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Generic Sums: %v and %v\n"</span><span class="token punctuation">,</span>    SumIntsOrFloats<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>    SumIntsOrFloats<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">float64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在这段代码中，您：</p><ul><li><p>调用了您之前申明的泛型函数，传入了您之前创建的 map。</p></li><li><p>指定类型参数——将类型名称放入方括号中——用来指明成为您当前调用的函数中的类型参数。</p></li></ul><div class="indentation"><p>正如您即将在下一小节中看到的，您往往可以省略调用函数时的类型参数。Go 可以通过您的代码推断他们。</p></div><ul><li>打印函数的加总结果。</li></ul></div><h2 id="运行代码-1"><a href="#运行代码-1" class="headerlink" title="运行代码"></a>运行代码</h2><p>在命令行中，main.go 文件所在的文件夹路径下，运行命令。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go run <span class="token builtin class-name">.</span>Non-Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span>Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>为了运行您的代码，编译器会在每次调用时将类型参数替换为调用时设置的具体类型。</p><p>在调用您的泛型函数的过程中，编译器会使用您指定的类型参数替换函数中的类型参数。正如您即将在下一小节中看到的，在很多情况下您可以省略类型参数，因为编译器会自动推断他们。</p><h1 id="删除调用泛型函数时的类型参数"><a href="#删除调用泛型函数时的类型参数" class="headerlink" title="删除调用泛型函数时的类型参数"></a>删除调用泛型函数时的类型参数</h1><p>在这一小节，您将添加一个新版本的对泛型函数的调用，通过一些微小的改动来简化调用代码。您将会删除类型参数，实际上在这个例子中他们确实是不必要的。</p><p>当 Go 编译器可以推断您想要使用的类型时，您可以在调用代码中省略类型参数。编译器通过函数参数的类型来推断类型参数。</p><p>请记住，这并不总是可行的。例如，如果您希望调用一个没有函数参数的泛型函数，您就必须在调用时包含类型参数。</p><h2 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h2><ul><li>在 main.go 中，您现有代码的下方，粘贴如下代码。</li></ul><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Generic Sums, type parameters inferred: %v and %v\n"</span><span class="token punctuation">,</span>    <span class="token function">SumIntsOrFloats</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">SumIntsOrFloats</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在这段代码中，您：</p><ul><li>调用泛型函数，并省略了类型参数。</li></ul></div><h2 id="运行代码-2"><a href="#运行代码-2" class="headerlink" title="运行代码"></a>运行代码</h2><p>在命令行中，main.go 文件所在的文件夹路径下，运行命令。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go run <span class="token builtin class-name">.</span>Non-Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span>Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span>Generic Sums, <span class="token builtin class-name">type</span> parameters inferred: <span class="token number">46</span> and <span class="token number">62.97</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接下来，您会通过将整数和浮点数设置为一种可复用的类型约束来进一步简化函数。</p><h1 id="声明类型约束"><a href="#声明类型约束" class="headerlink" title="声明类型约束"></a>声明类型约束</h1><p>在这个最后的小节中，您将要把您之前定义的约束做成一个接口，这样您就可以在更多地方复用他们。通过这种方式声明约束有助于精简代码，特别是当约束的内容逐渐复杂时。</p><p>您可以将类型约束声明为一个接口，这种约束允许任何类型来实现这个接口。例如，如果您声明了一个有三种方法的类型约束接口，并将他应用为一个泛型函数的类型参数，那么用于调用此函数的类型必须实现所有这些方法。</p><p>约束接口也可以指定特定的类型，就像您即将在本节中看到的那样。</p><h2 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h2><ol><li>在 main 函数之前，引入语句之后，粘贴下列用于声明类型约束的代码。</li></ol><div class="indentation"><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Number <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">int64</span> <span class="token operator">|</span> <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在这段代码中，您：</p><ul><li><p>声明了 Number 接口作为类型约束。</p></li><li><p>在 Number 接口中声明了 int64 和 float64。</p></li></ul><div class="indentation"><p>在本质上，您只是将函数中的类型声明换了个地方。此时，当您想要表示 int64 或 float64 的类型时，您可以直接使用 Number 类型，而非 int64 | float64。</p></div><ol start="2"><li>在您之前定义的函数下方，粘贴 SunNumbers 泛型函数。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// SumNumbers sums the values of map m. It supports both integers</span><span class="token comment">// and floats as map values.</span><span class="token keyword">func</span> SumNumbers<span class="token punctuation">[</span>K comparable<span class="token punctuation">,</span> V Number<span class="token punctuation">]</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span>V<span class="token punctuation">)</span> V <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s V    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这段代码中，您：</p><ul><li>声明了一个和原有泛型函数逻辑相同的泛型函数，但使用接口类型取代了原来的类型约束。就像之前一样，您使用类型参数作为函数参数和返回值的类型。</li></ul><ol start="3"><li>在 main.go 中，您现有的代码下方，粘贴如下代码。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Generic Sums with Constraint: %v and %v\n"</span><span class="token punctuation">,</span>    <span class="token function">SumNumbers</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">SumNumbers</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在这段代码中，您：</p><ul><li>调用 SubNumbers，并用之前定义的 map 作为参数，打印每个加总的值。</li></ul><div class="indentation"><p>就像在前面章节中提到的，您在调用泛型函数时省略了类型参数（其中的类型需要被中括号包裹）。Go 编译器可以通过其他参数来推断类型参数。</p></div></div><h2 id="运行代码-3"><a href="#运行代码-3" class="headerlink" title="运行代码"></a>运行代码</h2><p>在命令行中，main.go 文件所在的文件夹路径下，运行命令。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go run <span class="token builtin class-name">.</span>Non-Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span>Generic Sums: <span class="token number">46</span> and <span class="token number">62.97</span>Generic Sums, <span class="token builtin class-name">type</span> parameters inferred: <span class="token number">46</span> and <span class="token number">62.97</span>Generic Sums with Constraint: <span class="token number">46</span> and <span class="token number">62.97</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>很好，您已经靠自己掌握了 Go 中的泛型。</p><p>向您推荐这些主题：</p><ul><li><a href="https://go.dev/tour/">Go Tour</a> 是一个非常优秀的对 Go 的介绍。</li><li>您可以在 <a href="https://go.dev/doc/effective_go">Effective Go</a> 和 <a href="https://go.dev/doc/code">How to write Go code</a> 中找到很多关于 Go 的最佳实践。</li></ul><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>您可以通过在 <a href="https://go.dev/play/p/apNmfVwogK0?v=gotip">Go playground</a> 中点击 <strong>Run</strong> 按钮来运行这些代码。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">type</span> Number <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token builtin">int64</span> <span class="token operator">|</span> <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Initialize a map for the integer values</span>    ints <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int64</span><span class="token punctuation">&#123;</span>        <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token number">34</span><span class="token punctuation">,</span>        <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Initialize a map for the float values</span>    floats <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">&#123;</span>        <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token number">35.98</span><span class="token punctuation">,</span>        <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token number">26.99</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Non-Generic Sums: %v and %v\n"</span><span class="token punctuation">,</span>        <span class="token function">SumInts</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">SumFloats</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Generic Sums: %v and %v\n"</span><span class="token punctuation">,</span>        SumIntsOrFloats<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>        SumIntsOrFloats<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">float64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Generic Sums, type parameters inferred: %v and %v\n"</span><span class="token punctuation">,</span>        <span class="token function">SumIntsOrFloats</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">SumIntsOrFloats</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Generic Sums with Constraint: %v and %v\n"</span><span class="token punctuation">,</span>        <span class="token function">SumNumbers</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">SumNumbers</span><span class="token punctuation">(</span>floats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// SumInts adds together the values of m.</span><span class="token keyword">func</span> <span class="token function">SumInts</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s <span class="token builtin">int64</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span class="token comment">// SumFloats adds together the values of m.</span><span class="token keyword">func</span> <span class="token function">SumFloats</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s <span class="token builtin">float64</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span class="token comment">// SumIntsOrFloats sums the values of map m. It supports both floats and integers</span><span class="token comment">// as map values.</span><span class="token keyword">func</span> SumIntsOrFloats<span class="token punctuation">[</span>K comparable<span class="token punctuation">,</span> V <span class="token builtin">int64</span> <span class="token operator">|</span> <span class="token builtin">float64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span>V<span class="token punctuation">)</span> V <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s V    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span class="token comment">// SumNumbers sums the values of map m. Its supports both integers</span><span class="token comment">// and floats as map values.</span><span class="token keyword">func</span> SumNumbers<span class="token punctuation">[</span>K comparable<span class="token punctuation">,</span> V Number<span class="token punctuation">]</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span>V<span class="token punctuation">)</span> V <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> s V    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Ubuntu22.04LTS上使用 BBR</title>
    <link href="/%E5%9C%A8Ubuntu22.04LTS%E4%B8%8A%E4%BD%BF%E7%94%A8%20BBR.html"/>
    <url>/%E5%9C%A8Ubuntu22.04LTS%E4%B8%8A%E4%BD%BF%E7%94%A8%20BBR.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是BBR"><a href="#什么是BBR" class="headerlink" title="什么是BBR"></a>什么是BBR</h1><blockquote><p>以下内容摘自<a href="https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_BBR">Wiki</a></p></blockquote><span id="more"></span><p>Bottleneck Bandwidth and Round-trip propagation time (BBR) 是由 Google 在 2016年开发的一种拥塞控制算法 (CCA)。虽然其他的拥塞控制算法大多基于丢包机制，通过丢包来检测到拥塞并降低传输速率，但 BBR，和 TCP Vegas 相似，是基于模型的。算法利用网络传送最近一次发出的数据包达到的最大带宽和往返时间来构建网络模型。每次累积确认或选择性确认数据包的传送都会产生一个速率样本，该样本记录了数据包的发送时间和确认时间之间间隔内传送的数据量。</p><p>在 YouTube 的实际部署中，BBRv1 版本平均带来了 4% 的网络吞吐量提升，在某些国家甚至能达到 14%。BBR 算法从 Linux 4.9 版本开始就被集成到 Linux 内核的 TCP 协议栈中。它同样也适用于 QUIC 协议。</p><p>BBR 版本 1 (BBRv1) 对非 BBR 流的公平性存在争议。尽管谷歌的演示文稿显示 BBRv1 可以很好地与 CUBIC 协同工作，但一些研究人员 (例如 Geoff Huston 和 Hock、Bless 及 Zitterbart) 认为它对其他数据流并不公平，并且难以扩展。Hock等人还发现 Linux 4.9 版本的 BBR 实现存在一些严重的固有缺陷，例如增加的队列延迟、不公平性和大量丢包。Soheil Abbasloo 等人 (C2TCP 算法的作者) 指出，BBRv1 版本在动态环境（例如蜂窝网络）中表现不佳。他们还指出 BBR 存在公平性问题。例如，当网络中存在一个 CUBIC 流 (它是 Linux、Android 和 MacOS 操作系统默认的 TCP 实现) 和一个 BBR 流时，BBR 流可能会主导 CUBIC 流，并占用整个链路带宽。</p><p>第 2 版 (Version 2) 尝试解决与基于丢包的拥塞控制 (例如 CUBIC) 共同运行时出现的不公平问题。BBRv2 改进了 BBRv1 的模型，加入了丢包信息和来自显式拥塞通知 (ECN) 的信息。虽然 BBRv2 有时可能比 BBRv1 吞吐量更低，但它通常被认为具有更好的有效吞吐量 (goodput)。[需要来源]</p><p>第 3 版 (BBRv3) 修复了 BBRv2 中的两个漏洞（带宽探测过早结束、带宽收敛问题）并进行了一些性能调整。它还提供了一个变体版本，称为 BBR.Swift，专为数据中心内部链路进行优化：它使用 network_RTT（不包含接收方延迟）作为主要的拥塞控制信号。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>既然 BBR 已经被集成到 Linux 内核中，那么我们稍作配置就可以使用，首先：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token assign-left variable">net.core.default_qdisc</span><span class="token operator">=</span>fq <span class="token operator">>></span> /etc/sysctl.conf<span class="token builtin class-name">echo</span> <span class="token assign-left variable">net.ipv4.tcp_congestion_control</span><span class="token operator">=</span>bbr <span class="token operator">>></span> /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>向 <code>sysctl.conf</code> 写入两条配置：</p><ul><li><code>net.core.default_qdisc=fq</code> 修改 Linux 系统中的的 qdisc 为 fq(fair queue)，避免 BBR 占用太多流量</li><li><code>net.ipv4.tcp_congestion_control=bbr</code> &gt;&gt; 将 ipv4 的 TCP 拥塞控制算法设置为 BBR</li></ul><p>接下来，保存生效：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sysctl</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>查看是否已经应用：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sysctl</span> net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control <span class="token operator">=</span> bbr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>这样就完成了所有配置。</p><p>（经过实际测试，不开启公平队列时 BBR 能提供更大的速率，也许对于一些纯粹跑流量的服务器（例如网络代理），不开启公平队列是更好的用法。）</p>]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>豆知识</tag>
      
      <tag>Linux</tag>
      
      <tag>网络工具</tag>
      
      <tag>VPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转]人月神话的困境：项目经理的挑战与转变</title>
    <link href="/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E7%9A%84%E5%9B%B0%E5%A2%83.html"/>
    <url>/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E7%9A%84%E5%9B%B0%E5%A2%83.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://blog.licsber.site/2024/03/29/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E7%9A%84%E5%9B%B0%E5%A2%83/">人月神话的困境：项目经理的挑战与转变</a></p></blockquote><span id="more"></span><h1 id="线性思维的束缚与局限"><a href="#线性思维的束缚与局限" class="headerlink" title="线性思维的束缚与局限"></a>线性思维的束缚与局限</h1><p>很多“聪明人”的思维都是线性思维，拿到任务，分解成小项，逐个完成，一步一步的像是在做证明题：期待着攒够一个又一个的事实和推理，最后拼图一般将它们串起来，达成某项任务。逻辑层面上看起来无懈可击，仿佛一切困难都可迎刃而解。</p><p>不可否认的是这套思维在应试方面屡试不爽，因为有一个天然的假设是存在的：“所有问题都有标准答案，问题在设计上就是逻辑可解的”。但是习惯这套“逻辑“的人，在处理现实世界的问题时，往往会不自觉地将自己带入死胡同。</p><h1 id="逻辑、事实关联的对立与统一"><a href="#逻辑、事实关联的对立与统一" class="headerlink" title="逻辑、事实关联的对立与统一"></a>逻辑、事实关联的对立与统一</h1><p>我将以上方法论称之为逻辑关联，与之相对的即是事实关联，生活中不乏遇到这种思维陷阱：</p><ul><li>白菜3块钱一斤，15块钱可以买五斤白菜</li><li>你们工厂一个月可以生产3000个零件，那明天先给我10个吧</li><li>这个项目比较急，上次排期的工时是一周，我再给你一倍的人，三天给我做出来</li></ul><p>有时候其实很难意识到这样的思考模式存在的问题，这也是《人月神话》里屡次提到的困境，可能上面的例子不太直观，代入下现实生活：</p><ul><li>生一个孩子需要9个月，生一对双胞胎需要18个月</li><li>生一个孩子需要9个月，9个妈妈是不是只要1个月？！</li></ul><p>专注解决问题的思维方式久了，就会慢慢开始只在乎逻辑关联，而忽略事实关联，就会开始期待一种“银弹”，说是缘木求鱼也不过如此。</p><h1 id="初级项目经理常见的误区与反思"><a href="#初级项目经理常见的误区与反思" class="headerlink" title="初级项目经理常见的误区与反思"></a>初级项目经理常见的误区与反思</h1><p>很多初级项目经理最常犯的错误就在这里，总是期待着任何事情都有一个进度条，这样就可以直观的反馈当前进展，自己要做的也就不过是按照排期表往下催进度。</p><p>这种人最喜欢问的问题就是“你这个要多久才能做出来？”，行使着身为“管理者”的特权，却不承担应有的角色义务。</p><p>项目经理这个角色，真正应该问的问题是“你还需要哪些其他的帮助可以提升你的速度？”。优秀的项目经理知道，项目进度不是靠完成了多少来判断，而是靠如何拥有足够的资源进行最大规模的试错。项目经理确保的应该是满足需求，成功交付。</p><p>然而现实中X-Y本末倒置的现象非常普遍，即为了完成某个目标，制定了一些KPI（关键绩效指标），最后完全忽视了原初的目标，而去追求后定的KPI。就像是前段时间北京环卫工人买新鲜白菜当厨余垃圾事件，政策目标是垃圾分类，管理者制定了每种垃圾必须的数量指标，然后只考察这个数量指标，下面执行的人就变了味，偏离初衷，最终酿成悲剧。</p><h1 id="软件行业里人的特殊性"><a href="#软件行业里人的特殊性" class="headerlink" title="软件行业里人的特殊性"></a>软件行业里人的特殊性</h1><p>再者，项目经理在向上汇报进度的同时，也在享受作为一个管理者的荣誉，以及成功后收割胜利果实。这使得执行层面的人本身就对这些只能汇报进度，却无法承担执行工作的人非常敌视。</p><p>况且在软件开发这个对人依赖非常大的领域，管理起来更需要一定的水平积累。项目经理每天跟人打交道，要知道人是有感情的，绝对不是你给他输入1+1，他就给你输出2。同一个功能点同一个人，由于其工作状态的差别，也会产生巨大的差异，如果主动积极做，可能只要1天，消极怠工的做，就无法预期了。这在传统行业是无法想象的，因为只要按规定的程序和规范来建房子，即使换一拨工人，也可以在同样的时间建造出来，建出来的房子的质量也不会相差太远。要知道，再烂的挖土机也能挖出一个大坑。</p><h1 id="结果导向与过程管理的平衡：避免悲剧的关键"><a href="#结果导向与过程管理的平衡：避免悲剧的关键" class="headerlink" title="结果导向与过程管理的平衡：避免悲剧的关键"></a>结果导向与过程管理的平衡：避免悲剧的关键</h1><p>执行时，对软件工程师来说，遇到问题，解决问题。但如果遇到的问题占用了比预期更多的时间，则是对自己能力和自信的打击。此时如果项目经理也不专业，硬推进度，工程师就会出现一些掩盖问题的行为。</p><p>我总觉得，负责技术攻坚的人也去追进度就很可惜。悲剧的根源是管理能力和技巧的不足，如果真的想做到结果导向，需要的是目标的制定和拆解，工作计划的精确评估和执行，真实有效的复盘，信息同步与应对突发状况的能力，这些都对领导者有很高的要求，如果能力不足以管理结果，那大家就只能来管理过程，最终陷入恶性循环。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.woshipm.com/zhichang/1554995.html">工程师想要做管理？先改变你的思考方式</a></p><p><a href="https://www.cnblogs.com/coprince/p/9155384.html">从程序员到项目经理：为什么要当项目经理</a></p>]]></content>
    
    
    <categories>
      
      <category>软件项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件项目</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Effective Go</title>
    <link href="/effective_go.html"/>
    <url>/effective_go.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://go.dev/doc/effective_go">Effective Go</a></p></blockquote><span id="more"></span><p>目录</p><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul><li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li></ul></li><li><a href="#%E6%A0%BC%E5%BC%8F">格式</a></li><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li><li><a href="#%E5%91%BD%E5%90%8D">命名</a><ul><li><a href="#%E5%8C%85%E5%91%BD%E5%90%8D">包命名</a></li><li><a href="#Getters">Getters</a></li><li><a href="#%E6%8E%A5%E5%8F%A3%E5%91%BD%E5%90%8D">接口命名</a></li><li><a href="#%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D">驼峰命名</a></li></ul></li><li><a href="#%E5%88%86%E5%8F%B7">分号</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">控制结构</a><ul><li><a href="#If">If</a></li><li><a href="#%E9%87%8D%E5%A3%B0%E6%98%8E%E4%B8%8E%E9%87%8D%E8%B5%8B%E5%80%BC">重声明与重赋值</a></li><li><a href="#For">For</a></li><li><a href="#Switch">Switch</a></li><li><a href="#Type-switch">Type switch</a></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a><ul><li><a href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC">多返回值</a></li><li><a href="#%E5%91%BD%E5%90%8D%E7%BB%93%E6%9E%9C%E5%8F%82%E6%95%B0">命名结果参数</a></li><li><a href="#Defer">Defer</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE">数据</a><ul><li><a href="#%E9%80%9A%E8%BF%87new%E5%88%86%E9%85%8D">通过new分配</a></li><li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8E%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F">构造器与复合字面量</a></li><li><a href="#%E9%80%9A%E8%BF%87make%E5%88%86%E9%85%8D">通过make分配</a></li><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E5%88%87%E7%89%87">切片</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%88%87%E7%89%87">二维切片</a></li><li><a href="#Maps">Maps</a></li><li><a href="#%E6%89%93%E5%8D%B0">打印</a></li><li><a href="#Append">Append</a></li></ul></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a><ul><li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#init%E5%87%BD%E6%95%B0">init函数</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a><ul><li><a href="#%E6%8C%87%E9%92%88%E6%88%96%E6%98%AF%E5%80%BC">指针或是值</a></li></ul></li><li><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B">接口和其他类型</a><ul><li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li><li><a href="#%E8%BD%AC%E6%8D%A2">转换</a></li><li><a href="#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">接口转换与类型断言</a></li><li><a href="#%E6%A6%82%E8%AE%BA">概论</a></li><li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%96%B9%E6%B3%95">接口与方法</a></li></ul></li><li><a href="#%E7%A9%BA%E6%A0%87%E8%AF%86%E7%AC%A6">空标识符</a><ul><li><a href="#%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%87%E8%AF%86%E7%AC%A6">多重赋值中的空标识符</a></li><li><a href="#%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BC%95%E5%85%A5%E5%92%8C%E5%8F%98%E9%87%8F">未使用的引入和变量</a></li><li><a href="#%E4%B8%BA%E4%BA%86%E6%BD%9C%E5%9C%A8%E4%BD%9C%E7%94%A8%E8%80%8C%E5%BC%95%E5%85%A5">为了潜在作用而引入</a></li><li><a href="#%E6%8E%A5%E5%8F%A3%E6%A3%80%E6%9F%A5">接口检查</a></li></ul></li><li><a href="#%E5%B5%8C%E5%85%A5%E5%BC%8F">嵌入式</a></li><li><a href="#%E5%B9%B6%E5%8F%91">并发</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E9%80%9A%E4%BF%A1%E5%85%B1%E4%BA%AB">通过通信共享</a></li><li><a href="#Goroutines">Goroutines</a></li><li><a href="#Channels">Channels</a></li><li><a href="#Channels-of-channels">Channels of channels</a></li><li><a href="#%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86">并行处理</a></li><li><a href="#A-leaky-buffer">A leaky buffer</a></li></ul></li><li><a href="#%E9%94%99%E8%AF%AF">错误</a><ul><li><a href="#Panic">Panic</a></li><li><a href="#Recover">Recover</a></li></ul></li><li><a href="#%E4%B8%80%E4%B8%AAWEB%E6%9C%8D%E5%8A%A1%E5%99%A8">一个WEB服务器</a></li></ul><head>  <style>    .indentation {      margin-left: 2rem;    }  </style></head><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Go 是一门新语言。虽然他借鉴了现有编程语言的思想，但他也具有独特的特性，使得有效的 Go 程序与其他语言编写的程序有性质上的不同。直接将 C++ 或 Java 程序改编为 Go 程序可能无法得到一个让人满意的结果——Java 程序是使用 Java 编写的，而不是 Go。另一方面，从 Go 的角度思考问题可能会产生一个成功但完全不同的程序。换句话说，要写好Go，重要的是要理解它的特性和习惯用法。了解 Go 编程的既定约定也很重要，例如命名、格式、程序构造等，这样您编写的程序将易于其他 Go 程序员理解。</p><p>这份文档提供了编写清晰、地道的 Go 代码的建议。他补充了 <a href="https://go.dev/ref/spec">language specification</a>、<a href="https://go.dev/tour/">the Tour of Go</a>以及 <a href="https://go.dev/doc/code.html">How to Write Go Code</a> 这几份资料，建议您在阅读本指南之前先阅读这些资料。</p><p>2022 年 1 月注：这份指南最初发布于 2009 年，自那以来更新并不频繁。虽然他仍然是理解如何使用 Go 语言本身的良好指南（因为语言本身很稳定），但他几乎没有涉及到 Go 生态系统自发布以来的重大变化，例如构建系统、测试、模块化和多态性。由于近年来变化太多，官方也不会再更新此文档。目前已经有很多文档、博客和书籍详细描述了现代 Go 的用法，足以满足学习需求。因此，虽然这份「Effective Go」指南仍然可用，但读者需要理解它并不是全面的指南。详情请参阅 <a href="https://go.dev/issue/28782">issue 28782</a>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://go.dev/src/">Go package sources</a>不仅是核心库，还包含了如何使用该语言的示例。此外，许多标准库包都包含可直接在 <a href="https://go.dev/">go.dev</a> 网站上运行的独立可执行示例（例如<a href="https://go.dev/pkg/strings/#example-Map">本例</a>，如果需要，可以点击 Example 按钮打开它）。如果您对如何解决问题或如何实现某项功能有疑问，那么标准库中的文档、代码和示例可以提供答案、思路和背景信息。</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>格式问题是争议最大但影响最小的问题。人们可以适应不同的格式风格，但如果没有必要的话，最好保持统一，这样大家就可以少花时间在格式上争论。 难点在于如何在没有冗长强制性风格指南的情况下实现这种「乌托邦」式的统一格式。</p><p>对于 Go 代码格式，我们采用了一种不同寻常的方法，让机器来处理大多数格式化问题。gofmt 程序（也可以称为 go fmt，它在包级别而不是源文件级别工作）读取一个 Go 程序，并按照标准的缩进和垂直对齐样式输出源代码，同时保留并根据需要重新格式化注释。如果您想了解如何处理一些新的布局情况，请运行 gofmt； 如果答案看起来不对，请重新排列您的程序（或提交有关 gofmt 的 bug 报告），不要试图绕过它。</p><p>例如，不必浪费时间去对齐结构体中的注释，Gofmt 会协助你处理，对于如下声明：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    name <span class="token builtin">string</span> <span class="token comment">// name of the object</span>    value <span class="token builtin">int</span> <span class="token comment">// its value</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>gofmt 会将列对其：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    name    <span class="token builtin">string</span> <span class="token comment">// name of the object</span>    value   <span class="token builtin">int</span>    <span class="token comment">// its value</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>所有标准库中的 Go 代码都使用 gofmt 进行了格式化。</p><p>简要的介绍一下格式化的细节：</p><p>缩进</p><div class="indentation">我们使用制表符 (tab) 进行缩进，gofmt 工具默认也会采用这种方式。只有在绝对必要的情况下才使用空格。</div><br /><p>行长</p><div class="indentation">Go 没有代码行长限制。不用担心代码会超出打孔卡的限制。如果一行代码看起来太长，可以将其换行并使用额外的制表符缩进。</div><br /><p>括号</p><div class="indentation">与 C 和 Java 语言相比，Go 需要更少的括号：控制结构 (if、for、switch) 的语法本身不需要括号。此外，Go 的运算符优先级层次更短更清晰。因此<figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">x<span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">+</span> y<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>通过间隔暗示了执行顺序，这一点和其他编程语言不同。</p></div><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Go 提供了 C 风格的 &#x2F;* *&#x2F; 块状注释和 C++ 风格的 &#x2F;&#x2F; 行注释。通常情况下会使用行注释，块状注释往往是在包注释中使用，但也可以用在表达式中或禁用大块的代码。</p><p>位于顶层声明之前的注释，如果没有额外的空行隔开，就会被视为该声明的文档。这些“文档注释”是 Go 程序包或命令的主要文档形式。有关文档注释的更多信息，请参阅“<a href="https://go.dev/doc/comment">Go Doc Comments</a>”。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>在 Go 中，命名和其他语言一样重要。他们甚至具有语义上的影响：一个名称对于包外部的可见性取决于他的首字母是否大写。因此，值得花一点时间讨论 Go 程序中的命名约定。</p><h2 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h2><p>当一个包被引入时，包名称就成为了其内容的入口，当做了如下引入之后</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"bytes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>引入该包的程序可以使用 bytes.Buffer。所有人都使用相同的名称来引用包的内容有很多好处，这也意味着包的命名必须是优秀的：短，简洁，意义明确。按照约定，包使用小写单个单词命名，不应出现下划线或驼峰命名。宁可过于简洁，因为每个使用您的包的人都需要输入这个名称。也无需担心包名的重复，包名只是引入时的默认名称，他不必在所有的源码中保持唯一，在极少数的包名重复的情况下，引入包可以选择一个本地使用的别名。无论如何，包名重复都是很罕见的，因为引入中的文件名决定了在使用哪个包。</p><p>另一个约定是包名是他源文件夹的基础名称，src&#x2F;encoding&#x2F;base64 中的包被 “encoding&#x2F;base64” 引入，但使用名称为 base64，并非 encoding_base64 或 encodingBase64。</p><p>引入包的程序会使用包名来引用包中的内容，因此包导出的名称可以利用这一点来避免重复（不要使用 import . 来省略包名，他可以简单的运行一些必须在包外部运行的测试，但应该在其他场合下避免）。例如，在 bufio 包中的缓冲读取器被命名为 Reader，而不是 BufReader，因为使用者看到的将会是 bufio.Reader，这是一个清晰、简洁的名称。此外，由于引入的内容总是和引入的包名一起使用，因此 bufio.Reader 并不会和 io.Reader 冲突。相似的，创建 ring.Ring 新实例的函数——也就是 Go 中的构造函数——通常被命名为 NewRing，但是考虑到 Ring 是 ring 包中导出的唯一类型，而且又因为包名已经是 ring，所以这个函数只需被命名为 New，包的使用者看到的是 ring.New。利用包的结构可以帮助你选择合适的命名。</p><p>另一个简短的示例是 once.Do，once.Do(setup) 读起来非常友好，而且明显优于 once.DoOrWaitUntilDone(setup)。长的命名不一定能带来更丰富的含义。一个实用的文档注释常常比长的命名更有价值。</p><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>Go 没有提供对 getters 和 setters 的自动支持。但您可以自己添加 getters 和 setters，而且这也常常是很适合的，但是在 getter 的名称前加上 Get 即不必须，也不符合 Go 的习惯。假设你有一个名为 owner 的字段（小写，非导出），那么他的 getter 方法应该被命名为 Owner（大写，导出），而不是 GetOwner。使用大写名称来作为导出标志可以方便的区分字段和方法。如果需要的话，他的 setter 函数应该被命名为 SetOwner。这些名称在实践中具有很好的阅读性：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">owner <span class="token operator">:=</span> obj<span class="token punctuation">.</span><span class="token function">Owner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> owner <span class="token operator">!=</span> user <span class="token punctuation">&#123;</span>    obj<span class="token punctuation">.</span><span class="token function">SetOwner</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h2><p>按照约定，只有一个方法的接口会使用方法名加 -er 后缀或类似的修改，构成一个表示操作者的名词：Reader，Writer，Formatter，CloseNotifier 等等。</p><p>许多常用方法名已经约定俗成，遵循这些既有命名并保持其含义是高效的。Read，Write，Close，Flush，String 等都拥有标准的方法签名和含义。为了避免混淆，不要给你的方法起这些名称，除非它们的方法签名和含义完全相同。相反地，如果你的实现具有和现有类型完全相同的方法签名和含义，那么就应该使用相同的名称和方法签名。例如，将你的字符串转换方法命名为 String，而不是 ToString。</p><h2 id="驼峰命名"><a href="#驼峰命名" class="headerlink" title="驼峰命名"></a>驼峰命名</h2><p>最后，Go 中处理多个单词的名称时使用大驼峰命名或小驼峰命名，而非下划线连接。</p><h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>和 C 相同，Go 的语法使用分号来终止语句，但与 C 不同的是，这些分号不会出现在源码中。取而代之的是，词法分析器会使用一个简单的规则在扫描时自动插入分号，因此输入的文本基本上无需含有分号。</p><p>规则是这样的。如果在换行符之前的最后一个词是类型标志（比如 int 和 float64），基本字面量（比如一个数字或字符串），或是以下之一：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">break continue fallthrough return ++ -- ) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>词法分析器会在这些词后插入一个分号。可以这样总结“如果一个换行符前的词可以使用分号结尾，则插入一个分号”。</p><p>右大括号前的分号也可以省略，因此这样的语句</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">for</span> <span class="token punctuation">&#123;</span> dst <span class="token operator">&lt;-</span> <span class="token operator">&lt;-</span>src <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>无需分号。地道的 Go 程序只会在类似于 for 循环处使用分号，用来区分初始化语句、约束条件和循环动作。如果您必须要将多条语句写入同一行中，那么他们之间也需要分号。</p><p>分号插入规则带来的后果之一是你不能将左大括号放置在控制语句（if，for，switch，select）的下一行。如果您这样做了，大括号前会被插入一个分号，这会带来一些不良影响。应该这样写</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>而不是这样写</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// wrong!</span><span class="token punctuation">&#123;</span>           <span class="token comment">// wrong!</span>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><p>Go 中的控制结构与 C 息息相关，但在一些重要的方面又有所不同。没有 do 或 while 循环，只有一个更通用的 for；switch 更加灵活；if 和 switch 像 for 一样可以设置初始化语句；break 和 continue 语句采用可选标签来标识需要中断或继续的内容；有一些新的控制结构例如type switch 和一个多路选择器 select。语法也略有不同：没有小括号，并且主体内容必须用大括号包裹。</p><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><p>Go 中简单的 If 看起来是这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> y<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>强制要求的大括号鼓励使用多行书写简单的 if 语句。无论如何，这都是一种好的代码风格，特别是当主体内容包含 return 或 break 之类的控制语句的时候。</p><p>由于 if 和 switch 可以接收一个初始化语句，因此通常会看到他被用来设置局部变量。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Chmod</span><span class="token punctuation">(</span><span class="token number">0664</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在 Go 库中，你会发现当 if 语句不流入下一个语句时——即内容主体使用 break，continue，goto 或 return 结尾——不必要的 else 会被省略。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token function">codeUsing</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是一个常见情况的示例，其中的代码必须考虑一系列的错误情况。代码的可读性很好，成功的步骤按序向下执行，错误总是在他出现的地方被处理。由于错误情况都使用 return 语句结束流程，因此不需要使用 else 语句。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> err<span class="token punctuation">&#125;</span>d<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token function">codeUsing</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="重声明与重赋值"><a href="#重声明与重赋值" class="headerlink" title="重声明与重赋值"></a>重声明与重赋值</h2><p>上一节的例子通过调用 os.Open 函数展示了如何使用 :&#x3D; 进行短声明</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这行代码声明了两个变量，f 和 err。几行后，又调用了 f.Stat</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">d<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这看起来是声明了 d 和 err。但请注意，这两行代码都出现了 err。这种重复是合法的：err 只被第一行代码声明，在第二行代码中只是被<em>重赋值（re-assigned）</em>。这意味着调用 f.Stat 使用的是之前声明的 err，此处仅仅是给他赋予新的值。</p><p>在一个 :&#x3D; 赋值中，已经被声明的变量 v 仍然可以被重赋值，只要：</p><ul><li>本次声明和已经存在的对 v 的声明在同一个代码空间（如果 v 是在外部空间被声明的，那么本次声明会创造一个新的变量§），</li><li>初始化中相应的值可以被赋值给 v，而且</li><li>本次声明中至少包括一个全新被声明的变量。</li></ul><p>这样的非常规设计是纯粹的实用主义，使得使用单个 err 变得很容易，例如在一长串的 if-else 中。你会经常看到这样的用法。</p><p>§ 这里值得注意的是，在 Go 中，函数的参数和返回值的空间与函数体相同，即使它们在词法上出现在函数体的大括号之外。</p><h2 id="For"><a href="#For" class="headerlink" title="For"></a>For</h2><p>Go 中的 for 循环和 C 中的 for 循环相似但又不同。他统一了 for 循环和 while 循环，并且没有 do-while 循环。总共有三种形式，其中只有一种带有分号。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Like a C for</span><span class="token keyword">for</span> init<span class="token punctuation">;</span> condition<span class="token punctuation">;</span> post <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token comment">// Like a C while</span><span class="token keyword">for</span> condition <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token comment">// Like a C for(;;)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>短声明方式让声明循环中使用的索引变得容易。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">sum <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> i<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果您在循环数组、切片、字符串或 map，又或是在读取 channel，range 关键字可以帮助你管理循环。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> oldMap <span class="token punctuation">&#123;</span>    newMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>如果您只需要 range 中的第一个参数（key 或者 index），那么丢掉第二个：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> key<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果你只需要 range 中的第二个参数（值），使用空标识，也就是下划线，从而丢弃第一个参数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">sum <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> array <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> value<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>空标识有很多种用法，就像<a href="#%E7%A9%BA%E6%A0%87%E8%AF%86%E7%AC%A6">后续章节</a>中描述的这样。</p><p>对于字符串，range 为您做了更多的事情，通过解析 UTF-8 来分解各个 Unicode 码。错误的编码消耗一个 byte 并使用 rune U+FFFD 代替（rune 是 Go 中称呼和使用单个 Unicode 码点的术语。参考<a href="https://go.dev/ref/spec">language specification</a>了解更多）。对于下面的循环</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> pos<span class="token punctuation">,</span> char <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token string">"日本\x80語"</span> <span class="token punctuation">&#123;</span> <span class="token comment">// \x80 is an illegal UTF-8 encoding</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"character %#U starts at byte position %d\n"</span><span class="token punctuation">,</span> char<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>输出为</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">character U+65E5 '日' starts at byte position 0character U+672C '本' starts at byte position 3character U+FFFD '�' starts at byte position 6character U+8A9E '語' starts at byte position 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后，Go 没有逗号运算符， ++ 和 -- 是语句而不是表达式。因此如果你在 for 中运行多个变量，你应该使用多重赋值（不包括 ++ 和 --）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Reverse a</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>Go 中的 switch 比 C 中的更通用。表达式不需要是常量，甚至不需要是整数，cases 从上向下匹配，直到寻找到匹配项，如果 switch 没有表达式，则他匹配到 true。因此，习惯上可以将 if-else-if-else 链编写为 switch。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">unhex</span><span class="token punctuation">(</span>c <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">byte</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token char">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token char">'0'</span>    <span class="token keyword">case</span> <span class="token char">'a'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'f'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">+</span> <span class="token number">10</span>    <span class="token keyword">case</span> <span class="token char">'A'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'F'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token char">'A'</span> <span class="token operator">+</span> <span class="token number">10</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Go 语言的 switch 不会自动执行下一个分支，但是可以使用逗号分隔的列表来组合判断条件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">shouldEscape</span><span class="token punctuation">(</span>c <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> c <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token char">' '</span><span class="token punctuation">,</span> <span class="token char">'?'</span><span class="token punctuation">,</span> <span class="token char">'&amp;'</span><span class="token punctuation">,</span> <span class="token char">'='</span><span class="token punctuation">,</span> <span class="token char">'#'</span><span class="token punctuation">,</span> <span class="token char">'+'</span><span class="token punctuation">,</span> <span class="token char">'%'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>尽管他们在 Go 中不像在其他一些类似 C 的语言中那么常见，但 break 语句可以用来中止 switch。但有时，我们需要打破外围的循环，而非 switch，在 Go 中可以通过在循环上放置标签并 “breaking” 该标签来完成。下面的例子演示了这两种用途。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">Loop<span class="token punctuation">:</span>    <span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> n <span class="token operator">+=</span> size <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> src<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sizeOne<span class="token punctuation">:</span>            <span class="token keyword">if</span> validateOnly <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            size <span class="token operator">=</span> <span class="token number">1</span>            <span class="token function">update</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">case</span> src<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sizeTwo<span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                err <span class="token operator">=</span> errShortInput                <span class="token keyword">break</span> Loop            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> validateOnly <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            size <span class="token operator">=</span> <span class="token number">2</span>            <span class="token function">update</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> src<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>shift<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然， continue 语句也可以接受标签，但他仅适用于循环。</p><p>为了完成这个章节，这里有一个使用两个 switch 语句的字节切片比较函数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Compare returns an integer comparing the two byte slices,</span><span class="token comment">// lexicographically.</span><span class="token comment">// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a > b</span><span class="token keyword">func</span> <span class="token function">Compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">case</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">case</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h2><p>switch 也可以用来发现接口变量的动态类型。这种 type switch 使用类型断言的语法，并将关键字 type 放在括号内。如果 switch 在表达式中声明了变量，那么变量会在每个匹配项中获得相应的类型。在每个 case 项中使用相同的名称也是惯用的做法，实际上是在每个 case 中声明了名称相同但类型不同的变量。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> t <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>t <span class="token operator">=</span> <span class="token function">functionOfSomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">switch</span> t <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">default</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"unexpected type %T\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>     <span class="token comment">// %T prints whatever type t has</span><span class="token keyword">case</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"boolean %t\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>             <span class="token comment">// t has type bool</span><span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"integer %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>             <span class="token comment">// t has type int</span><span class="token keyword">case</span> <span class="token operator">*</span><span class="token builtin">bool</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"pointer to boolean %t\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token comment">// t has type *bool</span><span class="token keyword">case</span> <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"pointer to integer %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token comment">// t has type *int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Go 中的一个特殊特性是函数和方法可以返回多个值。这种形式可以用于改进 C 程序中的几个笨拙的惯用方法：例如通过返回 -1 来表示 EOF 或是修改一个使用指针传入的参数。</p><p>在 C 语言中，write 错误通过一个负数来表示，而错误代码隐藏在容易丢失的变量中。在 Go 中， Write 可以同时返回计数和错误：“你写入了一些字节，但没有完全写入，因为你的磁盘满了”。在 os 包中的 Write 方法的方法签名是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>file <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>正如文档所说，当 n !&#x3D; len(b) 时，函数返回了已经写入的字节数和一个非 nil 的 error。这是一个通用的风格，查看关于错误处理的章节了解更多例子。</p><p>一个类似的可以用来替代传递指针作为参数的方法是，通过返回一个值来模拟引用参数。这里是一个简单的函数，用来从字节切片的某个定位开始抓取数字，并返回数字和数字后的定位。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">nextInt</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isDigit</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    x <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDigit</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        x <span class="token operator">=</span> x<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> <span class="token function">int</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> x<span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>您可以通过这样的方式使用，扫描切片 b 中的数字：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>    x<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> i<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="命名结果参数"><a href="#命名结果参数" class="headerlink" title="命名结果参数"></a>命名结果参数</h2><p>在 Go 函数中返回的结果“参数”可以被命名并像其他常规变量一样使用，就像输入参数一样。当被命名时，他们会在函数开始时被初始化为其对应类型的0值；如果函数执行不带参数的返回，那么这些结果参数的当前值会被用作返回值。</p><p>命名不是强制性的，但是他们会让代码更加简短和清晰：他们是文档的一种。如果我们将 nextInt 函数的返回结果命名，那么返回的 int 的含义将变得显而易见。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">nextInt</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> pos <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> nextPos <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>因为命名的返回值已经和不带参数的 return 绑定在了一起，他们可以用来简化和澄清代码。这里是使用命名结果参数的 io.ReadFull：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ReadFull</span><span class="token punctuation">(</span>r Reader<span class="token punctuation">,</span> buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> nr <span class="token builtin">int</span>        nr<span class="token punctuation">,</span> err <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>        n <span class="token operator">+=</span> nr        buf <span class="token operator">=</span> buf<span class="token punctuation">[</span>nr<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>Go 中的 defer 语句可以在当前执行的函数返回前执行一次函数调用（ <em>deferred</em> 函数）。这是一个不寻常但有效的方案，可以用来处理类似于在任何函数执行路径下的资源关闭问题。典型的例子是解锁一个 mutex 或关闭一个文件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Contents returns the file's contents as a string.</span><span class="token keyword">func</span> <span class="token function">Contents</span><span class="token punctuation">(</span>filename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err    <span class="token punctuation">&#125;</span>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// f.Close will run when we're finished.</span>    <span class="token keyword">var</span> result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>    buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// append is discussed later.</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err  <span class="token comment">// f will be closed if we return here.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span> <span class="token comment">// f will be closed if we return here.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>通过 defer 调用 Close 函数有两个好处。其一， 他确保了你不会忘记关闭这个文件，尤其是你之后再为函数添加更多种返回路径时。其二，他意味着 close 的位置与 open 在一起，这比将他放在函数的末尾要清晰的多。</p><p>deferred 函数的参数（或是 deferred 方法的接收者）是在 <em>defer</em> 语句执行时计算的（意味着创建一个闭包），而非是在函数被调用时计算。除了无需担心在函数执行过程中的变量值改变外，这也意味着一个 defer 语句可以创建多个延迟执行的函数。这是一个不太聪明的示例。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>Deferred 函数按照后进先出的顺序执行，因此这段代码会在函数返回时打印 4 3 2 1 0。一个更合理的例子是简单的通过程序跟踪函数调用的方法。我们可以写一些类似这样的跟踪例程：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">trace</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"entering:"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">untrace</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"leaving:"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token comment">// Use them like this:</span><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> <span class="token function">untrace</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>    <span class="token comment">// do something....</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以利用 deferred 函数是在 defer 执行时计算参数这一事实来做的更好。tracing 例程可以用来设置 untracing 例程的参数。下面是例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">trace</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"entering:"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>    <span class="token keyword">return</span> s<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">un</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"leaving:"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">defer</span> <span class="token function">un</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in a"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">defer</span> <span class="token function">un</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in b"</span><span class="token punctuation">)</span>    <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">entering: bin bentering: ain aleaving: aleaving: b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对于在其他编程语言中习惯了块级资源管理的程序员来说，defer 也许看起来有些特殊，但是他最有趣也是最强大的的应用恰恰来自于他是基于函数而非基于块的事实。在 panic 与 recover 章节我们会看到这种可能性的例子。</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="通过new分配"><a href="#通过new分配" class="headerlink" title="通过new分配"></a>通过new分配</h2><p>Go 中有两个分配关键字，内置函数 new 和 make。他们做不同的事情而且用于不同的类型，这可能会令人困惑，但是规则实际上很简单。让我们先从 new 开始。这是一个内建的用于分配内存的函数，但与一些其他编程语言中的同名函数不同，他并不会初始化内存，而只是将内存值置零。也就是说，new(T) 分配了一块零值的内存用来放置类型 T 并返回他的指针，一个类型为 *T 的值。在 Go 术语中，他返回了一个指向新分配的零值 T 的指针。</p><p>由于 new 返回的内存值总是 0，因此在设计您的数据结构时，将 0 值作为一个合理的初始化值就非常有帮助。这意味着数据结构的使用者可以通过 new 来创建他并立刻使用。例如 bytes.Buffer 的文档表示“零值的 Buffer 是一个可以被使用的空 buffer”。类似的，sync.Mutex 也没有显式的构造函数或是初始化方法。取而代之的是，零值的 sync.Mutex 被定义为一个未锁定的 mutex。</p><p>零值有效的设计方式是可以传递的，考虑下述类型声明。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> SyncedBuffer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    lock    sync<span class="token punctuation">.</span>Mutex    buffer  bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>类型为 SyncedBuffer 的值也可以在被分配或声明后立即使用。在下面的片段里，p 和 v 都可以在无需更多参数的情况下正确使用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>SyncedBuffer<span class="token punctuation">)</span>  <span class="token comment">// type *SyncedBuffer</span><span class="token keyword">var</span> v SyncedBuffer      <span class="token comment">// type  SyncedBuffer</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="构造器与复合字面量-composite-literals"><a href="#构造器与复合字面量-composite-literals" class="headerlink" title="构造器与复合字面量(composite literals)"></a>构造器与复合字面量(composite literals)</h2><p>有些情况下无法通过零值初始化，这时就需要构造器，例如这个 os 包中的例子。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewFile</span><span class="token punctuation">(</span>fd <span class="token builtin">int</span><span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>File <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">&#125;</span>    f <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span>    f<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd    f<span class="token punctuation">.</span>name <span class="token operator">=</span> name    f<span class="token punctuation">.</span>dirinfo <span class="token operator">=</span> <span class="token boolean">nil</span>    f<span class="token punctuation">.</span>nepipe <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> f<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里有很多的赋值操作。我们可以简单的使用复合字面量，这是一种在每次执行时创建一个新实例的表达式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewFile</span><span class="token punctuation">(</span>fd <span class="token builtin">int</span><span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>File <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">&#125;</span>    f <span class="token operator">:=</span> File<span class="token punctuation">&#123;</span>fd<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>f<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请注意，与 C 不同，返回局部变量的地址是完全可行的；在函数返回后与变量关联的存储依然存在。实际上，每次获取复合字面量地址时都会分配一个新的实例，因此我们可以合并最后两行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">return</span> <span class="token operator">&amp;</span>File<span class="token punctuation">&#123;</span>fd<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>复合字面量中的字段必须按序且全部存在。然而，通过使用 field:value 对标记元素，初始值设定可以以任何顺序出现，缺失的字段保留位各自的零值。因此我们可以</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">return</span> <span class="token operator">&amp;</span>File<span class="token punctuation">&#123;</span>fd<span class="token punctuation">:</span> fd<span class="token punctuation">,</span> name<span class="token punctuation">:</span> name<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>作为一个特殊情况，如果复合字面量没有包括任何字段，他会创建当前类型的零值对象。表达式 new(File) 和 &amp;File{} 是等效的。</p><p>复合字面量也可以用来创建数组、切片和 maps，其中的字段标签被视为索引或 map 中的键。在这些示例中，只要 Enone、Eio、Einval 的值不同，无论他们的值如何，初始化都会生效。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span>   <span class="token punctuation">&#123;</span>Enone<span class="token punctuation">:</span> <span class="token string">"no error"</span><span class="token punctuation">,</span> Eio<span class="token punctuation">:</span> <span class="token string">"Eio"</span><span class="token punctuation">,</span> Einval<span class="token punctuation">:</span> <span class="token string">"invalid argument"</span><span class="token punctuation">&#125;</span>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>      <span class="token punctuation">&#123;</span>Enone<span class="token punctuation">:</span> <span class="token string">"no error"</span><span class="token punctuation">,</span> Eio<span class="token punctuation">:</span> <span class="token string">"Eio"</span><span class="token punctuation">,</span> Einval<span class="token punctuation">:</span> <span class="token string">"invalid argument"</span><span class="token punctuation">&#125;</span>m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>Enone<span class="token punctuation">:</span> <span class="token string">"no error"</span><span class="token punctuation">,</span> Eio<span class="token punctuation">:</span> <span class="token string">"Eio"</span><span class="token punctuation">,</span> Einval<span class="token punctuation">:</span> <span class="token string">"invalid argument"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="通过make分配"><a href="#通过make分配" class="headerlink" title="通过make分配"></a>通过make分配</h2><p>回到内存分配的话题。内置函数 make(T, args) 提供了一个与 new(T) 不同的用途。他只用来创建切片、maps 和 channels，而且他返回一个已经被初始化的（非零值）的 T 的值（而非 *T）。区别的原因是这三种类型在底层都是对必须被初始化的某种数据结构的引用。例如切片，由三个元素组成，指向数据的指针（数据是内置的数组）、长度和容量，在这些元素被初始化前，切片的值是 nil。对于切片、maps 和 channels，make 初始化了他们内部的数据结构而且提供了可用的值。对于，</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>分配了一个长度为 100 int 的数组，随后创建切片结构，长度为 10，容量为 100，指向数组最初的 10 个元素。（在创建切片时，可以不手动指定容量；参考切片章节了解更多信息）。相反，new([]int) 返回一个新分配的，值为零的切片结构的指针，也就是一个指向 nil 切片值的指针。</p><p>这些例子阐明了 new 和 make 的区别。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> p <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>       <span class="token comment">// allocates slice structure; *p == nil; rarely useful</span><span class="token keyword">var</span> v  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// the slice v now refers to a new array of 100 ints</span><span class="token comment">// Unnecessarily complex:</span><span class="token keyword">var</span> p <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">// Idiomatic:</span>v <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请记住，make 用于 maps，切片和 channels，并不返回指针。如果想要显式的获得指针，需要使用 new 或是显式的获取变量的地址。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在进行详细的内存规划时很有用，而且有时候可以用来避免分配动作，但是大部分时候他们还是用于作为切片的一部分使用，也就是下一个章节的主题。为了给下一个主题打下基础，这里简单介绍一下数组。</p><p>这里有一些 Go 中数组和 C 中数组的主要区别。在 Go 中，</p><ul><li>数组是值，将一个数组赋值给另一个会复制所有的元素。</li><li>特别是，将数组传递给函数，他会收到数组的副本，而不是数组的指针。</li><li>数组的尺寸使其类型的一部分。[10]int 和 [20]int 是不同的类型。</li></ul><p>使用值传递可能会有用，但是开销也很大；如果你想要和 C 相似的表现方式和效率，你可以传递一个数组的指针。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Sum</span><span class="token punctuation">(</span>a <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sum <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token operator">*</span>a <span class="token punctuation">&#123;</span>        sum <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">&#125;</span>array <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">&#123;</span><span class="token number">7.0</span><span class="token punctuation">,</span> <span class="token number">8.5</span><span class="token punctuation">,</span> <span class="token number">9.1</span><span class="token punctuation">&#125;</span>x <span class="token operator">:=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>array<span class="token punctuation">)</span>  <span class="token comment">// Note the explicit address-of operator</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但是这也不是 Go 中的惯用方式，Go 程序员使用切片。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片封装了数组，提供了一个更加通用、强大、方便的处理序列数据的接口。除了例如变换矩阵这种有显式的维度的情况外，在 Go 中大部分关于序列数据的编程都是通过切片而非数组完成的。</p><p>切片持有了对其下层数组的引用，如果你将一个切片赋值给另一个，他们将会引用同一个数组。如果函数使用切片作为参数，则调用者可以看到函数对切片中元素的修改，类似于传递了下层数组的指针。因此，Read 函数可以接收切片作为参数，而非指针和计数；切片中的长度设置了要读取数据内容的上限。这里是 os 包中 File 类型的 Read 方法的方法签名：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>该方法返回读取的字节数和可能的错误值。如果想要将前 32 个字节的内容读取到一个大容量的 buffer（名为 buf）中，可以对这个 buffer 进行切片（此处为动词）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">n<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这种切片是常见且高效的。事实上，暂且不考虑执行效率，下面的代码片段也可以将前 32 个字节读取到 buffer 中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> n <span class="token builtin">int</span><span class="token keyword">var</span> err <span class="token builtin">error</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    nbytes<span class="token punctuation">,</span> e <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// Read one byte.</span>    n <span class="token operator">+=</span> nbytes    <span class="token keyword">if</span> nbytes <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        err <span class="token operator">=</span> e        <span class="token keyword">break</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>切片的长度可以在其底层数据限制的范围内任意修改；只要切取他自身的一部分并赋值即可。切片的容量可以通过内建函数 cap 访问，报告了切片可用的最大长度。这里是一个向切片添加数据的函数。如果数据超出了容量限制，切片会采用重新分配的内存。最终的结果是函数返回的切片。设计这个函数时巧妙利用了如下事实：对 nil 切片使用 len 和 cap 操作是合法的，且会返回 0。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Append</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">&#123;</span>    l <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span>    <span class="token keyword">if</span> l <span class="token operator">+</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">cap</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// reallocate</span>        <span class="token comment">// Allocate double what's needed, for future growth.</span>        newSlice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>l<span class="token operator">+</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment">// The copy function is predeclared and works for any slice type.</span>        <span class="token function">copy</span><span class="token punctuation">(</span>newSlice<span class="token punctuation">,</span> slice<span class="token punctuation">)</span>        slice <span class="token operator">=</span> newSlice    <span class="token punctuation">&#125;</span>    slice <span class="token operator">=</span> slice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>l<span class="token operator">+</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token function">copy</span><span class="token punctuation">(</span>slice<span class="token punctuation">[</span>l<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token keyword">return</span> slice<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后我们必须返回切片，因为虽然 Append 可以改变切片中的元素，但切片本身（运行时的数据结构，包括指针，长度和容量）是按值传递的。</p><p>向切片添加元素是一个常用操作，因此内建函数 append 实现了这一功能。为了理解这个函数的设计，我们需要掌握更多的信息，因此我们会在稍后讨论他。</p><h2 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h2><p>Go 中的数组和切片是一维的。为了等效的实现二维数组或二维切片，必须定义 数组的数组 或是 切片的切片，类似于：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Transform <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">float64</span>  <span class="token comment">// A 3x3 array, really an array of arrays.</span><span class="token keyword">type</span> LinesOfText <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>     <span class="token comment">// A slice of byte slices.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>因为切片的长度是可变的，因此每个内部切片的长度不同是可能的。这是一个很常见的情况，如果我们的 文本行 的例子：每一行都有独立的长度。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">text <span class="token operator">:=</span> LinesOfText<span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Now is the time"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"for all good gophers"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"to bring some fun to the party."</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>有时需要分配二维切片，例如在处理逐行像素扫描时。有两种方式可以实现这一目标。一种是为每个切片独立进行分配；另一种是分配一个独立的数组，然后将各个切片指向其中不同的区域。使用哪一种方式取决于您的应用程序。如果您的切片可能会增大或缩小，那应该独立分配切片，避免覆盖到下一行的内容；如果不是，单次分配一个数据来使用可能会更高效。作为参考，这里提供了两种方式的简单实现。第一种，每次一行的方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Allocate the top-level slice.</span>picture <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token punctuation">,</span> YSize<span class="token punctuation">)</span> <span class="token comment">// One row per unit of y.</span><span class="token comment">// Loop over the rows, allocating the slice for each row.</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> picture <span class="token punctuation">&#123;</span>    picture<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token punctuation">,</span> XSize<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在是单次分配，切为多行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Allocate the top-level slice, the same as before.</span>picture <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token punctuation">,</span> YSize<span class="token punctuation">)</span> <span class="token comment">// One row per unit of y.</span><span class="token comment">// Allocate one large slice to hold all the pixels.</span>pixels <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token punctuation">,</span> XSize<span class="token operator">*</span>YSize<span class="token punctuation">)</span> <span class="token comment">// Has type []uint8 even though picture is [][]uint8.</span><span class="token comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> picture <span class="token punctuation">&#123;</span>    picture<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pixels <span class="token operator">=</span> pixels<span class="token punctuation">[</span><span class="token punctuation">:</span>XSize<span class="token punctuation">]</span><span class="token punctuation">,</span> pixels<span class="token punctuation">[</span>XSize<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>Maps 是一种方便且强大的内建数据结构，他将一种类型的值（键）关联到另一种类型的值（值）。键可以是支持相等操作的任意数据类型，例如整数、浮点数、复数、字符串、指针、接口（只要其中的动态类型支持相等）、结构体或数组。切片不能用作 map 的键，因为没有为其定义相等操作。与切片类似，maps 持有了对下层数据结构的引用。如果你将 map 传入一个函数并且在函数中改变了 map 的内容，调用者也会看到这个改变。</p><p>Maps 可以使用常规的复合字面量语法，加上冒号分隔键值对来构建，因此在初始化期间构建他们很容易。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> timeZone <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span>    <span class="token string">"UTC"</span><span class="token punctuation">:</span>  <span class="token number">0</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span>    <span class="token string">"EST"</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span>    <span class="token string">"CST"</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span>    <span class="token string">"MST"</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">7</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span>    <span class="token string">"PST"</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对 map 分配值或获取值的语法看起来和对数组或切片的操作相同，只是索引不必须是整数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">offset <span class="token operator">:=</span> timeZone<span class="token punctuation">[</span><span class="token string">"EST"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>尝试获取 map 中不存在键映射的值会返回该类型的零值。例如，如果 map 包含整数，查询一个不存在的键会返回 0。可以使用 bool 作为值的 map 来实现 set。将每个键的值都设置为 true，之后可以通过索引来简单的判断该键是否存在。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">attended <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">&#123;</span>    <span class="token string">"Ann"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token string">"Joe"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> attended<span class="token punctuation">[</span>person<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token comment">// will be false if person is not in the map</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">"was at the meeting"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>有时您需要去区分缺失条目或是零值。究竟是是否有 UTC 的值，或者说 0 只是因为他并没有在 map 中设置？你可以使用多重赋值的方式分辨。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> seconds <span class="token builtin">int</span><span class="token keyword">var</span> ok <span class="token builtin">bool</span>seconds<span class="token punctuation">,</span> ok <span class="token operator">=</span> timeZone<span class="token punctuation">[</span>tz<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>出于一些显然的原因，这被称为 comma ok 用法。在下面的例子中，如果 tz 存在，seconds 将会被赋值而且 ok 的值为 true；如果 tz 不存在，seconds 的值将会是 0 而且 ok 的值会是 false。下面是一个将这些内容和一个错误日志组合到一起的函数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">offset</span><span class="token punctuation">(</span>tz <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> seconds<span class="token punctuation">,</span> ok <span class="token operator">:=</span> timeZone<span class="token punctuation">[</span>tz<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> seconds    <span class="token punctuation">&#125;</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"unknown time zone:"</span><span class="token punctuation">,</span> tz<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果不关心值的内容，只想测试键是否存在，您可以使用空标识符 (_) 代替值的变量。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token boolean">_</span><span class="token punctuation">,</span> present <span class="token operator">:=</span> timeZone<span class="token punctuation">[</span>tz<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>要删除 map 中的条目，可以使用内建的 delete 函数，他需求的参数是 map 和要被删除的键。即使要删除键已经不在 map 中，这个操作也是安全的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">delete</span><span class="token punctuation">(</span>timeZone<span class="token punctuation">,</span> <span class="token string">"PDT"</span><span class="token punctuation">)</span>  <span class="token comment">// Now on Standard Time</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>Go 中的格式化输出采用了和 C 中的 printf 系列相似但更加丰富和通用的实现。这些函数位于 fmt 包中且拥有大写的名称：fmt.Printf，fmt.Fprintf，fmt.Sprintf 等等。字符串系列函数（Sprintf等）返回一个字符串，而非填充某个指定的 buffer。</p><p>您不需要提供格式化字符串。对于每个 Printf，Fprintf 和 Sprintf 都存在另外两个与之对应的函数，例如 Print 和 Println。这些函数不接收格式化字符串，但为他们的每个参数提供默认格式。Println 会在两个参数间加入空格，而且在输出内容末尾添加换行符，Print 则是只有当两个连续的参数不是字符串时才添加空格。在这个例子中每一行都会提供同样的输出。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hello %d\n"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"Hello "</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>fmt.Fprint 系列的格式化输出函数接收任何实现了 io.Writer 接口的对象作为其第一个参数；os.Stdout 和 os.Stderr 是最常见的用法。</p><p>从现在开始事情变得和 C 不同。首先，%d 这样的数字格式不采用符号或大小标志；相反，打印例程使用参数的类型来决定这些属性。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">uint64</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">64</span> <span class="token operator">-</span> <span class="token number">1</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %x; %d %x\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">int64</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">int64</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">18446744073709551615 ffffffffffffffff; -1 -1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果您只想要默认转换，例如输出十进制整数，您可以使用万能格式 %v （含义是 “value”）；输出将会是 Print 和 Println 默认产生的结果。此外，这个格式可以用来打印任何值，甚至数组、切片、结构体和 maps。这里是打印上一章节定义的时区 map 的语句。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> timeZone<span class="token punctuation">)</span>  <span class="token comment">// or just fmt.Println(timeZone)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>输出是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>对于 maps，Printf 系列函数按字典顺序对输出进行排序。</p><p>在打印结构体时，使用 %+v 可以将字段值和名称共同输出，使用 %#v 则可以输出 Go 格式中全量的信息。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    a <span class="token builtin">int</span>    b <span class="token builtin">float64</span>    c <span class="token builtin">string</span><span class="token punctuation">&#125;</span>t <span class="token operator">:=</span> <span class="token operator">&amp;</span>T<span class="token punctuation">&#123;</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.35</span><span class="token punctuation">,</span> <span class="token string">"abc\tdef"</span> <span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> timeZone<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">&amp;&#123;7 -2.35 abc   def&#125;&amp;&#123;a:7 b:-2.35 c:abc     def&#125;&amp;main.T&#123;a:7, b:-2.35, c:"abc\tdef"&#125;map[string]int&#123;"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>（注意 &amp; 符号。）当输出 string 或 []byte 类型的值时，可以使用 %q 产生带引号的输出。如果可以的话，%#q 会使用反引号输出。（%q 也可以用于整数和 runes，输出一个单引号的 rune。）同样，%x 对 string、byte 数组、byte 切片和对整数有同样的效果，产生一个长十六进制字符串，如果在该格式中添加空格（% x），输出时会在字节间加入空格。</p><p>另一种方便的格式时 %T，他会输出值的类型。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> timeZone<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">map[string]int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果您想要控制自定义类型的默认输出格式，只需为该类型定义方法签名为 String() 的方法。对于一个简单的例子 T，看起来可能是这样。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d/%g/%q"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">,</span> t<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>打印出的内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">7/-2.35/"abc\tdef"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>(如果您需要打印 T 的类型和指向 T 的指针，String 函数的接收者必须是值类型；这个例子中使用指针是因为这样执行效率更高，也更复合结构体类型的习惯。查看后续章节<a href="#%E6%8C%87%E9%92%88%E6%88%96%E6%98%AF%E5%80%BC">指针或是值</a>了解更多信息。)</p><p>在我们的 String 方法中可以调用 Sprintf，因为打印例程是完全可重入的，而且可以通过这种方式包裹。然而，关于这种方法有一个非常重要的细节需要了解：不要使用会调用您的 String 方法的 Spintf 来构建您的 String 方法，这会导致您的 String 方法被无限调用。这种情况可能在您的 Sprintf 尝试直接将方法接收者直接作为 string 输出时发生，从而再次调用该方法。这是一个常见的但容易解决的问题，比如这个例子。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MyString <span class="token builtin">string</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m MyString<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"MyString=%s"</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token comment">// Error: will recur forever.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>修复起来也很简单：将参数转换为基本的 string 类型，转换后的参数不会调用这个方法。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MyString <span class="token builtin">string</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m MyString<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"MyString=%s"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// OK: note conversion.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>部分，我们将看到另一种避免这种递归的技术。</p><p>另一种打印技术是将打印例程的参数直接传递给另一个例程。Printf 的方法签名使用 …interface() 作为最后一个参数，用来指定任意数量（以及任意类型）的参数都可以出现在 format 之后。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Printf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> v <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在函数 Printf 中，v 的作用类似于类型为 []interface{} 的变量，但是如果将其传递到另一个可变参数的函数中，他则可以当作常规的参数列表使用。这里是我们之前用过的 log.Println 函数的实现。他直接将参数传递到 fmt.Sprintln 中，从而进行实际的格式化工作。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Println prints to the standard logger in the manner of fmt.Println.</span><span class="token keyword">func</span> <span class="token function">Println</span><span class="token punctuation">(</span>v <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    std<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintln</span><span class="token punctuation">(</span>v<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// Output takes parameters (int, string)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们在嵌套调用 Sprintln 时在参数 v 之后写上 …，用来告诉编辑器将 v 作为一个参数列表对待；否则他会将 v 作为一个切片类型的参数传递。</p><p>关于打印的内容比我们在这里介绍的还要多。有关详细信息，请参阅 fmt 包的 godoc 文档。</p><p>顺便提一句，…参数可以指定类型，例如使用 …int 实现的最小值函数，用来选取整数列表中的最小值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Min</span><span class="token punctuation">(</span>a <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    min <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token operator">^</span><span class="token function">uint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// largest int</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> min <span class="token punctuation">&#123;</span>            min <span class="token operator">=</span> i        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> min<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h2><p>现在我们需要解释之前缺失的碎片，关于内建函数 append 的设计。append 的方法签名和之前我们自定义的 Append 函数不同。示意一下的话，他看起来类似这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">append</span><span class="token punctuation">(</span>slice <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> elements <span class="token operator">...</span>T<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此处的 T 表示任何给定的类型。你不能在 Go 中编写一个由调用者决定 T 类型的函数。这也就是为何 append 作为内建函数的原因：他需要编译器的支持。</p><p>append 做的事情是将元素加入到切片的末尾并返回结果。需要返回结果的原因和我们之前手写的 Append 一样，底层的数组可能已经被改变。这里有个而简单的例子</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>输出 [1 2 3 4 5 6]。因此 append 的工作方式有点像 Printf，因为他可以接收任意数量和任意类型的参数。</p><p>但如果我们只想做和我们自定义 Append 一样的事情，把一个切片添加到另一个切片之后呢？简单：在调用时使用 …，就像我们在之前的 Output 调用时做的那样。这个片段会产生和上一个完全相同的输出。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>y <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span>x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果缺少了 …，这段代码会因为类型错误而无法编译，因为 y 的类型并不是 int。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>尽管从表面上看它与 C 或 C++ 中的初始化没有太大区别，但 Go 中的初始化更强大。可以在初始化期间构建复杂的结构，并且可以正确处理初始化对象之间（甚至不同包之间）的排序问题。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在 Go 中，常量的意思是——常量。他们是在编译时创建的，即使是在函数中被定义为局部变量也是如此，并且只能是数字、字符（rune）、字符串或是布尔值。由于编译时的限制，定义常量的表达式必须是常量表达式，可由编译器计算。例如，1&lt;&lt;3 是一个常量表达式，而 math.Sin(math.Pi&#x2F;4) 则不是，因为对函数 math.Sin 的调用需要在运行时发生。</p><p>在 Go 中，枚举常量是使用 iota 枚举器创建的。由于 iota 可以是表达式的一部分，并且表达式可以隐式重复，因此很容易构建复杂的值集。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ByteSize <span class="token builtin">float64</span><span class="token keyword">const</span> <span class="token punctuation">(</span>    <span class="token boolean">_</span>           <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// ignore first value by assigning to blank identifier</span>    KB ByteSize <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>    MB    GB    TB    PB    EB    ZB    YB<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>将类似 String 这样的方法附加到任何用户自定义类型的能力使得任何值都可以在打印时格式化输出自己。虽然最常见的用法是对结构体的应用，这种技术对于标量类型（例如浮点数表示的字节大小）也很有用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>b ByteSize<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> YB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fYB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>YB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> ZB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fZB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>ZB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> EB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fEB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>EB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> PB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fPB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>PB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> TB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fTB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>TB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> GB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fGB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>GB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> MB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fMB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>MB<span class="token punctuation">)</span>    <span class="token keyword">case</span> b <span class="token operator">>=</span> KB<span class="token punctuation">:</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fKB"</span><span class="token punctuation">,</span> b<span class="token operator">/</span>KB<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2fB"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>表达式 YB 会输出为 1.00YB，而 ByteSize(1e13) 则会输出为 9.09TB。</p><p>这里使用 Sprintf 来实现 ByteSize 类型的 String 方法是安全的（不会产生无限调用），并不是因为数据转换，而是因为他使用 %f 作为 Sprintf 的参数，这不是字符串格式的：Sprintf 只会在需要字符串值时调用 String 方法，而 %f 表示需要的是浮点数的值。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量可以像常量一样被初始化，但是其初始化表达式可以在运行时计算。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    home   <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"HOME"</span><span class="token punctuation">)</span>    user   <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span>    gopath <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"GOPATH"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h2><p>最后，每个源文件都可以定义自己的 无参数（niladic） init 函数，用来设置任何他们所需的状态。（实际上每个文件可以有多个 init 函数。）最后的最后：init 会在包中声明的所有变量完成初始化计算后执行，而这些变量的初始化计算则会在所有引入的包已经完成初始化后执行。</p><p>除了执行不能用声明表示的初始化动作外，init 函数的一个常见用途是在程序开始前确认或修复程序状态的正确性。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> user <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"$USER not set"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> home <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>        home <span class="token operator">=</span> <span class="token string">"/home/"</span> <span class="token operator">+</span> user    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> gopath <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>        gopath <span class="token operator">=</span> home <span class="token operator">+</span> <span class="token string">"/go"</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// gopath may be overridden by --gopath flag on command line.</span>    flag<span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gopath<span class="token punctuation">,</span> <span class="token string">"gopath"</span><span class="token punctuation">,</span> gopath<span class="token punctuation">,</span> <span class="token string">"override default GOPATH"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="指针或是值"><a href="#指针或是值" class="headerlink" title="指针或是值"></a>指针或是值</h2><p>如同我们之前在 Bytesize 中看到的，方法可以为任何命名类型定义（除了指针或接口）；方法的接收者不必是一个结构体。</p><p>在之前我们对切片的讨论中，我们写了 Append 函数。我们可以将他替换为切片的方法。为了实现这个目标，首先我们声明一个命名的类型，这样我们可以将方法绑定在上面，之后我们将该类型的值作为方法的接收者。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ByteSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">func</span> <span class="token punctuation">(</span>slice ByteSlice<span class="token punctuation">)</span> <span class="token function">Append</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Body exactly the same as the Append function defined above.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个方法仍然需要配返回更新后的切片。我们可以通过重新定义方法，采用 ByteSlice 的指针作为接收者，来消除这种不便，调用这个方法会覆盖调用者的切片。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>ByteSlice<span class="token punctuation">)</span> <span class="token function">Append</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    slice <span class="token operator">:=</span> <span class="token operator">*</span>p    <span class="token comment">// Body as above, without the return.</span>    <span class="token operator">*</span>p <span class="token operator">=</span> slice<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>实际上，我们甚至可以做的更好。如果我们修改我们的函数，让他看起来像标准的 Write 方法，比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>ByteSlice<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    slice <span class="token operator">:=</span> <span class="token operator">*</span>p    <span class="token comment">// Again as above.</span>    <span class="token operator">*</span>p <span class="token operator">=</span> slice    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>之后，*ByteSlice 类型满足了基础的 io.Writer 接口，这样就很方便。例如，我们可以使用 print 写入。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> b ByteSlicefmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token string">"This hour has %d days\n"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>我们传递 ByteSlice 的地址是因为只有 *ByteSlice 类型满足了 io.Wirter 的接口条件。使用指针或是值作为接收者的规则是这样的，值的方法可以被指针或是值调用，而指针的方法只能被指针调用。</p><p>这条规则的出现是因为指针的方法可以修改其接收者，在值上调用这种方法会导致方法接收到值的复制，因此任何修改都会失效。因此，该语言不允许出现这种错误。不过，有一个方便的例外。当值本身可寻址时，Go 通过在值前自动插入 &amp; 照顾了使用值调用指针方法的情况。在我们的例子中，变量 b 是可寻址的，因此我们可以使用 b.Write 调用他的 Write 方法。编译器会帮助我们自动重写为 (&amp;b).Write。</p><p>顺带一提，通过 Write 像字节切片写入数据的想法是 bytes.Buffer 包实现的核心。</p><h1 id="接口和其他类型"><a href="#接口和其他类型" class="headerlink" title="接口和其他类型"></a>接口和其他类型</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Go 中的接口提供了一个指定对象行为的方法：如果他可以实现这个功能，那么他就可以在这里使用。我们之前已经看到了几个简单的例子；自定义打印可以通过 String 方法实现，而 Fprintf 可以向任何实现了 Write 方法的对象输出内容。Go 中的接口往往只定义了一到两个方法，而且通常会根据方法指定一个名称，例如 io.Writer 表示任何 Write 接口实现。</p><p>一个类型可以实现多个接口。例如，如果一个集合实现了 sort.Interface（其中包含了 Len，Less(i, j int) bool，Swap(i, j int)），那么他就可以被 sort 包中的例程排序，同时他也可以有一个自定义的格式化器。在下面这个定制的例子中，Sequence 同时满足了这两个条件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Sequence <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment">// Methods required by sort.Interface.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token comment">// Copy returns a copy of the Sequence.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Sequence <span class="token punctuation">&#123;</span>    <span class="token builtin">copy</span> <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>Sequence<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token builtin">copy</span><span class="token punctuation">,</span> s<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Method for printing - sorts the elements before printing.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Make a copy; don't overwrite argument.</span>    sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    str <span class="token operator">:=</span> <span class="token string">"["</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> elem <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span> <span class="token comment">// Loop is O(N²); will fix that in next example.</span>        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            str <span class="token operator">+=</span> <span class="token string">" "</span>        <span class="token punctuation">&#125;</span>        str <span class="token operator">+=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> str <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>Sequence 类型的 String 方法重复了 Sprint 输出切片的工作。（而且复杂度为 O(N²)，这很糟糕）。如果我们在调用 Sprint 之前将他转换为普通的 []int，那么我们的工作量会减少，运行速度也会提升。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个方法是另一个通过转换技术在 String 方法中安全调用 Sprintf 的例子。因为这两种类型（Sequence 和 []int）在忽略名称的情况下实际上是相同的，因此这种转换是合法的。这种转换不会创建新的值，他只是暂时的将值作为一个新的类型来使用。（还有一种合法的转换，例如将整数转换为浮点数，过程中会创建新的值。）</p><p>通过转换类型来使用不同的方法是一种 Go 程序中的常见用法。作为示例，我们可以使用 sort.IntSlice 将上文中的例子改变为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Sequence <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment">// Method for printing - sorts the elements before printing</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Sequence<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    sort<span class="token punctuation">.</span><span class="token function">IntSlice</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，不再是让 Sequence 实现多个接口（sorting 和 printing），我们通过使用将数据转换为多种类型的能力（Sequence，sort.IntSlice 和 []int），每种类型可以解决一部分工作。这种方式在实践中并不常用，但是可能会很有效。</p><h2 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h2><p><a href="#Type-switch">Type switch</a> 是一种类型转换的形式：获取一个接口，对于 switch 中的每个 case，将接口“转换”为 case 对应的类型。这里是一个 fmt.Printf 如何通过类型转换将值转换为字符串的示例。如果值早已是 string，我们获取该接口持有的 string 本身的值，当值有 String 方法是，我们获取该方法的输出。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Stringer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> value <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Value provided by caller.</span><span class="token keyword">switch</span> str <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> str<span class="token keyword">case</span> Stringer<span class="token punctuation">:</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>第一个 case 匹配一个具体的类型；第二个 case 将接口转换成另一个接口。这样混合不同种类的使用是完全可行的。</p><p>当只有一种我们关心的类型时呢？如果我们提前知道值是 string 类型，而且我们只想将他提取出来呢？使用只有一个 case 的 type switch 是可以的，但 <em>类型断言</em> 也可以。类型断言使用一个接口值，从中提取出一个类型明确的值。该语法借鉴了 type switch，但是使用明确的类型而非 type 关键字：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">value<span class="token punctuation">.</span><span class="token punctuation">(</span>typeName<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>获得的结果就是一个符合指定的 typeName 类型的值。新的类型要么是接口持有的具体类型，要么是值可以转换的另一个接口类型。为了提炼我们已经知道的类型为 string 的值，我们可以：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">str <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>但是如果实际上值并非 string，程序会产生一个运行时错误并崩溃。为了防止这种情况，可以使用 “comma, ok” 方式来测试，判断值到底是否属于 string 类型：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">str<span class="token punctuation">,</span> ok <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">if</span> ok <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"string value is: %q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"value is not a string\n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果类型断言失败，str 依然会是 string 类型的变量，但是他的值为零值，也就是一个空字符串。</p><p>作为补充说明，这里是一个使用类型断言和 if-else 实现的语句，达到了和本章开始时 type switch 相同的效果。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> str<span class="token punctuation">,</span> ok <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> str<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> str<span class="token punctuation">,</span> ok <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token punctuation">(</span>Stringer<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>如果一个类型的存在仅仅是为了实现某个接口，而且不会导出除了接口方法外的任何方法，那么这个类型本身也无需被导出。仅导出接口清晰的表明了该值没有超出接口范围的行为能力。这也避免了在常见方法的各个实例上重复编写文档的必要。</p><p>在这种情况下，构造器应该返回接口类型的值而非实际实现类型的值。例如：在 hash 库中，crc32.NewIEEE 和 adler32.New 都返回了 hash.Hash32 接口的值。在 Go 中用 CRC-32 算法替换 Adler-32 只需要改变构造器中的调用；代码的其他部分都不会受到算法改变的影响。</p><p>类似的方法允许将各种加密包中的流式密码算法与他们相关的块状加密分开。crypto&#x2F;cipher 包中的 Block 接口指定了块状加密的行为，它提供单个数据块的加密。然后，与 bufio 包类比，实现该接口的 cipher 包可用于构造由 Stream 接口表示的流式加密，而无需知道块状加密的细节。</p><p>crypto&#x2F;cipher 中的接口看起来是这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Block <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">BlockSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>    <span class="token function">Encrypt</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span>    <span class="token function">Decrypt</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> Stream <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">XORKeyStream</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是 counter mode (CTR) 流的定义，他将块状加密转换为流式加密；请注意，关于块状加密的细节已经全部被抽象处理：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// NewCTR returns a Stream that encrypts/decrypts using the given Block in</span><span class="token comment">// counter mode. The length of iv must be the same as the Block's block size.</span><span class="token keyword">func</span> <span class="token function">NewCTR</span><span class="token punctuation">(</span>block Block<span class="token punctuation">,</span> iv <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> Stream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>NewCTR 不止是适用于某一种指定的加密算法或是数据源，而是可以适配任何 Block 接口的实现和任何数据流。因为他们返回的是接口类型的值，更换 CRT 加密模式是完全本地化的更改。构造器的调用必须修改，但是由于其他的代码仅仅将结果作为 Stream 看待，他们则不会受到影响。</p><h2 id="接口与方法"><a href="#接口与方法" class="headerlink" title="接口与方法"></a>接口与方法</h2><p>由于几乎所有类型都可以绑定方法，因此所有类型也都可以用来成为接口实现。http 包就是一个很好的例子，其中定义了 Handler 接口。所有实现了 Handler 接口的对象都可以用来处理 HTTP 请求。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>ResponseWriter 自身就是一个接口，提供了需要向客户端返回响应的方法的入口。这些方法包括了基础的 Write 方法，因此 http.ResponseWriter 可以用在任何 io.Writer 可用的地方。Request 是一个包含了已经解析好的客户端请求的结构体。</p><p>简单起见，让我们忽略 POSTs，假装 HTTP 请求总是 GETs；这种简化不会影响到 handlers 的代码逻辑。这里有一个 handler 实现的小例子，可以用来统计页面被访问的次数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Simple counter server.</span><span class="token keyword">type</span> Counter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    n <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>ctr <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ctr<span class="token punctuation">.</span>n<span class="token operator">++</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> ctr<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>（继续我们的主题，请注意 Fprintf 是如何向 http.ResponseWriter 输出内容的。）在实际的服务器中，对 ctr.n 的访问需要进行并发保护。参考 sync 和 atomic 包来获取建议。</p><p>作为引用，这里是如何将这样一个服务添加到 URL 树上。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"net/http"</span><span class="token operator">...</span>ctr <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Counter<span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/counter"</span><span class="token punctuation">,</span> ctr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但是为什么我们需要将 Counter 定义为结构体呢？使用整数就足够满足所有的需求了。（方法的接收者需要设置为指针，这样数字的增长才对调用者可见。）</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Simpler counter server.</span><span class="token keyword">type</span> Counter <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span>ctr <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>ctr<span class="token operator">++</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"counter = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ctr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果您的程序有一些内部状态想要得知页面已经被访问的话？可以将 channel 绑定到服务中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A channel that sends a notification on each visit.</span><span class="token comment">// (Probably want the channel to be buffered.)</span><span class="token keyword">type</span> Chan <span class="token keyword">chan</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token keyword">func</span> <span class="token punctuation">(</span>ch Chan<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ch <span class="token operator">&lt;-</span> req    fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"notification sent"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后，假设我们想要在 &#x2F;arg 上显示服务器启动时使用的参数。编写一个打印参数的函数很简单。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ArgServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>如何将其变为 HTTP 服务呢？我们可以将将 ArgServer 设置成某些我们不关注的类型的方法，但是有一个更清晰的实现方式。由于我们可以为除了指针和接口外的所有类型定义方法，我们也可以为函数定义方法。http 包中包含了这样的定义：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// The HandlerFunc type is an adapter to allow the use of</span><span class="token comment">// ordinary functions as HTTP handlers.  If f is a function</span><span class="token comment">// with the appropriate signature, HandlerFunc(f) is a</span><span class="token comment">// Handler object that calls f.</span><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token comment">// ServeHTTP calls f(w, req).</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>HandlerFunc 是一个有 ServerHTTP 方法的类型，因此该类型的数据实现了 Handler 接口，可以处理 HTTP 请求。观察这个方法的实现：接收者是一个函数 f，而方法调用了 f。这可能看起来有点奇怪，但是本质上和用 channel 作为接收者然后在方法中向 channel 发送数据没什么区别。</p><p>为了将 ArgServer 变成 HTTP 服务，首先我们改变他的方法签名。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Argument server.</span><span class="token keyword">func</span> <span class="token function">ArgServer</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>ArgServer 现在有了和 HanderFunc 相同的方法签名，所以他可以被类型转换为 HanderFunc 从而使用 HanderFunc 的方法，就像我们将 Sequence 转换为 IntSlice 从而使用 IntSlice.Sort 一样。设置的代码很简单：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/args"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span>ArgServer<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>当有人访问页面 &#x2F;args 时，此处的处理器是 HandlerFunc 类型的 ArgServer。HTTP 服务器会调用处理器的 ServeHTTP 方法，而 ArgServer 作为接收者，实际上会调用 ArgServer（通过 HandlerFunc.ServeHTTP 中的 f(w,rea)）。相关的参数结果也会随之返回。</p><p>在这一章节中我们使用多种方式实现 HTTP 服务，包括结构体、整数、channel 和 函数，这一切都是因为接口只是方法的集合，几乎所有类型都可以成为接口的实现。</p><h1 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h1><p>在之前的 <a href="#For">for range 循环</a> 和 <a href="#Maps">maps</a> 的内容中，我们已经几次提到了关于空标识符的内容。空标识符可以被声明为任何类型的任何数据，之后该数据则会被无害的丢弃。这有点像在 Unix 中向 &#x2F;dev&#x2F;null 文件写入内容：他提供了一个需要变量占位符但是实际值又无关紧要的场景下的只写的值。他的用途比我们之前见到的还要更加广泛。</p><h2 id="多重赋值中的空标识符"><a href="#多重赋值中的空标识符" class="headerlink" title="多重赋值中的空标识符"></a>多重赋值中的空标识符</h2><p>在 for range 循环中使用空标识符其实是某种通用解决方案的特例：在多重赋值中使用空标识符。</p><p>如果在赋值语句的左侧需要多个变量，但是其中的某个变量实际上又不会被系统使用，那么使用空标识符就可以避免我们去创建一个无效的变量，也可以清晰的表明此处变量的值会被丢弃。例如，当调用的函数可以同时提供返回值和错误值，但我们仅需要错误值时，可以使用空标识符丢弃无关紧要的返回值。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> os<span class="token punctuation">.</span><span class="token function">IsNotExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s does not exist\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>偶尔你会看到有代码通过丢弃错误的方式来忽略对他们的处理；这是一种很糟糕的实践。请确保总是检查错误的值，提供错误返回是有原因的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Bad! This code will crash if path does not exist.</span>fi<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token keyword">if</span> fi<span class="token punctuation">.</span><span class="token function">IsDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s is a directory\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="未使用的引入和变量"><a href="#未使用的引入和变量" class="headerlink" title="未使用的引入和变量"></a>未使用的引入和变量</h2><p>引入一个包或声明一个变量后不去使用是一种错误。未使用的引入会导致程序膨胀，编译速度变慢，当一个变量被初始化但没有使用时，至少他会造成计算性能的浪费，而且可能会表示某处存在更大的 bug。当一个程序处在活跃的开发阶段时，未使用的引入和变量会经常出现，如果只是为了继续编译而删除他们，而之后又需要重新引入或声明，这很让人懊恼。空标识符提供了对这个问题的解决方案。</p><p>这个半成品程序包括两个未使用的引入（fmt 和 io）和一个未使用的变量（fd），因此他无法被编译，但是假设我们想要查看至今为止的代码是否正确。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"io"</span>    <span class="token string">"log"</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"test.go"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// TODO: use fd.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>为了消除未使用引入的报错，可以使用空标识符从引入的包中引用一个变量。类似的，将 fd 赋值给空标识符会消除未使用变量的错误。这个版本的程序就可以编译了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"io"</span>    <span class="token string">"log"</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> fmt<span class="token punctuation">.</span>Printf <span class="token comment">// For debugging; delete when done.</span><span class="token keyword">var</span> <span class="token boolean">_</span> io<span class="token punctuation">.</span>Reader    <span class="token comment">// For debugging; delete when done.</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"test.go"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// TODO: use fd.</span>    <span class="token boolean">_</span> <span class="token operator">=</span> fd<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>方便起见，为了消除引入错误而进行的全局声明应该集中在 imports 代码块后并且被注解，这样既可以方便的找到他们，又可以提醒我们之后将他们清理掉。</p><h2 id="为了潜在作用而引入"><a href="#为了潜在作用而引入" class="headerlink" title="为了潜在作用而引入"></a>为了潜在作用而引入</h2><p>前文中提到的未使用的引入例如 fmt 或 io 最终会被使用或被移除：空赋值表示了代码仍在开发过程中。但有时，不去显式的使用一个包，而仅仅是为了他的潜在作用而引入他也是有效的。例如，<a href="https://go.dev/pkg/net/http/pprof/">net&#x2F;http&#x2F;pprof</a> 包在他的 init 函数中注册了提供 debug 信息的 HTTP 接口。他有一个导出 API，但是大多数客户端只需要初始化 HTTP 处理然后通过 web 页面访问数据。为了只利用包的潜在作用而引入包，可以将包名重命名为空标识符：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这种引入形式清楚的表明了这个包是为了他的潜在作用而引入，因为我们已经没有别的使用这种包的可能性：在这个文件里，他甚至连名称都没有。（如果他有名称，而且我们未使用的话，编译器会拒绝这段源码。）</p><h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>就像我们之前在讨论<a href="#%E6%8E%A5%E5%8F%A3">接口</a>时看到的，一个类型无需显示的声明他实现了某种接口。反之，一个类型只需要实现了该接口需要的方法，则他就默认实现了这个接口。在实践中，大部分的接口转换是静态的，因此他们会在编译时被检查。例如，在一个需要 io.Reader 参数的函数中传入 *os.File 不会被编译，除非 *os.File 实现了 io.Reader 接口。</p><p>尽管如此，有些接口检查确实是在运行时发生的。一个例子是 <a href="https://go.dev/pkg/encoding/json/">encoding&#x2F;json</a> 包，其中定义了 <a href="https://go.dev/pkg/encoding/json/#Marshaler">Marshaler</a> 接口。当 JSON 编码器接收到实现了该接口的值时，编码器使用该值的编码方法将其转换为 JSON，否则使用基础方法转换。编码器在运行时使用<a href="#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">类型断言</a>检查此属性：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">m<span class="token punctuation">,</span> ok <span class="token operator">:=</span> val<span class="token punctuation">.</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>Marshaler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果仅仅只需要了解类型是否实现了某个接口，但并不使用接口值自身，也许就是作为错误检查的一部分，可以使用空标识符来忽略类型断言的值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> val<span class="token punctuation">.</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>Marshaler<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"value %v of type %T implements json.Marshaler\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>这个情况出现的一个地方是在实现类型的包中需要保证它实际上满足了接口。如果一个类型——例如，<a href="https://go.dev/pkg/encoding/json/#RawMessage">json.RawMessage</a>——需要一个定制化的 JSON 表示，那么他应该实现 json.Marshaler 接口，但是这里没有静态类型转换使得编译器去自动检查这一点。如果这个类型的不经意间的改动无法满足了接口要求，JSON 编码器仍然会工作，但是不再使用定制化的实现方式。为了确保可以采用正确的实现，可以在这个包中进行一个全局的使用空标识符的声明：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token boolean">_</span> json<span class="token punctuation">.</span>Marshaler <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>RawMessage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在这个声明中，赋值语句调用了一个从 *RawMessage 到 Marshaler 的类型转换，这需要 *RawMassage 实现 Marshaler 接口，且这个属性会在编译时被检查。如果 json.Marshaler 接口发生变化，这个包将不再编译，我们会注意到这一点，意识到这个包需要被更新。</p><p>这里的空标识符表示这个声明的存在仅仅是为了做类型检查，而非创建一个变量。尽管如此，不要对每个实现接口的类型做这种检查。为了方便起见，这种声明只在代码中没有静态转换的使用使用，这其实是一种很罕见的情况。</p><h1 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h1><p>Go 没有提供传统的、类型驱动的子类概念，但他拥有通过 <em>嵌入类型</em> 来借用结构体或接口部分实现的能力。</p><p>接口嵌入十分简单，我们之前已经提过 io.Reader 和 io.Writer 接口；这里是他们的定义。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>io 包还提供了其他几个接口，用来指定对象需要满足这些方法。例如，io.ReadWriter 是一个同时包括了读写的接口。我们可以通过显示的列举这两个方法的方式来指定 io.ReadWriter 接口，但是更简单且优雅的方式是直接将原先的两个接口嵌入其中，就像这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    Reader    Writer<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>他的作用不言自明：ReadWriter 等同于 Reader 加上 Writer；他的能力由被嵌入接口组合而成。只有接口可以被接口嵌入。</p><p>这个想法同样适用于结构体，但是实现的更加深入。bufio 包有两个结构体类型，bufio.Reader 和 bufio.Writer，他们当然各自实现了 io 包中的接口。同时，bufio 包也实现了一个基于 buffer 的读写结构体，他通过嵌入的方式将 reader 和 writer 结合到一起：他包括了结构体内部的类型，但没有给他们字段名。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ReadWriter stores pointers to a Reader and a Writer.</span><span class="token comment">// It implements io.ReadWriter.</span><span class="token keyword">type</span> ReadWriter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>Reader  <span class="token comment">// *bufio.Reader</span>    <span class="token operator">*</span>Writer  <span class="token comment">// *bufio.Writer</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>被嵌入的元素是已经正确初始化的结构体的指针。ReadWriter 结构体可以被写为</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadWriter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    reader <span class="token operator">*</span>Reader    writer <span class="token operator">*</span>Writer<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但随后为了暴露字段的方法，且需要满足接口的需求，我们还需要提供对方法的转发，就像这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>ReadWriter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> rw<span class="token punctuation">.</span>reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>通过直接嵌入结构体，我们可以避免这样的抄书工作。被嵌入类型的方法可以直接调用，这意味着 bufio.ReadWriter 不仅有 bufio.Reader 和 bufio.Writer 的方法，他其实同时满足了三个接口：io.Reader，io.Writer，io.ReadWriter。</p><p>嵌入和子类有一个很重要的区别。当我们嵌入一个类型时，该类型的方法会变成外层的方法，但是当方法被调用时，方法的接收者是内部类型，而非外部类型。在我们的例子中，当 bufio.ReadWriter 中的 Read 方法被调用时，他实际上的效果和我们将这个方法转发到外层相同；方法的接收者是 ReadWriter 中的 reader 字段，而非 ReadWriter 自身。</p><p>嵌入式也带来一些简单的小技巧。这个例子里我们同时使用了一个嵌入式字段和一个常规的命名字段。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Job <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Command <span class="token builtin">string</span>    <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在 Job 类型就拥有了 Print， Printf， Println 和其他 *log.Logger 带来的方法。我们当然可以选择给 Logger 提供一个字段名，但这没有必要。现在，当初始化完成后，我们可以这样输出 Job：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">job<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"starting now..."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Logger 也是 Job 结构体中的一个字段，因此我们可以采用普通的方式在 Job 的构造函数中初始化他，例如这样，</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewJob</span><span class="token punctuation">(</span>command <span class="token builtin">string</span><span class="token punctuation">,</span> logger <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger<span class="token punctuation">)</span> <span class="token operator">*</span>Job <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>Job<span class="token punctuation">&#123;</span>command<span class="token punctuation">,</span> logger<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>或者采用复合字面量，</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">job <span class="token operator">:=</span> <span class="token operator">&amp;</span>Job<span class="token punctuation">&#123;</span>command<span class="token punctuation">,</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"Job: "</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>Ldate<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果我们需要直接引用被嵌入的字段，可以将他的类型名称（忽略包名）直接视作字段名称，就像我们在 ReadWriter 结构体中的 Read 方法中做的那样。在这里，如果我们需要访问 Job 类变量 job 中的 *log.Logger，我们可以使用 job.Logger，这对于如果我们想要重写 Logger 中的方法时很有用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>job <span class="token operator">*</span>Job<span class="token punctuation">)</span> <span class="token function">Printf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    job<span class="token punctuation">.</span>Logger<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q: %s"</span><span class="token punctuation">,</span> job<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>嵌入类型引入了名称冲突的问题，但解决他们的规则很简单。首先，一个名为 X 的字段或方法会将其他更深层的的名为 X 的部分隐藏。如果 log.Logger 包含一个名为 Command 的字段或方法，那么 Job 中的 Command 方法会屏蔽他。</p><p>其次，如果相同层级中出现了相同的名称，那通常会是一个错误；如果 Job 结构体包含另一个名为 Logger 的字段或方法，则嵌入 log.Logger 是错误的。然而，如果在类型定义外的任何地方，程序都没有使用这个重复的名称，那么是没有问题的。这种限定可以防止外部嵌入的类型发生更改时带来的一些问题；如果从未使用过某个字段，即使它与另一个子类型中的字段冲突也无关紧要。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="通过通信共享"><a href="#通过通信共享" class="headerlink" title="通过通信共享"></a>通过通信共享</h2><p>并发编程是一个庞大的主题，这里仅仅介绍一些 Go 相关的重点内容。</p><p>由于实现对共享变量的访问有很多微妙的细节，这导致了在很多环境中并发编程十分困难。Go 鼓励采用另一种方法，即通过通信传递共享的值，而非使用多个分离的线程来访问他。在任何时候只会有一个 goroutine 在使用这个值。通过这种设计方式，根本不会产生数据竞态问题。为了鼓励这种思维方式我们把他提炼成了一句简单的口号：</p><blockquote><p>不要通过共享内存来通信，而是通过通信来共享内存。</p></blockquote><p>这种设计可能会矫枉过正。例如，对于一个引用计数器，最好的方法就是在整数上加一个 mutex。但是作为一种高级方法，使用管道来控制接入还是会让编写清晰、正确的程序更加简单。</p><p>一种理解这个模型的方法是，考虑一个在 CPU 上运行的典型的单线程程序。他不需要任何的同步关键字。现在运行该程序的另一个实例，他也不需要任何同步关键字。现在让他们之间进行通信，如果通信过程是同步的，那么就仍然不需要任何同步关键字。Unix 中的管道就是这个模型的完美实例。尽管 Go 的并发方法起源于 Hoare 的 通信顺序进程（CSP），但他也可以被看作一种类型安全的 Unix 管道。</p><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p><em>goroutines</em> 被这样命名是因为所有现有的术语：线程、协程、进程等等，都无法准确表达他的内涵。goroutine 有一个简单的模型：他是一个与其他 goroutines 在同一地址空间并发执行的函数。他非常的轻量级，开销仅仅略多于堆栈空间分配。开始时仅使用一个小堆栈，因此开销很低，随后在使用时按序分配（或释放）堆存储。</p><p>Goroutines 在操作系统的多个线程上多路复用，如果其中一个发生堵塞，例如在等待 I&#x2F;O，其他的 goroutines 可以继续运行。这种设计隐藏了很多线程创建和管理上的复杂性。</p><p>在函数或方法调用前添加 go 关键字会让这次调用运行在一个新建的 goroutine 中。当调用完成后，goroutine 静默的退出。（效果类似于在 Unix shell 中使用 &amp; 在后台运行命令。）</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span> list<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// run list.Sort concurrently; don't wait for it.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>匿名函数可以方便的通过 goroutine 调用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Announce</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">,</span> delay time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Note the parentheses - must call the function.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在 Go 中，匿名函数是闭包：实现确保了函数引用的变量的生命周期至少和函数一致。</p><p>这些例子都不是很典型，因为函数无法发出完成信号。对此，我们需要 channels。</p><h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>类似于 maps，channels 同样使用 make 进行分配，获得的值同样引用了一个底层的数据结构。分配 channels 的 make 提供了一个可选的整数参数，用于设定 channel 的缓冲大小。默认值是 0，表示一个无缓冲的同步通道。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">ci <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>            <span class="token comment">// unbuffered channel of integers</span>cj <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment">// unbuffered channel of integers</span>cs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment">// buffered channel of pointers to Files</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>无缓冲的 channels 结合了通信（值的交换）与同步（保证两个计算(goroutines)）处在一个已知的状态。</p><p>关于通道的使用有很多好的惯例，我们从下面这个开始。在这段代码中我们在后台启动了数组排序。而 channel 允许启动者的 goroutine 等待排序完成。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token comment">// Allocate a channel.</span><span class="token comment">// Start the sort in a goroutine; when it completes, signal on the channel.</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    list<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    c <span class="token operator">&lt;-</span> <span class="token number">1</span>  <span class="token comment">// Send a signal; value does not matter.</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">doSomethingForAWhile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;-</span>c   <span class="token comment">// Wait for sort to finish; discard sent value.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接收者会在收到数据之前一直阻塞。如果 channel 是无缓冲的，发送者也会在接收者接受数据前一直堵塞。如果通道是有缓冲的，发送者只会在向缓冲区满的通道再次发送数据的时候堵塞，这意味着需要等待一些接收者来领取数据。</p><p>有缓冲的 channel 可以像信号量一样使用，例如用来进行吞吐量的限制。在这个例子中，输入的请求被传递到 handle，而他将一个值放入 channel、处理请求、最后从 channel 中接收一个值，为下一个使用者准备好“信号量”。channel 缓冲器的容量限制了 process 函数的并发数量。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> sem <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> MaxOutstanding<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">handle</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sem <span class="token operator">&lt;-</span> <span class="token number">1</span>    <span class="token comment">// Wait for active queue to drain.</span>    <span class="token function">process</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>  <span class="token comment">// May take a long time.</span>    <span class="token operator">&lt;-</span>sem       <span class="token comment">// Done; enable next request to run.</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>queue <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        req <span class="token operator">:=</span> <span class="token operator">&lt;-</span>queue        <span class="token keyword">go</span> <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>  <span class="token comment">// Don't wait for handle to finish.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>一旦有 MaxOutstanding 数量的 handlers 同时在处理，更多的请求会由于尝试向满载的缓冲 channel 写入数据而被堵塞，直到其中某个现存的 handlers 完成计算并且从缓冲 channel 中接收数据。</p><p>不过，这样的设计仍然存在一个问题：Serve 对每一个进入的请求创建新的 goroutine，即便在任何时候只有 MaxOutstanding 个请求可以运行。这样带来的结果是，当请求到来的过快时，该程序可能会消耗大量的资源。我们可以将 goroutines 的创建移入 Serve 来解决这个问题。这里有一个很明显的解决方案，但是小心，现在这里有一个 bug，我们随后会修复：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>queue <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> req <span class="token operator">:=</span> <span class="token keyword">range</span> queue <span class="token punctuation">&#123;</span>        sem <span class="token operator">&lt;-</span> <span class="token number">1</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">process</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token comment">// Buggy; see explanation below.</span>            <span class="token operator">&lt;-</span>sem        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里的 bug 是，在 Go 循环中，循环变量是在每次迭代时共享的，因此 req 变量是在所有 goroutines 中共享的，这并不符合我们的预期，我们希望每个 goroutine 中的 req 是独立的。这里有一个解决方式，将 req 的值作为参数传递给 goroutines 的闭包：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>queue <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> req <span class="token operator">:=</span> <span class="token keyword">range</span> queue <span class="token punctuation">&#123;</span>        sem <span class="token operator">&lt;-</span> <span class="token number">1</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">process</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>            <span class="token operator">&lt;-</span>sem        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对比这个版本和上一个版本的代码，可以观察闭包声明和运行中的区别。另一个解决方案是创建一个同名变量，比如在这个例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>queue <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> req <span class="token operator">:=</span> <span class="token keyword">range</span> queue <span class="token punctuation">&#123;</span>        req <span class="token operator">:=</span> req <span class="token comment">// Create new instance of req for the goroutine.</span>        sem <span class="token operator">&lt;-</span> <span class="token number">1</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">process</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>            <span class="token operator">&lt;-</span>sem        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这个写法也许看起来很怪</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">req <span class="token operator">:=</span> req<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>但这是合法的，而且很符合 Go 中的习惯。这会产生一个同名的新变量，有意的在循环体中隐藏了循环变量，确保了每个 goroutine 中变量的唯一性。</p><p>回到编写这个服务器的问题，另一个可以良好管理资源的解决方案是启动固定数量的 goroutines 并使他们都去读取 request channel。goroutines 的数量限制了 process 并发调用的数量。Serve 函数同时也接受一个通知其退出的 channel，在启动 goroutines 之后他阻塞直到从该通道接收到内容。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">handle</span><span class="token punctuation">(</span>queue <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> queue <span class="token punctuation">&#123;</span>        <span class="token function">process</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>clientRequests <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">,</span> quit <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Start handlers</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MaxOutstanding<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">go</span> <span class="token function">handle</span><span class="token punctuation">(</span>clientRequests<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">&lt;-</span>quit  <span class="token comment">// Wait to be told to exit.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Channels-of-channels"><a href="#Channels-of-channels" class="headerlink" title="Channels of channels"></a>Channels of channels</h2><p>Go 中最重要的特性之一就是 channel 是 Go 中的一等公民，他可以像其他值一样被分配和传递。这个属性的常见用途之一是用来实现安全、并行的解复用。</p><p>在上一章节的例子中，handle 是一个想象中用来处理请求的模型，但是我们没有定义他所处理的具体类型。如果该类型包含接收回复的通道，那么每个客户端都可以独立定义他们接收计算结果的路径。这里是一个对 Request 类型定义的示意。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    args        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    f           <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>    resultChan  <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>客户端提供了计算函数，计算参数，以及在其内部的用来接收结果的 channel。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> v    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">&#125;</span>request <span class="token operator">:=</span> <span class="token operator">&amp;</span>Request<span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Send request</span>clientRequests <span class="token operator">&lt;-</span> request<span class="token comment">// Wait for response.</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"answer: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&lt;-</span>request<span class="token punctuation">.</span>resultChan<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>而在服务端一侧，唯一的改变就是 handler 函数的内容。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">handle</span><span class="token punctuation">(</span>queue <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> req <span class="token operator">:=</span> <span class="token keyword">range</span> queue <span class="token punctuation">&#123;</span>        req<span class="token punctuation">.</span>resultChan <span class="token operator">&lt;-</span> req<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>args<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>显然还需要很多代码工作才能让这个例子成为真正的实现，但是这些代码可以视作一个有限速的、并发的、非阻塞的 RPC 系统的框架，而且看不到任何一个 mutex。</p><h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>关于这些想法的另一个应用是在多个 CPU 核心上并行处理计算任务。如果计算任务可以被分解成多个独立执行的小块，那么他就可以被并行处理，只需为每一块分配一个 channel 来标志其完成。</p><p>假设我们有一个开销很大的向量计算操作，而且对每个元素的计算是独立的，就像这个理想化的例子。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Vector <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token comment">// Apply the operation to v[i], v[i+1] ... up to v[n-1].</span><span class="token keyword">func</span> <span class="token punctuation">(</span>v Vector<span class="token punctuation">)</span> <span class="token function">DoSome</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">,</span> u Vector<span class="token punctuation">,</span> c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> u<span class="token punctuation">.</span><span class="token function">Op</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    c <span class="token operator">&lt;-</span> <span class="token number">1</span>    <span class="token comment">// signal that this piece is done</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们在循环中按照 CPU 的数量独立启动每个计算任务。他们可能会按照任意顺序完成但是这不重要，我们只需要在启动所有 goroutines 后通过清空 channel 来对完成信号进行计数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> numCPU <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment">// number of CPU cores</span><span class="token keyword">func</span> <span class="token punctuation">(</span>v Vector<span class="token punctuation">)</span> <span class="token function">DoAll</span><span class="token punctuation">(</span>u Vector<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> numCPU<span class="token punctuation">)</span>  <span class="token comment">// Buffering optional but sensible.</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCPU<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">go</span> v<span class="token punctuation">.</span><span class="token function">DoSome</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token function">len</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">/</span>numCPU<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">len</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">/</span>numCPU<span class="token punctuation">,</span> u<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Drain the channel.</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCPU<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token operator">&lt;-</span>c    <span class="token comment">// wait for one task to complete</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// All done.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>相比于创建一个固定值的 numCPU，我们可以在运行时获得一个更合适的值。函数 <a href="https://go.dev/pkg/runtime#NumCPU">runtime.NumCPU</a> 返回运行机器的 CPU 硬件核心数量，因此我们可以</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> numCPU <span class="token operator">=</span> runtime<span class="token punctuation">.</span><span class="token function">NumCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>还有一个函数是 <a href="https://go.dev/pkg/runtime#GOMAXPROCS">runtime.GOMAXPROCS</a>，他可以报告（或设置）由用户定义的 Go 程序运行时可以使用的核心数。他的默认值是 runtime.NumCPU，但是可以被一个名称相似的环境变量修改，或是被调用这个函数并传入一个正整数修改。调用此函数并传入 0 会查询这个值。因此，如果我们想尊重用户设置的资源限制，我们可以</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> numCPU <span class="token operator">=</span> runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>请注意不要混淆并发（将程序结构化为独立的执行组件）和并行（在多个 CPU 上并行计算以提高效率）的概念。虽然 Go 语言的并发特性可以让一些问题易于结构化为并行计算，但 Go 语言是一种并发语言，而不是并行语言，并不是所有并行化问题都适合 Go 语言的模型。关于这两种概念的区别，可以参考这篇<a href="https://go.dev/blog/concurrency-is-not-parallelism">博客</a>中引用的演讲。</p><h2 id="A-leaky-buffer"><a href="#A-leaky-buffer" class="headerlink" title="A leaky buffer"></a>A leaky buffer</h2><p>并发编程的工具甚至可以让非并发的想法更容易表达。这里有一个对某个 RPC 包的抽象例子。客户端 goroutine 从某个数据源循环的接收数据，也许是通过网络。为了避免大量分配和释放 buffer 的开销，他持有了一个空闲 buffer 的列表，然后通过一个带缓冲区的 channel 来表示这个列表。如果 channel 是空的，那么就分配一个新的 buffer。一旦 buffer 的内容被填充完成，他使用 serverChan 将其发送至服务程序。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> freeList <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Buffer<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">var</span> serverChan <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Buffer<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> b <span class="token operator">*</span>Buffer        <span class="token comment">// Grab a buffer if available; allocate if not.</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> b <span class="token operator">=</span> <span class="token operator">&lt;-</span>freeList<span class="token punctuation">:</span>            <span class="token comment">// Got one; nothing more to do.</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token comment">// None free, so allocate a new one.</span>            b <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>Buffer<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token function">load</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>              <span class="token comment">// Read next message from the net.</span>        serverChan <span class="token operator">&lt;-</span> b      <span class="token comment">// Send to server.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>server 循环接收来自客户端的消息，处理，并将 buffer 返回到空闲列表。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        b <span class="token operator">:=</span> <span class="token operator">&lt;-</span>serverChan    <span class="token comment">// Wait for work.</span>        <span class="token function">process</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token comment">// Reuse buffer if there's room.</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> freeList <span class="token operator">&lt;-</span> b<span class="token punctuation">:</span>            <span class="token comment">// Buffer on free list; nothing more to do.</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token comment">// Free list full, just carry on.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>客户端尝试从空闲列表中取出一个 buffer，如果没有空闲的 buffer ，那么他会分配一个新的 buffer。服务器将 b 发送到空闲列表除非 freeList 已满，这时 buffer 会被丢弃之后被垃圾回收器回收。（select 语句中的 default 条件会在其他 case 都不生效时被选中，这意味着这条 select 语句永远不会堵塞。）在带缓冲区的 channel 和垃圾回收机制的共同作用下，这个实现仅使用了几行代码就构建了一个泄露桶式的 buffer 池。</p><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>库例程必须经常向调用者返回一些错误信息。就像我们之前提过的，Go 中的多重返回让我们可以轻松的在正常的返回值旁边附带详细的错误描述。使用这个特性来提供详细的错误信息是很好的风格。例如，就像我们即将看到的，os.Open 不仅仅是在故障时返回一个空指针，他还提供了一个错误值来表述错误的内容。</p><p>为了方便起见，错误被定义为类型 error，一个简单的内建接口。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>库的作者可以在这个包装下自由的使用更丰富的模型实现该接口，让错误信息不仅包括错误本身，同时提供一些其他的内容。就像之前提过的，除了返回的 *os.File 类型的值之外，os.Open 还返回一个 error 类型的值。如果文件被成功的打开，那么这个 error 值将会是 nil，但是如果发生了错误，他将会持有一个 os.PathError：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// PathError records an error and the operation and</span><span class="token comment">// file path that caused it.</span><span class="token keyword">type</span> PathError <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Op <span class="token builtin">string</span>    <span class="token comment">// "open", "unlink", etc.</span>    Path <span class="token builtin">string</span>  <span class="token comment">// The associated file.</span>    Err <span class="token builtin">error</span>    <span class="token comment">// Returned by the system call.</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>PathError<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> e<span class="token punctuation">.</span>Op <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>Path <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>Err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>PathError 的 Error 方法生成的字符串类似于这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">open /etc/passwx: no such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>像这样一个 error，囊括了有问题的文件名称、操作内容和他触发了的系统错误，即使错误打印的地方和调用处相距甚远，这样的报错依然十分有用；他比直接的打印 “no such file or directory” 能提供更多有效的信息。</p><p>如果有条件的话，error 字符串应该标注他们的来源，例如添加前缀来标注是哪个操作或者包生成了这个 error。例如，在 image 包中，因为未知格式而导致的解码错误的错误字符串为 “image: unknown format”。</p><p>关心精确的错误细节的调用者可以使用 type switch 或者类型断言来获得 error 的具体类型从而获取更多的细节。对于 PathErrors 来说，这可能包括了检查内部的 Err 字段用来处理可恢复的故障。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> try <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> try <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> try<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    file<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> e<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>os<span class="token punctuation">.</span>PathError<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>Err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>ENOSPC <span class="token punctuation">&#123;</span>        <span class="token function">deleteTempFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Recover some space.</span>        <span class="token keyword">continue</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里的第二个 if 语句是一个<a href="%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">类型断言</a>。如果他失败了，ok 的值会是 false，e 的值会是 nil。如果他成功了，ok 的值会是 true，这表示 error 的类型确实是 *os.PathError，此时 e 会成为这个类型，这样我们可以检查其中的更多信息细节。</p><h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><p>常规的向调用者汇报错误的方式是添加一个 error 类型的返回值。Read 方法就是一个广为人知的典范，他返回了读取的字节数和一个 error。但是，当发生了不可恢复的故障的情况下怎么办呢？有些情况下就是需要中断程序运行。</p><p>为了实现这个目的，有一个内建函数 panic，他可以创建一个运行时错误从而中止程序（但也有例外，参考下一章）。此函数需要一个任意类型的信号参数——通常是字符串——用作程序终止时的打印输出。他也可以用来表明发生了某些不该发生的事，例如存在一个无限循环。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A toy implementation of cube root using Newton's method.</span><span class="token keyword">func</span> <span class="token function">CubeRoot</span><span class="token punctuation">(</span>x <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>    z <span class="token operator">:=</span> x<span class="token operator">/</span><span class="token number">3</span>   <span class="token comment">// Arbitrary initial value</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e6</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        prevz <span class="token operator">:=</span> z        z <span class="token operator">-=</span> <span class="token punctuation">(</span>z<span class="token operator">*</span>z<span class="token operator">*</span>z<span class="token operator">-</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">veryClose</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> prevz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> z        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// A million iterations has not converged; something is wrong.</span>    <span class="token function">panic</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"CubeRoot(%g) did not converge"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里只是一个例子，实际上的库函数应该避免 panic。如果问题可以被掩盖或者解决，让程序继续运行下去总比直接中断整个程序要好。一个可能的反例是初始化：可以认为，如果一个库确实无法完成自身设置，那么进行 panic 也是合理的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> user <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> user <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"no value for $USER"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h2><p>当 panic 发生时，或者包括隐式的运行时错误例如切片越界、类型断言错误等等，他会立刻中断当前执行的函数并且开始释放当前 goroutine 的堆栈，运行沿途上的任何 defer 函数。如果这个释放过程到达了当前 goroutine 的顶部，程序则会终止。然而，可以使用内建函数 recover 来恢复对 goroutine 的控制并让其继续执行。</p><p>对 recover 的调用会中止释放过程，并返回传递给 panic 的参数。由于在释放过程中唯一能够被执行的代码是位于 defer 中的代码，因此 recover 只有在 defer 函数中才有作用。</p><p>recover 的一个应用是中断服务中失败的 goroutine，从而避免中断整个程序。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span>workChan <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>Work<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> work <span class="token operator">:=</span> <span class="token keyword">range</span> workChan <span class="token punctuation">&#123;</span>        <span class="token keyword">go</span> <span class="token function">safelyDo</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">safelyDo</span><span class="token punctuation">(</span>work <span class="token operator">*</span>Work<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"work failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">do</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个例子中，如果 do(work) 导致了 panic，错误结果将被日志记录，而且报错的 goroutine 只会干净的退出而不会影响其他协程。无需再 defer 闭包中再添加任何东西，调用 cover 就完全足够。</p><p>除非是直接被 defer 函数调用，否则 recover 都会返回 nil，因此 defer 中的代码可以调用那些本身也使用了 panic 和 recover 的库函数。例如，在 safelyDo 函数中的 defer 函数可以在 recover 之前调用 logging 函数，该函数的执行不会受到 panic 过程的影响。</p><p>理解了 recover 的工作模式后，我们可以通过调用 panic 让 do 函数（以及他调用的任何函数）在遇到错误情况时干净的退出。我们可以利用这个概念来简化复杂软件中的错误处理。让我们看看这个理性化的 regexp 包，他通过调用一个带有本地定义错误类型的 panic 来报告解析错误。这里是关于 Error、error 方法和 Compile 函数的定义。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Error is the type of a parse error; it satisfies the error interface.</span><span class="token keyword">type</span> Error <span class="token builtin">string</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e Error<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// error is a method of *Regexp that reports parsing errors by</span><span class="token comment">// panicking with an Error.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>regexp <span class="token operator">*</span>Regexp<span class="token punctuation">)</span> <span class="token function">error</span><span class="token punctuation">(</span>err <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">Error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// Compile returns a parsed representation of the regular expression.</span><span class="token keyword">func</span> <span class="token function">Compile</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>regexp <span class="token operator">*</span>Regexp<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    regexp <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>Regexp<span class="token punctuation">)</span>    <span class="token comment">// doParse will panic if there is a parse error.</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> e <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            regexp <span class="token operator">=</span> <span class="token boolean">nil</span>    <span class="token comment">// Clear return value.</span>            err <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token punctuation">(</span>Error<span class="token punctuation">)</span> <span class="token comment">// Will re-panic if not a parse error.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> regexp<span class="token punctuation">.</span><span class="token function">doParse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果 doParse 触发了 panic，recover 代码块会将返回值设置为nil——因为 defer 函数可以修改命名返回值的值。之后，他会在向 err 赋值的语句中通过将 e 类型断言为本地类型 Error，检查问题是否是解析错误。如果不是，那么类型断言会失败，引发一个运行时错误，从而导致堆栈继续释放，就像释放过程未曾中断这样。这种检查意味着当有一些类似于数组越界的运行时错误发生时，即使我们使用 panic 和 recover 处理了解析错误，代码仍然会失败。</p><p>在错误处理机制到位后，error 方法（虽然他和内建类型 error 同名，但是由于他是一个绑定在类型上的方法，因此这个命名没有问题，使用起来也很自然）使得我们可以更简单的上报解析错误，而无需操心于手动释放解析堆栈：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> pos <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>    re<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"'*' illegal at start of expression"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>虽然这个模式非常实用，但是他应该仅限在包内部使用。通过解析将内部的 panic 转化为 error 类型的值，而不是将 panic 暴露给自己的客户端，这是一个良好的规则。</p><p>顺带一提，这种类型的用法改变了实际报错中的 panic 内容。然而，不管是原始的还是新的报错内容都会在崩溃日志中体现，因此报错的根源依然可以被找到。因此这种简单的 re-panic 机制往往就够用了——毕竟最终都是要崩溃的——但是如果你只想在崩溃日志中展示原始错误，你可以通过写一小段代码来过滤非预期的错误然后使用原始的错误来 re-panic。这是留给读者的小练习。</p><h1 id="一个WEB服务器"><a href="#一个WEB服务器" class="headerlink" title="一个WEB服务器"></a>一个WEB服务器</h1><p>让我们用一个完整的 Go 程序来收尾，一个 WEB 服务器。这其实是一个基于其他服务的 web 服务器。Google 在 chart.apis.google.com 上提供了一个服务，可以自动将数据格式化为图表和图形。但是他的交互比较麻烦，因为你要把数据作为 URL 的一部分用来查询。这个程序提供了一个更好的数据格式接口：通过输入一段文本，他调用图表服务来生成一个二维码，他可以被您的手机扫描并且转换为一个 URL，这样您就无需在手机的小键盘上输入这个 URL。</p><p>这里是完整的程序，随后会有说明。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"flag"</span>    <span class="token string">"html/template"</span>    <span class="token string">"log"</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">var</span> addr <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"addr"</span><span class="token punctuation">,</span> <span class="token string">":1718"</span><span class="token punctuation">,</span> <span class="token string">"http service address"</span><span class="token punctuation">)</span> <span class="token comment">// Q=17, R=18</span><span class="token keyword">var</span> templ <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">Must</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"qr"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>templateStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span>QR<span class="token punctuation">)</span><span class="token punctuation">)</span>    err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"ListenAndServe:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">QR</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    templ<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">FormValue</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> templateStr <span class="token operator">=</span> <span class="token string">`&lt;html>&lt;head>&lt;title>QR Link Generator&lt;/title>&lt;/head>&lt;body>&#123;&#123;if .&#125;&#125;&lt;img src="http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl=&#123;&#123;.&#125;&#125;" />&lt;br>&#123;&#123;.&#125;&#125;&lt;br>&lt;br>&#123;&#123;end&#125;&#125;&lt;form action="/" name=f method="GET">    &lt;input maxLength=1024 size=70 name=s value="" title="Text to QR Encode">    &lt;input type=submit value="Show QR" name=qr>&lt;/form>&lt;/body>&lt;/html>`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>main 之前的部分应该都很容易理解。flag 为我们的服务设置了一个默认的 HTTP 端口。模板变量 templ 是有趣的地方。他构建了一个服务器用来显示页面的 HTML 模板，稍后会详细介绍。</p><p>main 函数中解析了 flags，使用我们之前讨论过的机制将 QR 函数绑定在服务的根路径。之后 http.ListenAndServe 被调用，启动 HTTP 服务，并且在服务运行期间阻塞主程序。</p><p>QR 接受请求包含表单数据的请求，根据表单中名为 s 的数据的值来执行模板。</p><p>模板包 html&#x2F;template 非常强力，这个程序仅仅涉及他功能的一小部分。本质上，它通过替换从传递给 templ.Execute 的数据项派生的元素来动态重写一段 HTML 文本，在这里例子中就是表单的值。在模板文本 (template Str) 中，双括号分隔的部分表示模板操作。仅当数据项 .（点） 非空时，{{if .}} 到 {{end}} 之间的代码片才会执行。这意味着，当传入字符串为空时，这一部分的模板将不生效。</p><p>两个 {{.}} 表示了两个提供给模板的数据——一个位于查询字符串——另一个直接在 web 页面中。HTML 模板包自动提供适当的转移，以便文本可以安全的显示。</p><p>模板中剩余部分的字符串只是当页面加载时显示的 HTML。如果这部分的解释过于简短，您也可以参考这篇关于模板包的<a href="#https://go.dev/pkg/html/template/">文档</a>进行更全面的讨论。</p><p>此时你已经拥有了一个仅使用几行代码创建的数据驱动的 HTML 服务。Go 就是这样，他有能力仅仅使用几行代码来实现很多事情。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go标准库：log</title>
    <link href="/Go%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9Alog.html"/>
    <url>/Go%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9Alog.html</url>
    
    <content type="html"><![CDATA[<p>彪悍的人生不需要解释，那么彪悍的模块也不需要解释，例如今天所讨论的 <code>log</code> 模块，就绝对称得上是简明易懂、短小精干，只需稍微花个十来分钟阅读源码就可以理解并使用，非常具有 <code>go</code> 的味道。</p><span id="more"></span><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h4 id="最简单的应用："><a href="#最简单的应用：" class="headerlink" title="最简单的应用："></a>最简单的应用：</h4><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>test.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Log!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>输出：</p><figure><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token date number">2024/03/01</span> <span class="token time number">09:46:29</span> Hello Log<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="通过-Logger-对象指定写入位置和自定义前缀"><a href="#通过-Logger-对象指定写入位置和自定义前缀" class="headerlink" title="通过 Logger 对象指定写入位置和自定义前缀"></a>通过 Logger 对象指定写入位置和自定义前缀</h4><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>test.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>file<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"./test.log"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDWR<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>logger <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"[Custom prefix]"</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span>logger<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Log!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-log" data-language="log"><div class="caption"><span>test.log</span></div><code class="language-log"><span class="token punctuation">[</span>Custom prefix<span class="token punctuation">]</span><span class="token date number">2024/03/01</span> <span class="token time number">09:51:53</span> Hello Log<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="一个结构体"><a href="#一个结构体" class="headerlink" title="一个结构体"></a>一个结构体</h1><p><code>log</code> 模块定义了名为 <code>Logger</code> 的结构体，用来打理一切和日志有关的操作：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>log.go</span></div><code class="language-go"><span class="token keyword">type</span> Logger <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>outMu sync<span class="token punctuation">.</span>Mutexout   io<span class="token punctuation">.</span>Writer <span class="token comment">// destination for output</span>prefix    atomic<span class="token punctuation">.</span>Pointer<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token comment">// prefix on each line to identify the logger (but see Lmsgprefix)</span>flag      atomic<span class="token punctuation">.</span>Int32           <span class="token comment">// properties</span>isDiscard atomic<span class="token punctuation">.</span>Bool<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>Logger</code> 中仅有5个成员变量，其含义如下：</p><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>outMu</td><td>输出锁，实现并发环境下有序的输出</td></tr><tr><td>out</td><td>输入对象，表示日志输出的目的地</td></tr><tr><td>prefix</td><td>用户设置的日志前缀</td></tr><tr><td>flag</td><td>配置项，一共有8个开关项</td></tr><tr><td>isDiscard</td><td>内部使用，记录输出对象是否为丢弃，当输出目标是丢弃时，输出函数不再处理，直接返回</td></tr></tbody></table><p><code>flag</code> 表示的配置项有这些：</p><table><thead><tr><th>配置项</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>Ldate</td><td>添加日期</td><td>2009&#x2F;01&#x2F;23</td></tr><tr><td>Ltime</td><td>添加时间</td><td>01:23:23</td></tr><tr><td>Lmicroseconds</td><td>添加微秒</td><td>01:23:23.123123</td></tr><tr><td>Llongfile</td><td>添加完整的日志产生的文件和行数</td><td>&#x2F;a&#x2F;b&#x2F;c&#x2F;d.go:23</td></tr><tr><td>Lshortfile</td><td>添加简短的日志产生的文件和行数</td><td>d.go:23</td></tr><tr><td>LUTC</td><td>使用UTC时间，不使用本地时区</td><td></td></tr><tr><td>Lmsgprefix</td><td>将前缀至于行首，而非消息前</td><td>2024&#x2F;03&#x2F;01 10:30:58 [Custom prefix]Hello Log!</td></tr><tr><td>LstdFlags</td><td>等于 Ldate | Ltime</td><td>设置日期时间的快捷方法</td></tr></tbody></table><h1 id="两种入口"><a href="#两种入口" class="headerlink" title="两种入口"></a>两种入口</h1><p>使用者可以自己创建 <code>Logger</code> 对象，从而定制日志输出的目标、字符串前缀、配置项等，然而更简单的方式是直接使用 <code>log</code> 模块提供的公共函数。这些函数使用 <code>log</code> 模块内置的 <code>Logger</code> 对象、使用 <code>os.stdOut</code> 作为输出、没有前缀并使用 <code>LstdFlags</code> 作为默认配置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Log!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>或者自己创建 <code>Logger</code> 实现更多的定制化需求，或是创建多个 <code>Logger</code> 将日志发往不同地方等：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">logger <span class="token operator">:=</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"[Custom prefix]"</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="三类输出方式"><a href="#三类输出方式" class="headerlink" title="三类输出方式"></a>三类输出方式</h1><p>不管是如何创建的 <code>Logger</code> ，都提供了相同的输出方式，即三类、六种功能函数：</p><ul><li>Print[f|ln]</li><li>Fatal[f|ln]</li><li>Panic[f|ln]</li></ul><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td>Printf</td><td>输出日志</td></tr><tr><td>Println</td><td>输出日志并换行</td></tr><tr><td>Fatalf</td><td>输出日志，之后退出程序</td></tr><tr><td>Fatalln</td><td>输出日志并换行，之后退出程序</td></tr><tr><td>Panicf</td><td>输出日志，之后向上抛出panic，可能退出程序或被recover</td></tr><tr><td>Panicln</td><td>输出日志并换行，之后向上抛出panic，可能退出程序或被recover</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Go</code> 提供的日志模块非常简单，清晰易懂，便于使用者将其封装为各种业务模块。使用方法简单到堪称优雅的程度，再次提醒我们在使用 <code>Go</code> 工作的过程中，要反复不断的去学习标准库，体会其少即是多的设计思想。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过proxychains-windows在命令行中使用socks5代理</title>
    <link href="/%E9%80%9A%E8%BF%87proxychains-windows%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86.html"/>
    <url>/%E9%80%9A%E8%BF%87proxychains-windows%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86.html</url>
    
    <content type="html"><![CDATA[<p>工作时有时会需要使用一些带有网络操作命令行工具，这些工具也可能需要通过socks5进行代理，<a href="https://github.com/shunf4/proxychains-windows">proxychains-windows</a> 为我们提供了直接的解决方案。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在proxychains-windows的<a href="https://github.com/shunf4/proxychains-windows/blob/master/README_zh-Hans.md">介绍文档</a>中摘录如下内容：</p><blockquote><p>Proxychains.exe 是一个适用于 Win32(Windows) 和 Cygwin 平台的命令行强制代理工具（Proxifier）。它能够截获大多数 Win32 或 Cygwin 程序的 TCP 连接，强制它们通过一个或多个 SOCKS5 代理隧道。<br>Proxychains.exe 通过给动态链接的程序注入一个 DLL，对 Ws2_32.dll 的 Winsock 函数挂钩子的方式来将应用程序的连接重定向到 SOCKS5 代理。</p></blockquote><blockquote><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><ul><li>主程序 Hook CreateProcessW Win32 API 函数调用。</li><li>主程序创建按照用户给定的命令行启动子进程。</li><li>创建进程后，挂钩后的 CreateProcessW 函数将 Hook DLL 注入到子进程。当子进程被注入后，它也会 Hook 如下的 Win32 API 函数调用：<ul><li>CreateProcessW，这样每一个后代进程都会被注入；</li><li>connect 和 ConnectEx，这样就劫持了 TCP 连接；</li><li>GetAddrInfoW 系列函数，这样可以使用 Fake IP 来追踪访问的域名，用于远程 DNS 解析；</li><li>等等。</li></ul></li><li>主程序并不退出，而是作为一个命名管道服务端存在。子进程与主程序通过命名管道交换包括日志、域名等内容在内的数据。主程序实施大多数关于 Fake IP 和子进程是否还存在的簿记工作。</li><li>当所有后代进程退出后，主程序退出。</li><li>主程序收到一个 SIGINT（Ctrl-C）后，终止所有后代进程。</li></ul></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>按照文档，最简单的使用方法为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxychains_win32_x64.exe <span class="token parameter variable">-f</span> proxychains.conf cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>格式为 <code>可执行程序</code> <code>-f</code> <code>配置文件路径</code> <code>被代理的命令行工具</code>，使用 <code>cmd</code> 作为工具则可以在新开的命令行中手动使用其他命令行工具，均会被代理。</p><h1 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h1><p>通过创建下述快捷方式，可以更方便的使用 proxychains-windows。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C:<span class="token punctuation">\</span>Windows<span class="token punctuation">\</span>System32<span class="token punctuation">\</span>cmd.exe /k C:"<span class="token punctuation">\</span>Program Files<span class="token punctuation">\</span>"proxychains_0.6.8_win32_x64<span class="token punctuation">\</span>proxychains_win32_x64.exe <span class="token parameter variable">-f</span> proxychains.conf cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT 5.0 中文文档</title>
    <link href="/mqtt-v5-0-chinese.html"/>
    <url>/mqtt-v5-0-chinese.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html">MQTT Version 5.0</a><br><strong>[mqtt-v5.0]</strong><br>MQTT Version 5.0. Edited by Andrew Banks, Ed Briggs, Ken Borgendale, and Rahul Gupta. 07 March 2019. OASIS Standard. <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html</a>. Latest version: <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html">https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html</a>.</p></blockquote><span id="more"></span><head>  <style>    :root {      --vc-marked: #ffc107;      --vc-referred: #EE0000;    }    [data-user-color-scheme="dark"] {      --vc-marked: #886c57;      --vc-referred: #EE0000;    }    .bold {      font-weight: bold;    }    .vcLinked {      color: var(--post-link-color);    }    .vcMarked {      background: var(--vc-marked);    }    .vcReferred {      color: var(--vc-referred);    }    .vcTrans {      font-size: 0.8rem;      font-style: italic;    }  </style></head><h1 id="MQTT-5-0"><a href="#MQTT-5-0" class="headerlink" title="MQTT 5.0"></a>MQTT 5.0</h1><p>OASIS 标准</p><p>2019年3月7日</p><h2 id="规范-URIs"><a href="#规范-URIs" class="headerlink" title="规范 URIs"></a>规范 URIs</h2><h3 id="此版本"><a href="#此版本" class="headerlink" title="此版本"></a>此版本</h3><p><a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.docx">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.docx</a> (权威性)<br><a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html</a><br><a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.pdf">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.pdf</a></p><h3 id="前一版本"><a href="#前一版本" class="headerlink" title="前一版本"></a>前一版本</h3><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/cos01/mqtt-v5.0-cos01.docx">http://docs.oasis-open.org/mqtt/mqtt/v5.0/cos01/mqtt-v5.0-cos01.docx</a> (权威性)<br><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/cos01/mqtt-v5.0-cos01.html">http://docs.oasis-open.org/mqtt/mqtt/v5.0/cos01/mqtt-v5.0-cos01.html</a><br><a href="http://docs.oasis-open.org/mqtt/mqtt/v5.0/cos01/mqtt-v5.0-cos01.pdf">http://docs.oasis-open.org/mqtt/mqtt/v5.0/cos01/mqtt-v5.0-cos01.pdf</a></p><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h3><p><a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.docx">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.docx</a> (权威性)<br><a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html</a><br><a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.pdf">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.pdf</a></p><h3 id="技术委员会"><a href="#技术委员会" class="headerlink" title="技术委员会"></a>技术委员会</h3><p><a href="https://www.oasis-open.org/committees/mqtt/">OASIS Message Queuing Telemetry Transport (MQTT) TC</a></p><h3 id="主席"><a href="#主席" class="headerlink" title="主席"></a>主席</h3><p>Richard Coppen (<a href="mailto:&#x63;&#111;&#112;&#112;&#101;&#x6e;&#x40;&#x75;&#107;&#x2e;&#x69;&#x62;&#x6d;&#46;&#x63;&#111;&#x6d;">&#x63;&#111;&#112;&#112;&#101;&#x6e;&#x40;&#x75;&#107;&#x2e;&#x69;&#x62;&#x6d;&#46;&#x63;&#111;&#x6d;</a>), <a href="http://www.ibm.com/">IBM</a></p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>Andrew Banks (<a href="mailto:&#97;&#x6e;&#x64;&#114;&#x65;&#x77;&#95;&#98;&#97;&#x6e;&#107;&#115;&#64;&#x75;&#x6b;&#x2e;&#x69;&#x62;&#109;&#46;&#99;&#111;&#109;">&#97;&#x6e;&#x64;&#114;&#x65;&#x77;&#95;&#98;&#97;&#x6e;&#107;&#115;&#64;&#x75;&#x6b;&#x2e;&#x69;&#x62;&#109;&#46;&#99;&#111;&#109;</a>), <a href="http://www.ibm.com/">IBM</a><br>Ed Briggs (<a href="mailto:&#101;&#x64;&#x62;&#114;&#105;&#x67;&#103;&#115;&#64;&#x6d;&#105;&#x63;&#x72;&#x6f;&#115;&#x6f;&#102;&#116;&#46;&#x63;&#111;&#x6d;">&#101;&#x64;&#x62;&#114;&#105;&#x67;&#103;&#115;&#64;&#x6d;&#105;&#x63;&#x72;&#x6f;&#115;&#x6f;&#102;&#116;&#46;&#x63;&#111;&#x6d;</a>), <a href="http://www.microsoft.com/">Microsoft</a><br>Ken Borgendale (<a href="mailto:&#107;&#x77;&#98;&#64;&#117;&#x73;&#x2e;&#105;&#98;&#109;&#x2e;&#x63;&#111;&#x6d;">&#107;&#x77;&#98;&#64;&#117;&#x73;&#x2e;&#105;&#98;&#109;&#x2e;&#x63;&#111;&#x6d;</a>), <a href="http://www.ibm.com/">IBM</a><br>Rahul Gupta (<a href="mailto:&#x72;&#97;&#104;&#117;&#108;&#46;&#103;&#117;&#112;&#116;&#x61;&#x40;&#x75;&#x73;&#x2e;&#105;&#x62;&#109;&#46;&#99;&#111;&#x6d;">&#x72;&#97;&#104;&#117;&#108;&#46;&#103;&#117;&#112;&#116;&#x61;&#x40;&#x75;&#x73;&#x2e;&#105;&#x62;&#109;&#46;&#99;&#111;&#x6d;</a>), <a href="http://www.ibm.com/">IBM</a></p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>本规范取代：</p><ul><li><em>MQTT 3.1.1</em>  由 Andrew Banks 和 Rahul Gupta 编辑发布与 2014年10月29日。 OASIS 标准 <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a> 最新版本：<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html</a></li></ul><p>本规范涉及：</p><ul><li><em>MQTT and the NIST Cybersecurity Framework Version 1.0</em> 由 Geoff Brown 和 Louis-Philippe Lamoureux 编辑发布。最新版本： <a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MQTT 是一个 客户端&#x2F;服务器 架构，采用 订阅&#x2F;发布 模式的消息传输协议。是一套轻量级的、开放的、简单且易于实现的标准。这些特性使得他适用于多种场景，包括一些资源受限的场景比如机器和机器之间的通信（M2M）或是物联网（IoT）场景，这些场景要求较小的代码空间占用，或是网络带宽非常珍贵。</p><p>MQTT 基于 TCP&#x2F;IP 或其他提供了顺序、无包丢失、双向链接的网络协议。MQTT 的特性包括：</p><ul><li>通过 订阅&#x2F;发布 模式实现一对多的消息传输和应用程序解耦。</li><li>与负载内容无关的消息传输。</li><li>三种不同服务质量(QoS)的消息传输：<ul><li>至多一次(At most once)，根据操作环境情况尽最大努力来传输消息，消息可能会丢失。例如这种模式可以用于传感器数据采集，单次的消息的丢失并不重要，因为下一个消息很快就会到来。</li><li>至少一次(At least once)，可以确保消息到达，但是可能会造成消息重复。</li><li>确保一次(Exactly once)，可以确保消息只到达一次，例如这种消息可以用于账单交易信息，在交易场景下消息的丢失或者重复处理都会带来糟糕的后果。</li></ul></li><li>小型的协议头，用来降低网络负载。</li><li>当发生异常断开时通知相关方的机制。</li></ul><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>本文档最后一次修订的日期和级别都已经在前文中描述。检查<a href="#%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC">最新版本</a>位置了解本文档后续可能的修订版。技术委员会(TC)制作的其他版本文档或其他技术项目均在此提供 <a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical">https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=mqtt#technical</a></p><p>技术委员会成员应将对此文档的评论发送至技术委员会邮件列表，其他人需在技术委员会的网站(<a href="https://www.oasis-open.org/committees/mqtt/)%E8%AE%A2%E9%98%85%E5%85%AC%E5%85%B1%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB[%E5%8F%91%E9%80%81%E8%AF%84%E8%AE%BA](https://www.oasis-open.org/committees/comments/index.php?wg_abbrev=mqtt)%E5%B0%86%E8%AF%84%E8%AE%BA%E5%8F%91%E9%80%81%E8%87%B3%E5%85%AC%E5%85%B1%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8%E3%80%82">https://www.oasis-open.org/committees/mqtt/)订阅公共评论列表后，通过点击[发送评论](https://www.oasis-open.org/committees/comments/index.php?wg_abbrev=mqtt)将评论发送至公共评论列表。</a></p><p>本规范是在 OASIS <a href="https://www.oasis-open.org/policies-guidelines/ipr">知识产权政策</a>的 <a href="https://www.oasis-open.org/policies-guidelines/ipr#Non-Assertion-Mode">Non-Assertion</a>模式下提供的，该模式是技术委员会成立时选择的。关于是否有实施本规范依赖的已经披露的专利信息或是关于任何专利许可条款的信息，请参考技术委员会网站中的知识产权部分(<a href="https://www.oasis-open.org/committees/mqtt/ipr.php)%E3%80%82">https://www.oasis-open.org/committees/mqtt/ipr.php)。</a></p><p>请注意，本工作产品声明为规范的任何机器可读内容（<a href="https://www.oasis-open.org/policies-guidelines/tc-process#wpComponentsCompLang">计算机语言定义</a>）均以单独的纯文本文件提供。 如果任何此类纯文本文件与工作产品的散文叙述性文档中的显示内容之间存在差异，则以单独的纯文本文件中的内容为准。</p><h3 id="引用格式"><a href="#引用格式" class="headerlink" title="引用格式"></a>引用格式</h3><p>引用本规范时，需要使用如下引用格式：</p><p><strong>[mqtt-v5.0]</strong></p><p>MQTT Version 5.0. Edited by Andrew Banks, Ed Briggs, Ken Borgendale, and Rahul Gupta. 07 March 2019. OASIS Standard. <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html</a>. Latest version: <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html">https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html</a>.</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>Copyright © OASIS Open 2019. All Rights Reserved.</p><p>以下文本中所有 <code>大写</code> 术语均具有 <code>OASIS</code> 知识产权政策（the <code>OASIS IPR Policy</code>）中指定的含义。 完整的<a href="https://www.oasis-open.org/policies-guidelines/ipr">政策</a>可以在 <code>OASIS</code> 网站上找到。</p><p>本文档及其译本可以被复制并提供给其他人，本文档的原文或对本文档的部分引用、评论、解释说明等衍生品的制作、复制、出版和分发均没有限制，但上述许可的前提条件是上述的版权说明和本节内容必须包括在此类副本和衍生品内。并且，对于本文档本身的内容不得做任何修改，包括删除版权申明或对 <code>OASIS</code> 的引用，除非是为了 <code>OASIS</code> 技术委员会为了制作某些文件或者交付成果的需要（在这种情况下，必须遵守 OASIS 知识产权政策中规定的适用于版权的规则）或是将本文档翻译为英语之外的其他语言。</p><p>上述授予的有限权限是永久性的，<code>OASIS</code> 或其继承者或受让人不会撤销。</p><p>本文档和此处包含的信息均按<code>原样</code>提供，<code>OASIS 不承担任何明示或暗示的保证，包括但不限于使用此处信息不会侵犯任何所有权的任何保证或任何暗示的保证商用能力或特定用途的适用性</code>。</p><p><code>OASIS</code> 要求任何 <code>OASIS</code> 方或任何其他方认为其专利主张必然会因实施本 <code>OASIS</code> 委员会规范或 <code>OASIS</code> 标准而受到侵犯时，通知 OASIS 技术委员会管理员并表明其愿意向此类人员授予专利许可。 专利权利要求的方式与制定本规范的 <code>OASIS</code> 技术委员会的 IPR 模式一致。</p><p><code>OASIS</code> 邀请任何一方联系 <code>OASIS</code> 技术委员会管理员，如果它知道任何专利权利要求的所有权主张，如果专利持有者不愿意使用与制定本规范的 <code>OASIS</code> 技术委员会的 <code>IPR</code> 模式一致的方式。 <code>OASIS</code> 可能会在其网站上包含此类声明，但不承担任何这样做的义务。</p><p>对于可能声称与本文档中描述的技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或者此类权利下的任何许可可能或可能不可用的范围，<code>OASIS</code> 不持任何立场 ; 他也不代表他已做出任何努力来确定任何此类权利。 有关 <code>OASIS</code> 与 <code>OASIS</code> 技术委员会制定的任何文件或交付物的权利有关的程序的信息，请参见 <code>OASIS</code> 网站。 可供发布的权利主张的副本以及可供使用的许可证的任何保证，或者本 <code>OASIS</code> 委员会规范的实施者或用户尝试获得使用此类专有权利的一般许可证或许可的结果，或 <code>OASIS</code> 标准，可从 <code>OASIS</code> 技术委员会管理员处获取。 <code>OASIS</code> 不声明任何信息或知识产权列表在任何时候都是完整的，也不声明该列表中的任何权利要求实际上是基本权利要求。</p><p>名称<code>“OASIS”</code>是 <code>OASIS</code>（本规范的所有者和开发者）的商标，仅用于指代该组织及其官方输出。 <code>OASIS</code> 欢迎参考、实施和使用规范，同时保留强制执行其标记以防止误导性使用的权利。 请参阅 <a href="https://www.oasis-open.org/policies-guidelines/trademark">https://www.oasis-open.org/policies-guidelines/trademark</a> 了解上述指南。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>1 <a href="#1-%E4%BB%8B%E7%BB%8D">介绍</a><ul><li>1.0 <a href="#1-0-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E6%94%BF%E7%AD%96">知识产权政策</a></li><li>1.1 <a href="#1-1-MQTT%E8%A7%84%E8%8C%83%E7%BB%93%E6%9E%84">MQTT规范结构</a></li><li>1.2 <a href="#1-2-%E6%9C%AF%E8%AF%AD%E8%A1%A8">术语表</a></li><li>1.3 <a href="#1-3-%E8%A7%84%E8%8C%83%E6%80%A7%E5%BC%95%E7%94%A8">规范性引用</a></li><li>1.4 <a href="#1-4-%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%E5%BC%95%E7%94%A8">非规范性引用</a></li><li>1.5 <a href="#1-5-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA">数据表示</a><ul><li>1.5.1 <a href="#1-5-1-%E6%AF%94%E7%89%B9%E4%BD%8D">比特位</a></li><li>1.5.2 <a href="#1-5-2-2%E5%AD%97%E8%8A%82%E6%95%B4%E6%95%B0">2字节整数</a></li><li>1.5.3 <a href="#1-5-3-4%E5%AD%97%E8%8A%82%E6%95%B4%E6%95%B0">4字节整数</a></li><li>1.5.4 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">UTF-8字符串</a></li><li>1.5.5 <a href="#1-5-5-%E5%8F%98%E9%95%BF%E6%95%B4%E6%95%B0">变长整数</a></li><li>1.5.6 <a href="#1-5-6-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE">二进制数据</a></li><li>1.5.7 <a href="#1-5-7-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9">UTF-8字符串对</a></li></ul></li><li>1.6 <a href="#1-6-%E5%AE%89%E5%85%A8%E6%80%A7">安全性</a></li><li>1.7 <a href="#1-7-%E7%BC%96%E8%BE%91%E7%BA%A6%E5%AE%9A">编辑约定</a></li><li>1.8 <a href="#1-8-%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2">变更历史</a><ul><li>1.8.1 <a href="#1-8-1-MQTT-v3-1-1">MQTT v3.1.1</a></li><li>1.8.2 <a href="#1-8-2-MQTT-v5-0">MQTT v5.0</a></li></ul></li></ul></li><li>2 <a href="#2-MQTT%E5%8C%85%E6%A0%BC%E5%BC%8F">MQTT包格式</a><ul><li>2.1 <a href="#2-1-MQTT%E5%8C%85%E7%BB%93%E6%9E%84">MQTT包结构</a><ul><li>2.1.1 <a href="#2-1-1-%E5%9B%BA%E5%AE%9A%E5%A4%B4">固定头</a></li><li>2.1.2 <a href="#2-1-2-MQTT%E5%8C%85%E7%B1%BB%E5%9E%8B">MQTT包类型</a></li><li>2.1.3 <a href="2-1-3-%E6%8E%A7%E5%88%B6%E6%A0%87%E8%AF%86">控制标识</a></li><li>2.1.4 <a href="#2-1-4-%E5%89%A9%E4%BD%99%E9%95%BF%E5%BA%A6">剩余长度</a></li></ul></li><li>2.2 <a href="#2-2-%E5%8F%AF%E5%8F%98%E5%A4%B4">可变头</a><ul><li>2.2.1 <a href="#2-2-1-%E5%8C%85ID">包ID</a></li><li>2.2.2 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">属性集</a><ul><li>2.2.2.1 <a href="#2-2-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>2.2.2.2 <a href="#2-2-2-2-%E5%B1%9E%E6%80%A7">属性</a></li></ul></li></ul></li><li>2.3 <a href="#2-3-%E8%BD%BD%E8%8D%B7">载荷</a></li><li>2.4 <a href="#2-4-%E5%8E%9F%E5%9B%A0%E7%A0%81">原因码</a></li></ul></li><li>3 <a href="#3-MQTT%E5%8C%85">MQTT包</a><ul><li>3.1 <a href="#3-1-CONNECT-%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82">CONNECT - 连接请求</a><ul><li>3.1.1 <a href="#3-1-1-CONNECT%E5%9B%BA%E5%AE%9A%E5%A4%B4">CONNECT固定头</a></li><li>3.1.2 <a href="#3-1-2-CONNECT%E5%8F%AF%E5%8F%98%E5%A4%B4">CONNECT可变头</a><ul><li>3.1.2.1 <a href="#3-1-2-1-%E5%8D%8F%E8%AE%AE%E5%90%8D">协议名</a></li><li>3.1.2.2 <a href="#3-1-2-2-%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC">协议版本</a></li><li>3.1.2.3 <a href="#3-1-2-3-%E8%BF%9E%E6%8E%A5%E6%A0%87%E8%AF%86">连接标识</a></li><li>3.1.2.4 <a href="#3-1-2-4-%E5%85%A8%E6%96%B0%E5%BC%80%E5%A7%8B">全新开始</a></li><li>3.1.2.5 <a href="#3-1-2-5-%E9%81%97%E5%98%B1%E6%A0%87%E8%AF%86">遗嘱标识</a></li><li>3.1.2.6 <a href="#3-1-2-6-%E9%81%97%E5%98%B1QoS">遗嘱QoS</a></li><li>3.1.2.7 <a href="#3-1-2-7-%E9%81%97%E5%98%B1%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF">遗嘱保留消息</a></li><li>3.1.2.8 <a href="#3-1-2-8-%E7%94%A8%E6%88%B7%E5%90%8D%E6%A0%87%E8%AF%86">用户名标识</a></li><li>3.1.2.9 <a href="#3-1-2-9-%E5%AF%86%E7%A0%81%E6%A0%87%E8%AF%86">密码标识</a></li><li>3.1.2.10 <a href="#3-1-2-10-%E4%BF%9D%E6%B4%BB%E6%97%B6%E9%97%B4">保活时间</a></li><li>3.1.2.11 <a href="#3-1-2-11-CONNECT%E5%B1%9E%E6%80%A7%E9%9B%86">CONNECT属性集</a><ul><li>3.1.2.11.1 <a href="#3-1-2-11-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.1.2.11.2 <a href="#3-1-2-11-2-%E4%BC%9A%E8%AF%9D%E8%BF%87%E6%9C%9F%E9%97%B4%E9%9A%94">会话过期间隔</a></li><li>3.1.2.11.3 <a href="#3-1-2-11-3-%E6%8E%A5%E6%94%B6%E6%9C%80%E5%A4%A7%E5%80%BC">接收最大值</a></li><li>3.1.2.11.4 <a href="#3-1-2-11-4-%E6%9C%80%E5%A4%A7%E5%8C%85%E5%B0%BA%E5%AF%B8">最大包尺寸</a></li><li>3.1.2.11.5 <a href="#3-1-2-11-5-%E4%B8%BB%E9%A2%98%E5%88%AB%E5%90%8D%E6%9C%80%E5%A4%A7%E5%80%BC">主题别名最大值</a></li><li>3.1.2.11.6 <a href="#3-1-2-11-6-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF">请求响应信息</a></li><li>3.1.2.11.7 <a href="#3-1-2-11-7-%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98%E4%BF%A1%E6%81%AF">请求问题信息</a></li><li>3.1.2.11.8 <a href="#3-1-2-11-8-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li><li>3.1.2.11.9 <a href="#3-1-2-11-9-%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F">认证方式</a></li><li>3.1.2.11.10 <a href="#3-1-2-11-10-%E8%AE%A4%E8%AF%81%E6%95%B0%E6%8D%AE">认证数据</a></li></ul></li><li>3.1.2.12 <a href="#3-1-2-12-%E5%8F%AF%E5%8F%98%E5%A4%B4%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%E7%A4%BA%E4%BE%8B">可变头非规范性示例</a></li></ul></li><li>3.1.3 <a href="#3-1-3-CONNECT%E8%BD%BD%E8%8D%B7">CONNECT载荷</a><ul><li>3.1.3.1 <a href="#3-1-3-1-%E5%AE%A2%E6%88%B7%E7%AB%AFID">客户端ID</a></li><li>3.1.3.2 <a href="#3-1-3-2-%E9%81%97%E5%98%B1%E5%B1%9E%E6%80%A7%E9%9B%86">遗嘱属性集</a><ul><li>3.1.3.2.1 <a href="#3-1-3-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.1.3.2.2 <a href="#3-1-3-2-2-%E9%81%97%E5%98%B1%E5%BB%B6%E8%BF%9F%E9%97%B4%E9%9A%94">遗嘱延迟间隔</a></li><li>3.1.3.2.3 <a href="#3-1-3-2-3-%E8%BD%BD%E8%8D%B7%E6%A0%BC%E5%BC%8F%E6%A0%87%E8%AF%86">载荷格式标识</a></li><li>3.1.3.2.4 <a href="#3-1-3-2-4-%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F%E9%97%B4%E9%9A%94">消息过期间隔</a></li><li>3.1.3.2.5 <a href="#3-1-3-2-5-%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B">内容类型</a></li><li>3.1.3.2.6 <a href="#3-1-3-2-6-%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98">响应主题</a></li><li>3.1.3.2.7 <a href="#3-1-3-2-7-%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE">关联数据</a></li><li>3.1.3.2.8 <a href="#3-1-3-2-8-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li><li>3.1.3.3 <a href="#3-1-3-3-%E9%81%97%E5%98%B1%E4%B8%BB%E9%A2%98">遗嘱主题</a></li><li>3.1.3.4 <a href="3-1-3-4-%E9%81%97%E5%98%B1%E8%BD%BD%E8%8D%B7">遗嘱载荷</a></li><li>3.1.3.5 <a href="#3-1-3-5-%E7%94%A8%E6%88%B7%E5%90%8D">用户名</a></li><li>3.1.3.6 <a href="#3-1-3-6-%E5%AF%86%E7%A0%81">密码</a></li></ul></li><li>3.1.4 <a href="#3-1-4-CONNECT%E5%8A%A8%E4%BD%9C">CONNECT动作</a></li></ul></li><li>3.2 <a href="#3-2-CONNACK-%E8%BF%9E%E6%8E%A5%E7%A1%AE%E8%AE%A4">CONNACK - 连接确认</a><ul><li>3.2.1 <a href="#3-2-1-CONNACK%E5%9B%BA%E5%AE%9A%E5%A4%B4">CONNACK固定头</a></li><li>3.2.2 <a href="#3-2-2-CONNACK%E5%8F%AF%E5%8F%98%E5%A4%B4">CONNACK可变头</a><ul><li>3.2.2.1 <a href="#3-2-2-1-%E8%BF%9E%E6%8E%A5%E5%9B%9E%E5%A4%8D%E6%A0%87%E8%AF%86">连接回复标识</a><ul><li>3.2.2.1.1 <a href="#3-2-2-1-1-%E4%BC%9A%E8%AF%9D%E5%B1%95%E7%A4%BA">会话展示</a></li></ul></li><li>3.2.2.2 <a href="#3-2-2-2-%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E7%A0%81">连接原因码</a></li><li>3.2.2.3 <a href="#3-2-2-3-CONNACK%E5%B1%9E%E6%80%A7%E9%9B%86">CONNACK属性集</a><ul><li>3.2.2.3.1 <a href="#3-2-2-3-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.2.2.3.2 <a href="#3-2-2-3-2-%E4%BC%9A%E8%AF%9D%E8%BF%87%E6%9C%9F%E9%97%B4%E9%9A%94">会话过期间隔</a></li><li>3.2.2.3.3 <a href="#3-2-2-3-3-%E6%8E%A5%E6%94%B6%E6%9C%80%E5%A4%A7%E5%80%BC">接收最大值</a></li><li>3.2.2.3.4 <a href="#3-2-2-3-4-%E6%9C%80%E5%A4%A7QoS">最大QoS</a></li><li>3.2.2.3.5 <a href="#3-2-2-3-5-%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF%E5%8F%AF%E7%94%A8">保留消息可用</a></li><li>3.2.2.3.6 <a href="#3-2-2-3-6-%E6%9C%80%E5%A4%A7%E5%8C%85%E5%B0%BA%E5%AF%B8">最大包尺寸</a></li><li>3.2.2.3.7 <a href="#3-2-2-3-7-%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AFID">分配的客户端ID</a></li><li>3.2.2.3.8 <a href="#3-2-2-3-8-%E4%B8%BB%E9%A2%98%E5%88%AB%E5%90%8D%E6%9C%80%E5%A4%A7%E5%80%BC">主题别名最大值</a></li><li>3.2.2.3.9 <a href="#3-2-2-3-9-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.2.2.3.10 <a href="#3-2-2-3-10-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li><li>3.2.2.3.11 <a href="#3-2-2-3-11-%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AE%A2%E9%98%85%E5%8F%AF%E7%94%A8">通配符订阅可用</a></li><li>3.2.2.3.12 <a href="#3-2-2-3-12-%E8%AE%A2%E9%98%85ID%E5%8F%AF%E7%94%A8">订阅ID可用</a></li><li>3.2.2.3.13 <a href="#3-2-2-3-12-%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85%E5%8F%AF%E7%94%A8">共享订阅可用</a></li><li>3.2.2.3.14 <a href="#3-2-2-3-14-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%9D%E6%B4%BB%E6%97%B6%E9%97%B4">服务器保活时间</a></li><li>3.2.2.3.15 <a href="#3-2-2-3-15-%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF">响应信息</a></li><li>3.2.2.3.16 <a href="#3-2-2-3-16-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8">服务引用</a></li><li>3.2.2.3.17 <a href="#3-2-2-3-17-%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F">认证方式</a></li><li>3.2.2.3.18 <a href="#3-2-2-3-18-%E8%AE%A4%E8%AF%81%E6%95%B0%E6%8D%AE">认证数据</a></li></ul></li></ul></li><li>3.2.3 <a href="#3-2-3-CONNACK%E8%BD%BD%E8%8D%B7">CONNACK载荷</a></li></ul></li><li>3.3 <a href="#3-3-PUBLISH-%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF">PUBLISH - 发布消息</a><ul><li>3.3.1 <a href="#3-3-1-PUBLISH-%E5%9B%BA%E5%AE%9A%E5%A4%B4">PUBLISH 固定头</a><ul><li>3.3.1.1 <a href="#3-3-1-1-%E9%87%8D%E5%A4%8D%E6%A0%87%E8%AF%86">重复标识</a></li><li>3.3.1.2 <a href="#3-3-1-2-QoS">QoS</a></li><li>3.3.1.3 <a href="#3-3-1-3-%E4%BF%9D%E7%95%99%E6%B6%88%E6%81%AF">保留消息</a></li><li>3.3.1.4 <a href="#3-3-1-4-%E5%89%A9%E4%BD%99%E9%95%BF%E5%BA%A6">剩余长度</a></li></ul></li><li>3.3.2 <a href="#3-3-2-PUBLISH%E5%8F%AF%E5%8F%98%E5%A4%B4">PUBLISH可变头</a><ul><li>3.3.2.1 <a href="#3-3-2-1-%E4%B8%BB%E9%A2%98%E5%90%8D%E7%A7%B0">主题名称</a></li><li>3.3.2.2 <a href="#3-3-2-2-%E5%8C%85ID">包ID</a></li><li>3.3.2.3 <a href="#3-3-2-3-PUBLISH%E5%B1%9E%E6%80%A7%E9%9B%86">PUBLISH属性集</a><ul><li>3.3.2.3.1 <a href="#3-3-2-3-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.3.2.3.2 <a href="#3-3-2-3-2-%E8%BD%BD%E8%8D%B7%E6%A0%BC%E5%BC%8F%E6%A0%87%E8%AF%86">载荷格式标识</a></li><li>3.3.2.3.3 <a href="#3-3-2-3-3-%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F%E9%97%B4%E9%9A%94">消息过期间隔</a></li><li>3.3.2.3.4 <a href="#3-3-2-3-4-%E4%B8%BB%E9%A2%98%E5%88%AB%E5%90%8D">主题别名</a></li><li>3.3.2.3.5 <a href="#3-3-2-3-5-%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98">响应主题</a></li><li>3.3.2.3.6 <a href="#3-3-2-3-6-%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE">关联数据</a></li><li>3.3.2.3.7 <a href="#3-3-2-3-7-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li><li>3.3.2.3.8 <a href="#3-3-2-3-8-%E8%AE%A2%E9%98%85ID">订阅ID</a></li><li>3.3.2.3.9 <a href="#3-3-2-3-9-%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B">内容类型</a></li></ul></li></ul></li><li>3.3.3 <a href="#3-3-3-PUBLISH%E8%BD%BD%E8%8D%B7">PUBLISH载荷</a></li><li>3.3.4 <a href="#3-3-4-PUBLISH%E5%8A%A8%E4%BD%9C">PUBLISH动作</a></li></ul></li><li>3.4 <a href="#3-4-PUBACK-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4">PUBACK - 发布确认</a><ul><li>3.4.1 <a href="#3-4-1-PUBACK%E5%9B%BA%E5%AE%9A%E5%A4%B4">PUBACK固定头</a></li><li>3.4.2 <a href="#3-4-2-PUBACK%E5%8F%AF%E5%8F%98%E5%A4%B4">PUBACK可变头</a><ul><li>3.4.2.1 <a href="#3-4-2-1-PUBACK%E5%8E%9F%E5%9B%A0%E7%A0%81">PUBACK原因码</a></li><li>3.4.2.2 <a href="#3-4-2-2-PUBACK%E5%B1%9E%E6%80%A7%E9%9B%86">PUBACK属性集</a><ul><li>3.4.2.2.1 <a href="#3-4-2-2-1-%E5%B1%9E%E6%80%A7%E9%9B%86%E9%95%BF%E5%BA%A6">属性集长度</a></li><li>3.4.2.2.2 <a href="#3-4-2-2-2-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.4.2.2.3 <a href="#3-4-2-2-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.4.3 <a href="#3-4-3-PUBACK%E8%BD%BD%E8%8D%B7">PUBACK载荷</a></li><li>3.4.4 <a href="#3-4-4-PUBACK%E5%8A%A8%E4%BD%9C">PUBACK动作</a></li></ul></li><li>3.5 <a href="#3-5-PUBREC-%E5%8F%91%E5%B8%83%E7%AD%BE%E6%94%B6%EF%BC%88QoS-2-%E4%BA%A4%E4%BB%98%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89">PUBREC - 发布签收（QoS 2 交付第一部分）</a><ul><li>3.5.1 <a href="#3-5-1-PUBREC%E5%9B%BA%E5%AE%9A%E5%A4%B4">PUBREC固定头</a></li><li>3.5.2 <a href="#3-5-2-PUBREC%E5%8F%AF%E5%8F%98%E5%A4%B4">PUBREC可变头</a><ul><li>3.5.2.1 <a href="#3-5-2-1-PUBREC%E5%8E%9F%E5%9B%A0%E7%A0%81">PUBREC原因码</a></li><li>3.5.2.2 <a href="#3-5-2-2-PUBREC%E5%B1%9E%E6%80%A7%E9%9B%86">PUBREC属性集</a><ul><li>3.5.2.2.1 <a href="#3-5-2-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.5.2.2.2 <a href="#3-5-2-2-2-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.5.2.2.3 <a href="#3-5-2-2-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.5.3 <a href="#3-5-3-PUBREC%E8%BD%BD%E8%8D%B7">PUBREC载荷</a></li><li>3.5.4 <a href="#3-5-4-PUBREC%E5%8A%A8%E4%BD%9C">PUBREC动作</a></li></ul></li><li>3.6 <a href="#3-6-PUBREL-%E5%8F%91%E5%B8%83%E9%87%8A%E6%94%BE%EF%BC%88QoS-2-%E4%BA%A4%E4%BB%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89">PUBREL - 发布释放（QoS-2-交付第二部分）</a><ul><li>3.6.1 <a href="#3-6-1-PUBREL%E5%9B%BA%E5%AE%9A%E5%A4%B4">PUBREL固定头</a></li><li>3.6.2 <a href="#3-6-2-PUBREL%E5%8F%AF%E5%8F%98%E5%A4%B4">PUBREL可变头</a><ul><li>3.6.2.1 <a href="#3-6-2-1-PUBREL%E5%8E%9F%E5%9B%A0%E7%A0%81">PUBREL原因码</a></li><li>3.6.2.2 <a href="#3-6-2-2-PUBREL%E5%B1%9E%E6%80%A7%E9%9B%86">PUBREL属性集</a><ul><li>3.6.2.2.1 <a href="#3-6-2-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.6.2.2.2 <a href="#3-6-2-2-2-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.6.2.2.3 <a href="#3-6-2-2-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.6.3 <a href="#3-6-3-PUBREL%E8%BD%BD%E8%8D%B7">PUBREL载荷</a></li><li>3.6.4 <a href="#3-6-4-PUBREL%E5%8A%A8%E4%BD%9C">PUBREL动作</a></li></ul></li><li>3.7 <a href="#3-7-PUBCOMP-%E5%8F%91%E5%B8%83%E5%AE%8C%E6%88%90%EF%BC%88QoS-2-%E4%BA%A4%E4%BB%98%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%89">PUBCOMP - 发布完成（QoS-2-交付第三部分）</a><ul><li>3.7.1 <a href="#3-7-1-PUBCOMP%E5%9B%BA%E5%AE%9A%E5%A4%B4">PUBCOMP固定头</a></li><li>3.7.2 <a href="#3-7-2-PUBCOMP%E5%8F%AF%E5%8F%98%E5%A4%B4">PUBCOMP可变头</a><ul><li>3.7.2.1 <a href="#3-7-2-1-PUBCOMP%E5%8E%9F%E5%9B%A0%E7%A0%81">PUBCOMP原因码</a></li><li>3.7.2.2 <a href="#3-7-2-2-PUBCOMP%E5%B1%9E%E6%80%A7%E9%9B%86">PUBCOMP属性集</a><ul><li>3.7.2.2.1 <a href="#3-7-2-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.7.2.2.2 <a href="#3-7-2-2-2-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.7.2.2.3 <a href="#3-7-2-2-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.7.3 <a href="#3-7-3-PUBCOMP%E8%BD%BD%E8%8D%B7">PUBCOMP载荷</a></li><li>3.7.4 <a href="#3-7-4-PUBCOMP%E5%8A%A8%E4%BD%9C">PUBCOMP动作</a></li></ul></li><li>3.8 <a href="#3-8-SUBSCRIBE-%E8%AE%A2%E9%98%85%E8%AF%B7%E6%B1%82">SUBSCRIBE - 订阅请求</a><ul><li>3.8.1 <a href="#3-8-1-SUBSCRIBE%E5%9B%BA%E5%AE%9A%E5%A4%B4">SUBSCRIBE固定头</a></li><li>3.8.2 <a href="#3-8-2-SUBSCRIBE%E5%8F%AF%E5%8F%98%E5%A4%B4">SUBSCRIBE可变头</a><ul><li>3.8.2.1 <a href="#3-8-2-1-SUBSCRIBE%E5%B1%9E%E6%80%A7%E9%9B%86">SUBSCRIBE属性集</a><ul><li>3.8.2.1.1 <a href="#3-8-2-1-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.8.2.1.2 <a href="#3-8-2-1-2-%E8%AE%A2%E9%98%85ID">订阅ID</a></li><li>3.8.2.1.3 <a href="#3-8-2-1-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.8.3 <a href="#3-8-3-SUBSCRIBE%E8%BD%BD%E8%8D%B7">SUBSCRIBE载荷</a><ul><li>3.8.3.1 <a href="#3-8-3-1-%E8%AE%A2%E9%98%85%E9%80%89%E9%A1%B9">订阅选项</a></li></ul></li><li>3.8.4 <a href="#3-8-4-SUBSCRIBE%E5%8A%A8%E4%BD%9C">SUBSCRIBE动作</a></li></ul></li><li>3.9 <a href="#3-9-SUBACK-%E2%80%93-%E8%AE%A2%E9%98%85%E7%A1%AE%E8%AE%A4">SUBACK - 订阅确认</a><ul><li>3.9.1 <a href="#3-9-1-SUBACK%E5%9B%BA%E5%AE%9A%E5%A4%B4">SUBACK固定头</a></li><li>3.9.2 <a href="#3-9-2-SUBACK%E5%8F%AF%E5%8F%98%E5%A4%B4">SUBACK可变头</a><ul><li>3.9.2.1 <a href="#3-9-2-1-SUBACK%E5%B1%9E%E6%80%A7%E9%9B%86">SUBACK属性集</a><ul><li>3.9.2.1.1 <a href="#3-9-2-1-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.9.2.1.2 <a href="#3-9-2-1-2-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.9.2.1.3 <a href="#3-9-2-1-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.9.3 <a href="#3-9-3-SUBACK%E8%BD%BD%E8%8D%B7">SUBACK载荷</a></li></ul></li><li>3.10 <a href="#3-10-UNSUBSCRIBE-%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85%E8%AF%B7%E6%B1%82">UNSUBSCRIBE - 取消订阅请求</a><ul><li>3.10.1 <a href="#3-10-1-UNSUBSCRIBE%E5%9B%BA%E5%AE%9A%E5%A4%B4">UNSUBSCRIBE固定头</a></li><li>3.10.2 <a href="#3-10-2-UNSUBSCRIBE%E5%8F%AF%E5%8F%98%E5%A4%B4">UNSUBSCRIBE可变头</a><ul><li>3.10.2.1 <a href="#3-10-2-1-UNSUBSCRIBE%E5%B1%9E%E6%80%A7%E9%9B%86">UNSUBSCRIBE属性集</a><ul><li>3.10.2.1.1 <a href="#3-10-2-1-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.10.2.1.2 <a href="#3-10-2-1-2-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.10.3 <a href="#3-10-3-UNSUBSCRIBE%E8%BD%BD%E8%8D%B7">UNSUBSCRIBE载荷</a></li><li>3.10.4 <a href="#3-10-4-UNSUBSCRIBE%E5%8A%A8%E4%BD%9C">UNSUBSCRIBE动作</a></li></ul></li><li>3.11 <a href="#3-11-UNSUBACK-%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85%E7%A1%AE%E8%AE%A4">UNSUBACK - 取消订阅确认</a><ul><li>3.11.1 <a href="#3-11-1-UNSUBACK%E5%9B%BA%E5%AE%9A%E5%A4%B4">UNSUBACK固定头</a></li><li>3.11.2 <a href="#3-11-2-UNSUBACK%E5%8F%AF%E5%8F%98%E5%A4%B4">UNSUBACK可变头</a><ul><li>3.11.2.1 <a href="#3-11-2-1-UNSUBACK%E5%B1%9E%E6%80%A7%E9%9B%86">UNSUBACK属性集</a><ul><li>3.11.2.1.1 <a href="#3-11-2-1-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.11.2.1.2 <a href="#3-11-2-1-2-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.11.2.1.3 <a href="#3-11-2-1-3-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.11.3 <a href="#3-11-3-UNSUBACK%E8%BD%BD%E8%8D%B7">UNSUBACK载荷</a></li></ul></li><li>3.12 <a href="#3-12-PINGREQ-PING%E8%AF%B7%E6%B1%82">PINGREQ - PING请求</a><ul><li>3.12.1 <a href="#3-12-1-PINGREQ%E5%9B%BA%E5%AE%9A%E5%A4%B4">PINGREQ固定头</a></li><li>3.12.2 <a href="#3-12-2-PINGREQ%E5%8F%AF%E5%8F%98%E5%A4%B4">PINGREQ可变头</a></li><li>3.12.3 <a href="#3-12-3-PINGREQ%E8%BD%BD%E8%8D%B7">PINGREQ载荷</a></li><li>3.12.4 <a href="#3-12-4-PINGREQ%E5%8A%A8%E4%BD%9C">PINGREQ动作</a></li></ul></li><li>3.13 <a href="#3-13-PINGRESP-PING%E5%93%8D%E5%BA%94">PINGRESP - PING响应</a><ul><li>3.13.1 <a href="#3-13-1-PINGRESP%E5%9B%BA%E5%AE%9A%E5%A4%B4">PINGRESP固定头</a></li><li>3.13.2 <a href="#3-13-2-PINGRESP%E5%8F%AF%E5%8F%98%E5%A4%B4">PINGRESP可变头</a></li><li>3.13.3 <a href="#3-13-3-PINGRESP%E8%BD%BD%E8%8D%B7">PINGRESP载荷</a></li><li>3.13.4 <a href="#3-13-4-PINGRESP%E5%8A%A8%E4%BD%9C">PINGRESP动作</a></li></ul></li><li>3.14 <a href="#3-14-DISCONNECT-%E6%96%AD%E5%BC%80%E9%80%9A%E7%9F%A5">DISCONNECT - 断开通知</a><ul><li>3.14.1 <a href="#3-14-1-DISCONNECT%E5%9B%BA%E5%AE%9A%E5%A4%B4">DISCONNECT固定头</a></li><li>3.14.2 <a href="#3-14-2-DISCONNECT%E5%8F%AF%E5%8F%98%E5%A4%B4">DISCONNECT可变头</a><ul><li>3.14.2.1 <a href="#3-14-2-1-%E6%96%AD%E5%BC%80%E5%8E%9F%E5%9B%A0%E7%A0%81">断开原因码</a></li><li>3.14.2.2 <a href="#3-14-2-2-DISCONNECT%E5%B1%9E%E6%80%A7%E9%9B%86">DISCONNECT属性集</a><ul><li>3.14.2.2.1 <a href="#3-14-2-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.14.2.2.2 <a href="#3-14-2-2-2-%E4%BC%9A%E8%AF%9D%E8%BF%87%E6%9C%9F%E9%97%B4%E9%9A%94">会话过期间隔</a></li><li>3.14.2.2.3 <a href="#3-14-2-2-3-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.14.2.2.4 <a href="#3-14-2-2-4-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li><li>3.14.2.2.5 <a href="#3-14-2-2-5-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8">服务引用</a></li></ul></li></ul></li><li>3.14.3 <a href="#3-14-3-DISCONNECT%E8%BD%BD%E8%8D%B7">DISCONNECT载荷</a></li><li>3.14.4 <a href="#3-14-4-DISCONNECT%E5%8A%A8%E4%BD%9C">DISCONNECT动作</a></li></ul></li><li>3.15 <a href="#3-15-AUTH-%E8%AE%A4%E8%AF%81%E4%BA%A4%E6%8D%A2">AUTH - 认证交换</a><ul><li>3.15.1 <a href="#3-15-1-AUTH%E5%9B%BA%E5%AE%9A%E5%A4%B4">AUTH固定头</a></li><li>3.15.2 <a href="#3-15-2-AUTH%E5%8F%AF%E5%8F%98%E5%A4%B4">AUTH可变头</a><ul><li>3.15.2.1 <a href="#3-15-2-1-%E8%AE%A4%E8%AF%81%E5%8E%9F%E5%9B%A0%E7%A0%81">认证原因码</a></li><li>3.15.2.2 <a href="#3-15-2-2-AUTH%E5%B1%9E%E6%80%A7%E9%9B%86">AUTH属性集</a><ul><li>3.15.2.2.1 <a href="#3-15-2-2-1-%E5%B1%9E%E6%80%A7%E9%95%BF%E5%BA%A6">属性长度</a></li><li>3.15.2.2.2 <a href="#3-15-2-2-2-%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F">认证方式</a></li><li>3.15.2.2.3 <a href="#3-15-2-2-3-%E8%AE%A4%E8%AF%81%E6%95%B0%E6%8D%AE">认证数据</a></li><li>3.15.2.2.4 <a href="#3-15-2-2-4-%E5%8E%9F%E5%9B%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">原因字符串</a></li><li>3.15.2.2.5 <a href="#3-15-2-2-5-%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7">用户属性</a></li></ul></li></ul></li><li>3.15.3 <a href="#3-15-3-AUTH%E8%BD%BD%E8%8D%B7">AUTH载荷</a></li><li>3.15.4 <a href="#3-15-3-AUTH%E5%8A%A8%E4%BD%9C">AUTH动作</a></li></ul></li></ul></li><li>4 <a href="#4-%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA">操作行为</a><ul><li>4.1 <a href="#4-1-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">会话状态</a><ul><li>4.1.1 <a href="#4-1-1-%E5%AD%98%E5%82%A8%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">存储会话状态</a></li><li>4.1.2 <a href="#4-1-2-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%E7%A4%BA%E4%BE%8B">会话状态非规范性示例</a></li></ul></li><li>4.2 <a href="#4-2-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">网络连接</a></li><li>4.3 <a href="#4-3-QoS%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B">QoS和协议流程</a><ul><li>4.3.1 <a href="#4-3-1-QoS-0%EF%BC%9A%E8%87%B3%E5%A4%9A%E4%B8%80%E6%AC%A1">QoS 0：至多一次</a></li><li>4.3.2 <a href="#4-3-2-Qos-1%EF%BC%9A%E8%87%B3%E5%B0%91%E4%B8%80%E6%AC%A1">Qos-1：至少一次</a></li><li>4.3.3 <a href="#4-3-3-Qos-2%EF%BC%9A%E7%A1%AE%E4%BF%9D%E4%B8%80%E6%AC%A1">QoS 2：确保一次</a></li></ul></li><li>4.4 <a href="#4-4-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%87%8D%E8%AF%95">消息传递重试</a></li><li>4.5 <a href="#4-5-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6">消息接收</a></li><li>4.6 <a href="#4-6-%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F">消息顺序</a></li><li>4.7 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">主题名和主题过滤器</a><ul><li>4.7.1 <a href="#4-7-1-%E4%B8%BB%E9%A2%98%E9%80%9A%E9%85%8D%E7%AC%A6">主题通配符</a><ul><li>4.7.1.1 <a href="#4-7-1-1-%E4%B8%BB%E9%A2%98%E7%BA%A7%E5%88%AB%E5%88%86%E9%9A%94%E7%AC%A6">主题级别分隔符</a></li><li>4.7.1.2 <a href="#4-7-1-2-%E5%A4%9A%E7%BA%A7%E9%80%9A%E9%85%8D%E7%AC%A6">多级通配符</a></li><li>4.7.1.3 <a href="#4-7-1-3-%E5%8D%95%E7%BA%A7%E9%80%9A%E9%85%8D%E7%AC%A6">单级通配符</a></li></ul></li><li>4.7.2 <a href="#4-7-2-%E5%BC%80%E5%A4%B4%E7%9A%84%E4%B8%BB%E9%A2%98">$开头的主题</a></li><li>4.7.3 <a href="#4-7-3-%E4%B8%BB%E9%A2%98%E8%AF%AD%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">主题语义和使用</a></li></ul></li><li>4.8 <a href="#4-8-%E8%AE%A2%E9%98%85">订阅</a><ul><li>4.8.1 <a href="#4-8-1-%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85">非共享订阅</a></li><li>4.8.2 <a href="#4-8-2-%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85">共享订阅</a></li></ul></li><li>4.9 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></li><li>4.10 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">请求 &#x2F; 响应</a><ul><li>4.10.1 <a href="#4-10-1-%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">基础请求响应（非规范性）</a></li><li>4.10.2 <a href="#4-10-2-%E7%A1%AE%E5%AE%9A%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98%E7%9A%84%E5%80%BC%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">确定响应主题的值（非规范性）</a></li></ul></li><li>4.11 <a href="#4-11-%E6%9C%8D%E5%8A%A1%E9%87%8D%E5%AE%9A%E5%90%91">服务重定向</a></li><li>4.12 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">增强认证</a><ul><li>4.12.1 <a href="#4-12-1-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%81">重新认证</a></li></ul></li><li>4.13 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a><ul><li>4.13.1 <a href="#4-13-1-%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%85%E5%92%8C%E5%8D%8F%E8%AE%AE%E9%94%99%E8%AF%AF">格式错误的包和协议错误</a></li><li>4.13.2 <a href="#4-13-2-%E5%85%B6%E4%BB%96%E9%94%99%E8%AF%AF">其他错误</a></li></ul></li></ul></li><li>5 <a href="#5-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">安全性（非规范性）</a><ul><li>5.1 <a href="#5-1-%E4%BB%8B%E7%BB%8D">介绍</a></li><li>5.2 <a href="#5-2-MQTT%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81">MQTT解决方案：安全和认证</a></li><li>5.3 <a href="#5-3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%86%E7%A0%81%E5%AD%A6%E5%92%8C%E5%8F%97%E9%99%90%E8%AE%BE%E5%A4%87">轻量级密码学和受限设备</a></li><li>5.4 <a href="#5-4-%E5%AE%9E%E6%96%BD%E8%AF%B4%E6%98%8E">实施说明</a><ul><li>5.4.1 <a href="#5-4-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">服务器对客户端进行身份验证</a></li><li>5.4.2 <a href="#5-4-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83">服务器对客户端进行授权</a></li><li>5.4.3 <a href="#5-4-3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">客户端对服务器进行身份验证</a></li><li>5.4.4 <a href="#5-4-4-%E5%BA%94%E7%94%A8%E6%B6%88%E6%81%AF%E5%92%8CMQTT%E5%8C%85%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">应用消息和MQTT包的完整性</a></li><li>5.4.5 <a href="#5-4-5-%E5%BA%94%E7%94%A8%E6%B6%88%E6%81%AF%E5%92%8CMQTT%E5%8C%85%E7%9A%84%E9%9A%90%E7%A7%81">应用消息和MQTT包的隐私</a></li><li>5.4.6 <a href="#5-4-6-%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%90%A6%E8%AE%A4%E6%80%A7">消息传输的不可否认性</a></li><li>5.4.7 <a href="#5-4-7-%E6%A3%80%E6%B5%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E8%A2%AB%E5%85%A5%E4%BE%B5">检测客户端和服务器是否被入侵</a></li><li>5.4.8 <a href="#5-4-8-%E6%A3%80%E6%B5%8B%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA">检测异常行为</a></li><li>5.4.9 <a href="#5-4-9-%E5%A4%84%E7%90%86%E7%A6%81%E6%AD%A2%E7%9A%84Unicode%E7%A0%81%E6%AE%B5">处理禁止的Unicode码段</a><ul><li>5.4.9.1 <a href="#5-4-9-1-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E7%A6%81%E6%AD%A2%E7%9A%84Unicode%E7%A0%81%E6%AE%B5%E7%9A%84%E8%80%83%E8%99%91">关于使用禁止的Unicode码段的考虑</a></li><li>5.4.9.2 <a href="#5-4-9-2-%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92">发布者和订阅者之间的交互</a></li><li>5.4.9.3 <a href="#5-4-9-3-%E8%A1%A5%E6%95%91%E6%8E%AA%E6%96%BD">补救措施</a></li></ul></li><li>5.4.10 <a href="#5-4-10-%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">其他安全注意事项</a></li><li>5.4.11 <a href="#5-4-11-%E4%BD%BF%E7%94%A8SOCKS%E4%BB%A3%E7%90%86">使用SOCKS代理</a></li><li>5.4.12 <a href="#5-4-12-%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE">安全配置</a><ul><li>5.4.12.1 <a href="#5-4-12-1-%E9%80%8F%E6%98%8E%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE">透明通信配置</a></li><li>5.4.12.2 <a href="#5-4-12-2-%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE">安全网络通信配置</a></li><li>5.4.12.3 <a href="#5-4-12-3-%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93%E9%85%8D%E7%BD%AE">安全传输配置</a></li><li>5.4.12.4 <a href="#5-4-12-4-%E8%A1%8C%E4%B8%9A%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE">行业特定的安全配置</a></li></ul></li></ul></li></ul></li><li>6 <a href="#6-%E4%BD%BF%E7%94%A8WebSocket%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82">使用WebSocket作为传输层</a><ul><li>6.1 <a href="#6-1-IANA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">IANA注意事项</a></li></ul></li><li>7 <a href="#7-%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a><ul><li>7.1 <a href="#7-1-%E4%B8%80%E8%87%B4%E6%80%A7%E6%9D%A1%E6%AC%BE">一致性条款</a><ul><li>7.1.1 <a href="#7-1-1-MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E8%87%B4%E6%80%A7%E6%9D%A1%E6%AC%BE">MQTT服务器一致性条款</a></li><li>7.1.2 <a href="#7-1-2-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E6%9D%A1%E6%AC%BE">MQTT客户端一致性条款</a></li></ul></li></ul></li><li>附录 A. <a href="#%E9%99%84%E5%BD%95-A-%E8%87%B4%E8%B0%A2">致谢</a></li><li>附录 B. <a href="#%E9%99%84%E5%BD%95-B-%E5%BC%BA%E5%88%B6%E6%80%A7%E8%A7%84%E8%8C%83%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">强制性规范性声明（非规范性）</a></li><li>附录 C. <a href="#%E9%99%84%E5%BD%95-C-MQTT-v5-0-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">MQTT v5.0 新特性汇总（非规范性）</a></li></ul><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><h2 id="1-0-知识产权政策"><a href="#1-0-知识产权政策" class="headerlink" title="1.0 知识产权政策"></a>1.0 知识产权政策</h2><p>本规范是在 OASIS <a href="https://www.oasis-open.org/policies-guidelines/ipr">知识产权政策</a>的 <a href="https://www.oasis-open.org/policies-guidelines/ipr#Non-Assertion-Mode">Non-Assertion</a>模式下提供的，该模式是技术委员会成立时选择的。关于是否有实施本规范依赖的已经披露的专利信息或是关于任何专利许可条款的信息，请参考技术委员会网站中的知识产权部分(<a href="https://www.oasis-open.org/committees/mqtt/ipr.php)%E3%80%82">https://www.oasis-open.org/committees/mqtt/ipr.php)。</a></p><h2 id="1-1-MQTT规范结构"><a href="#1-1-MQTT规范结构" class="headerlink" title="1.1 MQTT规范结构"></a>1.1 MQTT规范结构</h2><p>本规范分为七个章节：</p><ul><li>第一章 - <a href="#1-%E4%BB%8B%E7%BB%8D">介绍</a></li><li>第二章 - <a href="#2-MQTT%E5%8C%85%E7%BB%93%E6%9E%84">MQTT包格式</a></li><li>第三章 - <a href="#3-MQTT%E5%8C%85">MQTT包</a></li><li>第四章 - <a href="#4-%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA">操作行为</a></li><li>第五章 - <a href="#5-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">安全性</a></li><li>第六章 - <a href="#6-%E4%BD%BF%E7%94%A8WebSocket%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82">使用Websocket作为传输层</a></li><li>第七章 - <a href="#7-%E4%B8%80%E8%87%B4%E6%80%A7">一致性目标</a></li></ul><h2 id="1-2-术语表"><a href="#1-2-术语表" class="headerlink" title="1.2 术语表"></a>1.2 术语表</h2><p>本文档中的关键字 **必须(MUST)<strong>，</strong>必须不(MUST NOT)<strong>，</strong>需要(REQUIRED)<strong>，</strong>应该(SHALL)<strong>，</strong>不应该(SHALL NOT)<strong>，</strong>理应(SHOULD)<strong>，</strong>理应不(SHOULD NOT)<strong>，</strong>推荐(RECOMMENDED)<strong>，</strong>可以(MAY)<strong>，和</strong>可选(OPTIONAL)**按照IETF <a href="#1.3-RFC2119">RFC 2119</a>的定义阐释，除非在此类关键字出现的地方明确被标记为非规范性。</p><p><strong>网络连接:</strong></p><p><strong>由 MQTT 使用的传输协议提供的构造。</strong></p><ul><li>他在客户端与服务器之间提供连接。</li><li>他提供了有序、无丢失、双向传输数据流的能力。</li></ul><p>参考 <a href="#4-2-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">4.2 网络连接</a> 中提供的非规范性示例。</p><p><strong>应用消息</strong></p><p>提供应用程序使用的通过MQTT协议携带的消息。当应用消息通过MQTT传输时，他包含载荷，服务质量，属性集合和主题名称。</p><p><span id="1.2-client"><strong>客户端</strong></span></p><p>一个使用了 MQTT 的程序或设备。一个客户端往往：</p><ul><li>打开通往服务器的网络连接</li><li>发布其他客户端可能会感兴趣的应用消息</li><li>通过订阅来接收自己感兴趣的应用消息</li><li>通过取消订阅，不再接收应用消息</li><li>关闭通过服务器的网络连接</li></ul><p><span id="1.2-server"><strong>服务器</strong></span></p><p>一个在发布应用消息的客户端和订阅应用消息的客户端之间充当转发中介的程序或设备。一个服务器往往：</p><ul><li>接收来自客户端的网络连接</li><li>接收客户端发布的应用消息</li><li>处理客户端的订阅和取消订阅请求</li><li>根据客户端的订阅情况匹配转发应用消息</li><li>关闭和客户端的网络连接</li></ul><p><strong>会话</strong></p><p>服务器和客户端之间的有状态交互。有些会话仅和单次网络连接持续一样长的时间，有些会话则能够跨越多次连续的网络断开和连接持续保持。</p><p><strong>订阅</strong></p><p>订阅包括了主题过滤器和最大QoS。订阅只关联到一个会话。一个会话可以包括多个订阅。会话中的每个订阅都拥有一个不同的主题过滤器。</p><p><strong>共享订阅</strong></p><p>共享订阅包括了主题过滤器和最大QoS。共享订阅可以与多个会话关联，以便使用更加宽泛的信息交换模式。匹配到共享订阅的应用消息只会发送到被关联的会话其中之一对应的客户端。一个会话可以同时持有多个共享订阅，也可以同时持有共享订阅和普通订阅。</p><p><strong>通配订阅</strong></p><p>通配订阅指的是主题过滤器中包括了一个或多个通配符的订阅。通配订阅允许此订阅匹配多个主题名。参考 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">4.7</a> 来了解通配符如何在主题过滤器中起作用。</p><p><strong>主题名</strong></p><p>附加到应用消息的文字标签，用于与服务器已知的订阅相匹配。</p><p><strong>主题过滤器</strong></p><p>订阅中包含的一种表达式，用于指示对一个或多个主题的兴趣。主题过滤器可以包含通配符。</p><p><strong>MQTT包</strong></p><p>通过网络连接发送的数据包。MQTT规范定义了十五中不同类型的MQTT包，例如 <code>发布</code> 包用来承载应用消息。</p><p><strong>格式错误的包</strong></p><p>一个不能通过本规范解析的数据包。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><p><strong>协议错误</strong></p><p>数据包被解析后发现的不符合协议规范的数据内容或客户端与服务器状态不一致的数据。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><p><strong>遗嘱</strong></p><p>当网络连接非正常关闭后，由服务器发布的应用消息。参考 <a href="#3-1-2-5-%E9%81%97%E5%98%B1%E6%A0%87%E8%AF%86">3.1.2.5</a> 查看关于遗嘱的消息。</p><p><strong>禁止的 Unicode 码段</strong></p><p>在 UTF-8 字符串中不应出现的 Unicode 控制代码和 Unicode 非字符集。参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> 查看更多关于禁止的 Unicode 码段的信息。</p><h2 id="1-3-规范性引用"><a href="#1-3-规范性引用" class="headerlink" title="1.3 规范性引用"></a>1.3 规范性引用</h2><p><span id="1.3-RFC2119" class="bold">[RFC2119]</span></p><p>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, DOI 10.17487&#x2F;RFC2119, March 1997,</p><p><a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a></p><p><span id="1.3-RFC3629" class="bold">[RFC3629]</span></p><p>Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, RFC 3629, DOI 10.17487&#x2F;RFC3629, November 2003,</p><p><a href="http://www.rfc-editor.org/info/rfc3629">http://www.rfc-editor.org/info/rfc3629</a></p><p><span id="1.3-RFC6455" class="bold">[RFC6455]</span></p><p>Fette, I. and A. Melnikov, “The WebSocket Protocol”, RFC 6455, DOI 10.17487&#x2F;RFC6455, December 2011,</p><p><a href="http://www.rfc-editor.org/info/rfc6455">http://www.rfc-editor.org/info/rfc6455</a></p><p><span id="1.3-Unicode" class="bold">[Unicode]</span></p><p>The Unicode Consortium. The Unicode Standard,</p><p><a href="http://www.unicode.org/versions/latest/">http://www.unicode.org/versions/latest/</a></p><h2 id="1-4-非规范性引用"><a href="#1-4-非规范性引用" class="headerlink" title="1.4 非规范性引用"></a>1.4 非规范性引用</h2><p><span id="1.4-RFC0793" class="bold">[RFC0793]</span></p><p>Postel, J., “Transmission Control Protocol”, STD 7, RFC 793, DOI 10.17487&#x2F;RFC0793, September 1981, <a href="http://www.rfc-editor.org/info/rfc793">http://www.rfc-editor.org/info/rfc793</a></p><p><span id="1.4-RFC5246" class="bold">[RFC5246]</span></p><p>Dierks, T. and E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.2”, RFC 5246, DOI 10.17487&#x2F;RFC5246, August 2008,</p><p><a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a></p><p><span id="1.4-AES" class="bold">[AES]</span></p><p>Advanced Encryption Standard (AES) (FIPS PUB 197).</p><p><a href="https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf">https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf</a></p><p><span id="1.4-CHACHA20" class="bold">[CHACHA20]</span></p><p>ChaCha20 and Poly1305 for IETF Protocols</p><p><a href="https://tools.ietf.org/html/rfc7539">https://tools.ietf.org/html/rfc7539</a></p><p><span id="1.4-FIPS1402" class="bold">[FIPS1402]</span></p><p>Security Requirements for Cryptographic Modules (FIPS PUB 140-2)</p><p><a href="https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf">https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf</a></p><p><span id="1.4-IEEE 802.1AR" class="bold">[IEEE 802.1AR]</span></p><p>IEEE Standard for Local and metropolitan area networks - Secure Device Identity</p><p><a href="http://standards.ieee.org/findstds/standard/802.1AR-2009.html">http://standards.ieee.org/findstds/standard/802.1AR-2009.html</a></p><p><span id="1.4-ISO29192" class="bold">[ISO29192]</span></p><p>ISO&#x2F;IEC 29192-1:2012 Information technology – Security techniques – Lightweight cryptography – Part 1: General</p><p><a href="https://www.iso.org/standard/56425.html">https://www.iso.org/standard/56425.html</a></p><p><span id="1.4-MQTT NIST" class="bold">[MQTT NIST]</span></p><p>MQTT supplemental publication, MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity</p><p><a href="http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html">http://docs.oasis-open.org/mqtt/mqtt-nist-cybersecurity/v1.0/mqtt-nist-cybersecurity-v1.0.html</a></p><p><span id="1.4-MQTTV311" class="bold">[MQTTV311]</span></p><p>MQTT V3.1.1 Protocol Specification</p><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p><p><span id="1.4-ISO20922" class="bold">[ISO20922]</span></p><p>MQTT V3.1.1 ISO Standard (ISO&#x2F;IEC 20922:2016)</p><p><a href="https://www.iso.org/standard/69466.html">https://www.iso.org/standard/69466.html</a></p><p><span id="1.4-NISTCSF" class="bold">[NISTCSF]</span></p><p>Improving Critical Infrastructure Cybersecurity Executive Order 13636</p><p><a href="https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf">https://www.nist.gov/sites/default/files/documents/itl/preliminary-cybersecurity-framework.pdf</a></p><p><span id="1.4-NIST7628" class="bold">[NIST7628]</span></p><p>NISTIR 7628 Guidelines for Smart Grid Cyber Security Catalogue</p><p><a href="https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf">https://www.nist.gov/sites/default/files/documents/smartgrid/nistir-7628_total.pdf</a></p><p><span id="1.4-NSAB" class="bold">[NSAB]</span></p><p>NSA Suite B Cryptography</p><p><a href="http://www.nsa.gov/ia/programs/suiteb_cryptography/">http://www.nsa.gov/ia/programs/suiteb_cryptography/</a></p><p><span id="1.4-PCIDSS" class="bold">[PCIDSS]</span></p><p>PCI-DSS Payment Card Industry Data Security Standard</p><p><a href="https://www.pcisecuritystandards.org/pci_security/">https://www.pcisecuritystandards.org/pci_security/</a></p><p><span id="1.4-RFC1928" class="bold">[RFC1928]</span></p><p>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, “SOCKS Protocol Version 5”, RFC 1928, DOI 10.17487&#x2F;RFC1928, March 1996,</p><p><a href="http://www.rfc-editor.org/info/rfc1928">http://www.rfc-editor.org/info/rfc1928</a></p><p><span id="1.4-RFC4511" class="bold">[RFC4511]</span></p><p>Sermersheim, J., Ed., “Lightweight Directory Access Protocol (LDAP): The Protocol”, RFC 4511, DOI 10.17487&#x2F;RFC4511, June 2006,</p><p><a href="http://www.rfc-editor.org/info/rfc4511">http://www.rfc-editor.org/info/rfc4511</a></p><p><span id="1.4-RFC5280" class="bold">[RFC5280]</span></p><p>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, “Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile”, RFC 5280, DOI 10.17487&#x2F;RFC5280, May 2008,</p><p><a href="http://www.rfc-editor.org/info/rfc5280">http://www.rfc-editor.org/info/rfc5280</a></p><p><span id="1.4-RFC6066" class="bold">[RFC6066]</span></p><p>Eastlake 3rd, D., “Transport Layer Security (TLS) Extensions: Extension Definitions”, RFC 6066, DOI 10.17487&#x2F;RFC6066, January 2011,</p><p><a href="http://www.rfc-editor.org/info/rfc6066">http://www.rfc-editor.org/info/rfc6066</a></p><p><span id="1.4-RFC6749" class="bold">[RFC6749]</span></p><p>Hardt, D., Ed., “The OAuth 2.0 Authorization Framework”, RFC 6749, DOI 10.17487&#x2F;RFC6749, October 2012,</p><p><a href="http://www.rfc-editor.org/info/rfc6749">http://www.rfc-editor.org/info/rfc6749</a></p><p><span id="1.4-RFC6960" class="bold">[RFC6960]</span></p><p>Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, “X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP”, RFC 6960, DOI 10.17487&#x2F;RFC6960, June 2013,</p><p><a href="http://www.rfc-editor.org/info/rfc6960">http://www.rfc-editor.org/info/rfc6960</a></p><p><span id="1.4-SARBANES" class="bold">[SARBANES]</span></p><p>Sarbanes-Oxley Act of 2002.</p><p><a href="http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm">http://www.gpo.gov/fdsys/pkg/PLAW-107publ204/html/PLAW-107publ204.htm</a></p><p><span id="1.4-USEUPRIVSH" class="bold">[USEUPRIVSH]</span></p><p>U.S.-EU Privacy Shield Framework</p><p><a href="https://www.privacyshield.gov/">https://www.privacyshield.gov</a></p><p><span id="1.4-RFC3986" class="bold">[RFC3986]</span></p><p>Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, RFC 3986, DOI 10.17487&#x2F;RFC3986, January 2005,</p><p><a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a></p><p><span id="1.4-RFC1035" class="bold">[RFC1035]</span></p><p>Mockapetris, P., “Domain names - implementation and specification”, STD 13, RFC 1035, DOI 10.17487&#x2F;RFC1035, November 1987,</p><p><a href="http://www.rfc-editor.org/info/rfc1035">http://www.rfc-editor.org/info/rfc1035</a></p><p><span id="1.4-RFC2782" class="bold">[RFC2782]</span></p><p>Gulbrandsen, A., Vixie, P., and L. Esibov, “A DNS RR for specifying the location of services (DNS SRV)”, RFC 2782, DOI 10.17487&#x2F;RFC2782, February 2000,</p><p><a href="http://www.rfc-editor.org/info/rfc2782">http://www.rfc-editor.org/info/rfc2782</a></p><h2 id="1-5-数据表示"><a href="#1-5-数据表示" class="headerlink" title="1.5 数据表示"></a>1.5 数据表示</h2><h3 id="1-5-1-比特位"><a href="#1-5-1-比特位" class="headerlink" title="1.5.1 比特位"></a>1.5.1 比特位</h3><p>字节中的比特位被标记为7-0，最高位为7，最低位为0。</p><h3 id="1-5-2-2字节整数"><a href="#1-5-2-2字节整数" class="headerlink" title="1.5.2 2字节整数"></a>1.5.2 2字节整数</h3><p>2字节整数指16位的大端表示的无符号整数：高位字节在低位字节之前。这意味着在网络中传输的2字节整数先传输高有效字节(MSB)，后传输低有效字节(LSB)。</p><h3 id="1-5-3-4字节整数"><a href="#1-5-3-4字节整数" class="headerlink" title="1.5.3 4字节整数"></a>1.5.3 4字节整数</h3><p>4字节整数指32位的大端表示的无符号整数：高位字节先于连续的低位字节。这意味着在网络中传输的4字节整数先传输最高有效字节(MSB)，再传输次高有效字节(MSB)，再传输次高有效字节(MSB)，最后传输低有效字节(LSB)。</p><h3 id="1-5-4-UTF-8字符串"><a href="#1-5-4-UTF-8字符串" class="headerlink" title="1.5.4 UTF-8字符串"></a>1.5.4 UTF-8字符串</h3><p>MQTT包中使用的文本类型字段均采用 UTF-8 编码。UTF-8 <a href="#1.3-RFC3629">RFC3629</a> 是一种高效的 <a href="#1.3-Unicode">Unicode</a> 编码，他优化了 ACSII 的编码以用来支持基于文本的通信。</p><p>每个 UTF-8 编码的字符串都使用开头的两个字节表示字符串的长度，就像下方的 <span class="vcLinked">图1-1 UTF-8 字符串结构</span> 示意的那样。因此，UTF-8 字符串的最大长度为65535字节。</p><p>除非另有说明，否则所有 UTF-8 编码字符串可以具有 0 到 65,535 字节范围内的任意长度。</p><p>图1-1 UTF-8 字符串结构</p><table>  <thead>    <tr>      <th>Bit</th>      <th>7</th>      <th>6</th>      <th>5</th>      <th>4</th>      <th>3</th>      <th>2</th>      <th>1</th>      <th>0</th>    </tr>  </thead>  <tbody>    <tr>      <td>byte 1</td>      <td colspan="8">字符串长度高字节(MSB)</td>    </tr>    <tr>      <td>byte 2</td>      <td colspan="8">字符串长度低字节(LSB)</td>    </tr>    <tr>      <td>byte 3 ...</td>      <td colspan="8">当长度 > 0 时, UTF-8 编码的字符数据</td>    </tr>  </tbody></table><p><span class="vcMarked">在 UTF-8 编码字符串中的字符<strong>必须</strong>为 <a href="#1.3-Unicode">[Unicode]</a> 和 <a href="#1.3-RFC3629">[RFC3629]</a> 中所定义的，格式正确的字符编码。<strong>必须不</strong>使用U+D800 至 U+DFFF之间的编码</span> <span class="vcReferred">[MQTT-1.5.4-1]</span>。如果客户端或服务器接收到的 MQTT 包中包括了非法 UTF-8 编码，将其视为一个格式错误的包。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><p><span class="vcMarked">UTF-8 编码字符串<strong>必须</strong>不包含空字符 U+0000</span> <span class="vcReferred">[MQTT-1.5.4-2]</span>。如果一个接收者（服务器或客户端）接收的 MQTT 包其中有空字符 U+0000 ，将其视为一个格式错误的包。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><p>数据不应该包括下方列表中的 Unicode 码段，如果一个接收者（服务器或客户端）接受的 MQTT 包其中有此类字符，接收者可以将此包视为一个格式错误的包。这些是禁止使用的 Unicode 码段。参考 <a href="#5-4-9-%E5%A4%84%E7%90%86%E7%A6%81%E6%AD%A2%E7%9A%84Unicode%E7%A0%81%E6%AE%B5">5.4.9</a> 查看关于错误处理的信息。</p><ul><li>U+0001..U+001F 控制字符</li><li>U+007F..U+009F 控制字符</li><li><a href="#1.3-Unicode">Unicode</a> 规范中定义的非文本字符（例如 U+0FFFF）</li></ul><p><span class="vcMarked">无论 UTF-8 编码序列 0xEF 0xBB 0xBF 出现在字符串的何处，他永远被解释为 U+FEFF (0宽无换行空格) 而且<strong>必须</strong>不能被数据包的接收者跳过或剥离</span> <span class="vcReferred">[MQTT-1.5.4-3]</span>。</p><p><strong>非规范性示例</strong></p><p>例如，字符串 A𪛔 的第一个字符是拉丁文大写字母A，第二个字符是码点 U+2A6D4 （代表 CJK IDEOGRAPH EXTENSION B 字符），他是这样编码的：</p><p>图1‑2 UTF-8 编码字符串非规范性示例</p><table>  <thead>    <tr>      <th>Bit</th>      <th>7</th>      <th>6</th>      <th>5</th>      <th>4</th>      <th>3</th>      <th>2</th>      <th>1</th>      <th>0</th>    </tr>  </thead>  <tbody>    <tr>      <td>byte 1</td>      <td colspan="8">字符串长度高字节(MSB)(0x00)</td>    </tr>    <tr>      <td></td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>byte 2</td>      <td colspan="8">字符串长度低字节(LSB)(0x05)</td>    </tr>    <tr>      <td></td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>byte 3</td>      <td colspan="8">‘A’ (0x41)</td>    </tr>    <tr>      <td></td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <td>byte 4</td>      <td colspan="8">(0xF0)</td>    </tr>    <tr>      <td></td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>byte 5</td>      <td colspan="8">(0xAA)</td>    </tr>    <tr>      <td></td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <td>byte 6</td>      <td colspan="8">(0x9B)</td>    </tr>    <tr>      <td></td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <td>byte 7</td>      <td colspan="8">(0x94)</td>    </tr>    <tr>      <td></td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><h3 id="1-5-5-变长整数"><a href="#1-5-5-变长整数" class="headerlink" title="1.5.5 变长整数"></a>1.5.5 变长整数</h3><p>变长整数中将一个字节的最大值视为 127，更大的值采用如下方式处理。每个字节中较低的七位用来存储数字的值，最高位用来表示是否有后续的字节。因此，每个字节都编码了128个可能的值和一个 “后续位”。变长整数的最大字节数是4。<span class="vcMarked">变长整数编码时<strong>必须</strong>使用能够表示数字值的最小长度来进行编码</span> <span class="vcReferred">[MQTT-1.5.5-1]</span>。表1-1 中展示了变长整数可以表示的值。</p><p>表1-1 变长整数的值</p><table><thead><tr><th>位数</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>1</td><td>0 (0x00)</td><td>127 (0x7F)</td></tr><tr><td>2</td><td>128 (0x80, 0x01)</td><td>16,383 (0xFF, 0x7F)</td></tr><tr><td>3</td><td>16,384 (0x80, 0x80, 0x01)</td><td>2,097,151 (0xFF, 0xFF, 0x7F)</td></tr><tr><td>4</td><td>2,097,152 (0x80, 0x80, 0x80, 0x01)</td><td>268,435,455 (0xFF, 0xFF, 0xFF, 0x7F)</td></tr></tbody></table><p><strong>非规范性示例</strong></p><p>将非负整数 X 编码为变长整数的伪代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">do   encodedByte = X MOD 128   X = X DIV 128   // if there are more data to encode, set the top bit of this byte   if (X > 0)      encodedByte = encodedByte OR 128   endif   'output' encodedBytewhile (X > 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上例中的 MOD 表示取模（C语言中的 %），DIV表示整数除法（C语言中的 &#x2F;），OR表示位运算中的或（C语言中的 |）。</p><p><strong>非规范性示例</strong></p><p>解码变长整数的伪代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">multiplier = 1value = 0do   encodedByte = 'next byte from stream'   value += (encodedByte AND 127) * multiplier   if (multiplier > 128*128*128)      throw Error(Malformed Variable Byte Integer)   multiplier *= 128while ((encodedByte AND 128) != 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上例中的 AND 表示位运算中的且（C语言中的 &amp;）。</p><p>当该算法完成时，value的值即是变长整数表示的值。</p><h3 id="1-5-6-二进制数据"><a href="#1-5-6-二进制数据" class="headerlink" title="1.5.6 二进制数据"></a>1.5.6 二进制数据</h3><p>二进制数据由2字节整数表示的字节流长度加上实际的字节流内容组成。因此，二进制数据的长度范围是 0-65535 字节。</p><h3 id="1-5-7-UTF-8字符串对"><a href="#1-5-7-UTF-8字符串对" class="headerlink" title="1.5.7 UTF-8字符串对"></a>1.5.7 UTF-8字符串对</h3><p>UT-8 字符串对包括两个 UTF-8 编码的字符串。这种数据类型用来存储 键-值 对。第一个字符串表示键，第二个字符串表示值。</p><p><span class="vcMarked">UTF-8字符串对中的两个字符串都<strong>必须</strong>遵守 UTF-8 字符串的需求</span> <span class="vcReferred">[MQTT-1.5.7-1]</span>。如果一个接收者（客户端或服务器）接收到的键值对没有遵守这些需求，则被视为一个格式错误的数据包。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><h2 id="1-6-安全性"><a href="#1-6-安全性" class="headerlink" title="1.6 安全性"></a>1.6 安全性</h2><p>MQTT 的客户端和服务器实现应该提供认证、授权和加密传输选项，这一部分在第五章讨论。强烈建议与关键基础设施、个人身份信息或其他个人或敏感信息相关的应用程序使用这些安全功能。</p><h2 id="1-7-编辑约定"><a href="#1-7-编辑约定" class="headerlink" title="1.7 编辑约定"></a>1.7 编辑约定</h2><p>本规范中以<span class="vcMarked">黄色</span>突出显示的文本标识了一致性声明。每个一致性声明都被分配了一个格式为 <span class="vcReferred">[MQTT-x.x.x-y]</span> 的引用，其中 <span class="vcReferred">x.x.x</span> 是章节序号，<span class="vcReferred">y</span> 是章节内的序号。</p><h2 id="1-8-变更历史"><a href="#1-8-变更历史" class="headerlink" title="1.8 变更历史"></a>1.8 变更历史</h2><h3 id="1-8-1-MQTT-v3-1-1"><a href="#1-8-1-MQTT-v3-1-1" class="headerlink" title="1.8.1 MQTT v3.1.1"></a>1.8.1 MQTT v3.1.1</h3><p>MQTT v3.1.1 是 OASIS 提出的第一个 MQTT 标准 <strong>[MQTTV311]</strong> 。</p><p>MQTT v3.1.1 同时也是 ISO&#x2F;IEC 20922:2016 标准 <a href="#1.4-ISO20922">ISO20922</a>。</p><h3 id="1-8-2-MQTT-v5-0"><a href="#1-8-2-MQTT-v5-0" class="headerlink" title="1.8.2 MQTT v5.0"></a>1.8.2 MQTT v5.0</h3><p>MQTT v5.0 为 MQTT 添加了大量新功能，同时保留了大部分核心功能。主要功能目标是：</p><ul><li>可扩展性和大型系统的增强</li><li>改进错误报告能力</li><li>将常见用法规范化，包括功能发现和请求响应</li><li>包括用户属性在内的拓展机制</li><li>性能改进，增强对小型客户端的支持</li></ul><p>参考 <a href="#%E9%99%84%E5%BD%95-C-MQTT-v5-0-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB%EF%BC%88%E9%9D%9E%E8%A7%84%E8%8C%83%E6%80%A7%EF%BC%89">附录 C</a> 查阅 MQTT v5.0 的变更汇总。</p><h1 id="2-MQTT包格式"><a href="#2-MQTT包格式" class="headerlink" title="2 MQTT包格式"></a>2 MQTT包格式</h1><h2 id="2-1-MQTT包结构"><a href="#2-1-MQTT包结构" class="headerlink" title="2.1 MQTT包结构"></a>2.1 MQTT包结构</h2><p>MQTT 协议操作通过一系列的 MQTT 包交互来实现。本章用来描述这些 MQTT 包的结构。</p><p>一个 MQTT 包由三部分构成，顺序固定，参考下图：</p><table>  <tbody>    <tr><td>固定头，所有的 MQTT 包都必须持有</td><tr>    <tr><td>可变头，部分 MQTT 包持有</td></tr>    <tr><td>载荷，部分 MQTT 包持有</td></tr>  </tbody></table><h3 id="2-1-1-固定头"><a href="#2-1-1-固定头" class="headerlink" title="2.1.1 固定头"></a>2.1.1 固定头</h3><p>每个 MQTT 包都包含着一个下图所示的固定头：</p><p>图2-2 固定头格式</p><table>  <thead>    <tr>      <th>Bit</th>      <th>7</th>      <th>6</th>      <th>5</th>      <th>4</th>      <th>3</th>      <th>2</th>      <th>1</th>      <th>0</th>    </tr>  </thead>  <tbody>    <tr>      <td>byte 1</td>      <td colspan="4">MQTT包类型</td>      <td colspan="4">针对不同包类型的控制标识</td>    </tr>    <tr>      <td>byte 2...</td>      <td colspan="8">剩余长度</td>    </tr>  </tbody></table><h3 id="2-1-2-MQTT包类型"><a href="#2-1-2-MQTT包类型" class="headerlink" title="2.1.2 MQTT包类型"></a>2.1.2 MQTT包类型</h3><p><strong>位置：</strong>第一个Byte，比特位7-4。</p><p>表示为 4bit 的无符号整数，数值的含义如下表所示：</p><p>表2-1 MQTT包类型</p><table><thead><tr><th>Name</th><th>Value</th><th>Direction of flow</th><th>Description</th></tr></thead><tbody><tr><td>保留</td><td>0</td><td>禁止</td><td>保留</td></tr><tr><td>CONNECT</td><td>1</td><td>客户端到服务器</td><td>连接请求</td></tr><tr><td>CONNACK</td><td>2</td><td>服务器到客户端</td><td>连接回复</td></tr><tr><td>PUBLISH</td><td>3</td><td>双向</td><td>消息发布</td></tr><tr><td>PUBACK</td><td>4</td><td>双向</td><td>消息回复（QoS1）</td></tr><tr><td>PUBREC</td><td>5</td><td>双向</td><td>消息已接收（QoS2交付第 1 部分）</td></tr><tr><td>PUBREL</td><td>6</td><td>双向</td><td>消息释放（QoS2交付第 2 部分）</td></tr><tr><td>PUBCOMP</td><td>7</td><td>双向</td><td>消息完成（QoS2交付第 3 部分）</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>客户端到服务器</td><td>订阅请求</td></tr><tr><td>SUBACK</td><td>9</td><td>服务器到客户端</td><td>订阅回复</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>客户端到服务器</td><td>取消订阅请求</td></tr><tr><td>UNSUBACK</td><td>11</td><td>服务器到客户端</td><td>取消订阅回复</td></tr><tr><td>PINGREQ</td><td>12</td><td>客户端到服务器</td><td>PING 请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>服务器到客户端</td><td>PING 响应</td></tr><tr><td>DISCONNECT</td><td>14</td><td>双向</td><td>断开连接通知</td></tr><tr><td>AUTH</td><td>15</td><td>双向</td><td>认证交换</td></tr></tbody></table><h3 id="2-1-3-控制标识"><a href="#2-1-3-控制标识" class="headerlink" title="2.1.3 控制标识"></a>2.1.3 控制标识</h3><p>固定头第一个 byte 中剩下的四个bit [3-0]包括了基于不同 MQTT 包类型的控制标识。<span class="vcMarked">当一个比特位被标记为 “保留” 时，他的意义被保留到未来使用而他的值<strong>必须</strong>按照下表设置</span> <span class="vcReferred">[MQTT-2.1.3-1]</span>。如果接收到的控制标志不符合规范，则被认为是一个格式错误的数据包。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><p>表2‑2 控制标志</p><table>  <thead>    <tr>      <td>MQTT包</td>      <td>控制标志</td>      <td>Bit 3</td>      <td>Bit 2</td>      <td>Bit 1</td>      <td>Bit 0</td>    </tr>  </thead>  <tbody>    <tr>      <td>CONNECT</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>CONNACK</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>PUBLISH</td>      <td>MQTT 5.0版本使用</td>      <td>DUP</td>      <td colspan="2">QoS</td>      <td>RETAIN</td>    </tr>    <tr>      <td>PUBACK</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>PUBREC</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>PUBREL</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <td>PUBCOMP</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>SUBSCRIBE</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <td>SUBACK</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>UNSUBSCRIBE</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <td>UNSUBACK</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>PINGREQ</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>PINGRESP</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>DISCONNECT</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <td>AUTH</td>      <td>Reserved</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><p>DUP &#x3D; 重复发送的 PUBLISH 包<br>QoS &#x3D; PUBLISH 包的服务质量标识<br>RETAIN &#x3D; PUBLISH 保留消息标识</p><p>参考 <a href="#3-3-1-PUBLISH-%E5%9B%BA%E5%AE%9A%E5%A4%B4">3.3.1</a> 了解更多关于 DUP，QoS 和 RETAIN 标识在 PUBLISH 中的使用方式。</p><h3 id="2-1-4-剩余长度"><a href="#2-1-4-剩余长度" class="headerlink" title="2.1.4 剩余长度"></a>2.1.4 剩余长度</h3><p><strong>位置：</strong>从第二个Byte开始。</p><p>剩余长度是一个变长整数，用来表示当前包剩余的字节数，包括可变头和载荷。剩余长度的值不包括剩余长度自己本身占用的字节数。一个 MQTT 包完整的字节数等于固定头的长度加上剩余长度的值。</p><h2 id="2-2-可变头"><a href="#2-2-可变头" class="headerlink" title="2.2 可变头"></a>2.2 可变头</h2><p>某些类型的 MQTT 包包含可变头。他位于固定头和载荷之间。可变头的内容根据数据包的类型变化。可变头中的包ID字段多种类型的数据包中都存在。</p><h3 id="2-2-1-包ID"><a href="#2-2-1-包ID" class="headerlink" title="2.2.1 包ID"></a>2.2.1 包ID</h3><p>很多类型的 MQTT 包都在其可变头中包含了 2byte 的包ID字段。这些 MQTT 包是 PUBLISH （当 QoS &gt; 0时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE，SUBACK，UNSUBSCRIBE，UNSUBACK。</p><p>需要包ID的 MQTT 包类型如下表所示：</p><p>表2-3 包含包ID的 MQTT 包类型</p><table><thead><tr><th>MQTT 包</th><th>包ID字段</th></tr></thead><tbody><tr><td>CONNECT</td><td>否</td></tr><tr><td>CONNACK</td><td>否</td></tr><tr><td>PUBLISH</td><td>是（仅当 QoS &gt; 0 时）</td></tr><tr><td>PUBACK</td><td>是</td></tr><tr><td>PUBREC</td><td>是</td></tr><tr><td>PUBREL</td><td>是</td></tr><tr><td>PUBCOMP</td><td>是</td></tr><tr><td>SUBSCRIBE</td><td>是</td></tr><tr><td>SUBACK</td><td>是</td></tr><tr><td>UNSUBSCRIBE</td><td>是</td></tr><tr><td>UNSUBACK</td><td>是</td></tr><tr><td>PINGREQ</td><td>否</td></tr><tr><td>PINGRESP</td><td>否</td></tr><tr><td>DISCONNECT</td><td>否</td></tr><tr><td>AUTH</td><td>否</td></tr></tbody></table><p><span class="vcMarked">当 PUBLISH 包的 QoS 值为 0 时，<strong>必须不</strong>包含 包ID 字段</span> <span class="vcReferred">[MQTT-2.2.1-2]</span>。</p><p><span class="vcMarked">每当客户端发送新的 SUBSCRIBE 包，UNSUBSCRIBE 包 或 QoS &gt; 0 的 PUBLISH 包，<strong>必须</strong>携带一个非零且当前未被使用的包ID</span> <span class="vcReferred">[MQTT-2.2.1-3]</span>。</p><p><span class="vcMarked">每当服务器发送新的 QoS &gt; 0 的 PUBLISH 包，<strong>必须</strong>携带一个非零且当前未被使用的包ID</span> <span class="vcReferred">[MQTT-2.2.1-4]</span>。</p><p>包ID仅在发送者处理了对应的回复后可重新使用，定义如下。对于 QoS &#x3D; 1 的 PUBLISH，对应的回复是 PUBACK；对于 QoS &#x3D; 2 的PUBLISH，对应的回复是 PUBCOMP 或当原因码为 128 或更大时为 PUBREC。对于 SUBSCRIBE 或 UNSUBSCRIBE，对应的回复是 SUBACK 或 UNSUBACK。</p><p>在一个会话中，客户端与服务器分别使用一个单独、统一的集合用作提供 PUBLISH、SUBSCRIBE 和 UNSUBSCRIBE 的包ID。包ID在任何时候都不能被多个命令使用。</p><p><span class="vcMarked">PUBACK，PUBREC，PUBREL 或 PUBCOMP 包<strong>必须</strong>携带和 PUBLISH 相同的包ID</span> <span class="vcReferred">[MQTT-2.2.1-5]</span>。<span class="vcMarked">SUBACK 和 UNSUBACK <strong>必须</strong>携带和其对应的 SUBSCRIBE 和 UNSUBSCRIBE 包相同的包ID</span> <span class="vcReferred">[MQTT-2.2.1-6]</span>。</p><p>客户端与服务器各自独立的维护包ID分配。因此，客户端与服务器可以同时使用同样的包ID发送信息。</p><p><strong>非规范性示例</strong></p><p>客户端发送一个包ID为 0x1234 的 PUBLISH 包，之后在其接收到对应的 PUBACK 之前，从服务器接收到一个 包ID 为 0x1234 的 PUBLISH 包。这样的情况是合理而且完全有可能的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">Client                                                   ServerPUBLISH 包ID=0x1234 ‒→                                                    ←‒ PUBLISH 包ID=0x1234PUBACK 包ID=0x1234 ‒→                                                    ←‒ PUBACK 包ID=0x1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-2-2-属性集"><a href="#2-2-2-属性集" class="headerlink" title="2.2.2 属性集"></a>2.2.2 属性集</h3><p>在 CONNECT，CONNACK，PUBLISH，PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE，SUBACK，UNSUBSCRIBE，UNSUBACK，DISCONNECT 和 AUTH 包的可变头中的最后一个字段是属性集。在 CONNECT 的载荷中也存在着一组可选的遗嘱属性集。</p><p>属性集由属性长度和属性组成。</p><h4 id="2-2-2-1-属性长度"><a href="#2-2-2-1-属性长度" class="headerlink" title="2.2.2.1 属性长度"></a>2.2.2.1 属性长度</h4><p>属性长度是一个变长整数。属性长度的值不包括自己所占用的字节数，但包括了后续所有属性占用的字节数。<span class="vcMarked">如果没有属性，<strong>必须</strong>通过一个 0 值的属性长度来明确表示</span> <span class="vcReferred">[MQTT-2.2.2-1]</span>。</p><h4 id="2-2-2-2-属性"><a href="#2-2-2-2-属性" class="headerlink" title="2.2.2.2 属性"></a>2.2.2.2 属性</h4><p>属性由一个标识了其用途和数据类型的ID和一个后续的值组成。属性ID是一个变长整数。当一个数据包使用的属性ID和其包类型不一致，或属性的值和ID指明的类型不一致时，视为一个格式错误的包。如果收到，需使用带有原因码为 0x81 的 CONNACK 或 DISCONNECT 数据包，采用 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 描述的方法处理此错误。不同ID的属性没有顺序要求。</p><p>表2-4 属性</p><table>  <thead>    <tr>      <th colspan="2">ID</th>      <th rowspan="2">名称（用途）</th>      <th rowspan="2">数据类型</th>      <th rowspan="2">包类型 / 遗嘱属性</th>    </tr>    <tr>      <th>十进制</th><th>十六进制</th>    </tr>  </thead>  <tbody>    <tr><td>1</td><td>0x01</td><td>载荷格式标识</td><td>单字节</td><td>PUBLISH，Will Properties</td></tr>    <tr><td>2</td><td>0x02</td><td>消息过期间隔</td><td>4字节整数</td><td>PUBLISH，Will Properties</td></tr>    <tr><td>3</td><td>0x03</td><td>内容类型</td><td>UTF-8字符串</td><td>PUBLISH，Will Properties</td></tr>    <tr><td>8</td><td>0x08</td><td>响应主题</td><td>UTF-8字符串</td><td>PUBLISH，Will Properties</td></tr>    <tr><td>9</td><td>0x09</td><td>关联数据</td><td>二进制数据</td><td>PUBLISH，Will Properties</td></tr>    <tr><td>11</td><td>0x0B</td><td>订阅ID</td><td>变长整数</td><td>PUBLISH，SUBSCRIBE</td></tr>    <tr><td>17</td><td>0x11</td><td>会话过期间隔</td><td>4字节整数</td><td>CONNECT，CONNACK，DISCONNECT</td></tr>    <tr><td>18</td><td>0x12</td><td>分配的客户端ID</td><td>UTF-8字符串</td><td>CONNACK</td></tr>    <tr><td>19</td><td>0x13</td><td>服务器保活时间</td><td>2字节整数</td><td>CONNACK</td></tr>    <tr><td>21</td><td>0x15</td><td>认证方式</td><td>UTF-8字符串</td><td>CONNECT，CONNACK，AUTH</td></tr>    <tr><td>22</td><td>0x16</td><td>认证数据</td><td>二进制数据</td><td>CONNECT，CONNACK，AUTH</td></tr>    <tr><td>23</td><td>0x17</td><td>请求问题信息</td><td>单字节</td><td>CONNECT</td></tr>    <tr><td>24</td><td>0x18</td><td>遗嘱延迟间隔</td><td>4字节整数</td><td>Will Properties</td></tr>    <tr><td>25</td><td>0x19</td><td>请求响应信息</td><td>单字节</td><td>CONNECT</td></tr>    <tr><td>26</td><td>0x1A</td><td>响应信息</td><td>UTF-8字符串</td><td>CONNACK</td></tr>    <tr><td>28</td><td>0x1C</td><td>服务引用</td><td>UTF-8字符串</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>31</td><td>0x1F</td><td>原因字符串</td><td>UTF-8字符串</td><td>CONNACK，PUBACK，PUBREC，PUBREL，PUBCOMP，SUBACK，UNSUBACK，DISCONNECT，AUTH</td></tr>    <tr><td>33</td><td>0x21</td><td>接收最大值</td><td>2字节整数</td><td>CONNECT，CONNACK</td></tr>    <tr><td>34</td><td>0x22</td><td>主题别名最大值</td><td>2字节整数</td><td>CONNECT，CONNACK</td></tr>    <tr><td>35</td><td>0x23</td><td>主题别名</td><td>2字节整数</td><td>PUBLISH</td></tr>    <tr><td>36</td><td>0x24</td><td>QoS最大值</td><td>单字节</td><td>CONNACK</td></tr>    <tr><td>37</td><td>0x25</td><td>保留消息可用</td><td>单字节</td><td>CONNACK</td></tr>    <tr><td>38</td><td>0x26</td><td>用户属性</td><td>UTF-8字符串对</td><td>CONNECT，CONNACK，PUBLISH，Will Properties，PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE，SUBACK，UNSUBSCRIBE，UNSUBACK，DISCONNECT，AUTH</td></tr>    <tr><td>39</td><td>0x27</td><td>最大包尺寸</td><td>4字节整数</td><td>CONNECT，CONNACK</td></tr>    <tr><td>40</td><td>0x28</td><td>通配符订阅可用</td><td>单字节</td><td>CONNACK</td></tr>    <tr><td>41</td><td>0x29</td><td>订阅ID可用</td><td>单字节</td><td>CONNACK</td></tr>    <tr><td>42</td><td>0x2A</td><td>共享订阅可用</td><td>单字节</td><td>CONNACK</td></tr>  </tbody></table><p><em>非规范性评论</em></p><p><em>虽然属性ID被定义为一个变长整数，但在规范的此版本中所有的属性ID都只有一个字节的长度。</em></p><h2 id="2-3-载荷"><a href="#2-3-载荷" class="headerlink" title="2.3 载荷"></a>2.3 载荷</h2><p>有些 MQTT 包的尾部是载荷。在 PUBLISH 包中的载荷就是应用消息。</p><p>表2-5 包含载荷的 MQTT 包</p><table><thead><tr><th>MQTT 包</th><th>载荷</th></tr></thead><tbody><tr><td>CONNECT</td><td>有</td></tr><tr><td>CONNACK</td><td>无</td></tr><tr><td>PUBLISH</td><td>可选</td></tr><tr><td>PUBACK</td><td>无</td></tr><tr><td>PUBREC</td><td>无</td></tr><tr><td>PUBREL</td><td>无</td></tr><tr><td>PUBCOMP</td><td>无</td></tr><tr><td>SUBSCRIBE</td><td>有</td></tr><tr><td>SUBACK</td><td>有</td></tr><tr><td>UNSUBSCRIBE</td><td>有</td></tr><tr><td>UNSUBACK</td><td>有</td></tr><tr><td>PINGREQ</td><td>无</td></tr><tr><td>PINGRESP</td><td>无</td></tr><tr><td>DISCONNECT</td><td>无</td></tr><tr><td>AUTH</td><td>无</td></tr></tbody></table><h2 id="2-4-原因码"><a href="#2-4-原因码" class="headerlink" title="2.4 原因码"></a>2.4 原因码</h2><p>原因码是一个单字节的无符号整数值，用来表示一个操作的结果。小于 0x80 的原因码用来表示操作成功，最常见的表示成功的原因码是 0x00。0x80或更大的原因码表示失败。</p><p>在 CONNACK，PUBACK，PUBREC，PUBREL，PUBCOMP，DISCONNECT 和 AUTH 包的可变头中有一个原因码字段。在 SUBACK 和 UNSUBACK 的载荷中包一个列表，其中有一个或多个原因码字段。</p><p>原因码字段值的通用定义如下：</p><p>表2-6 原因码</p><table>  <thead>    <tr>      <th colspan="2">原因码</th>      <th rowspan="2">名称</th>      <th rowspan="2">包类型</th>    </tr>    <tr>      <th>十进制</th><th>十六进制</th>    </tr>  </thead>  <tbody>    <tr><td>0</td><td>0x00</td><td>成功</td><td>CONNACK，PUBACK，PUBREC，PUBREL，PUBCOMP，UNSUBACK，AUTH</td></tr>    <tr><td>0</td><td>0x00</td><td>普通断开</td><td>DISCONNECT</td></tr>    <tr><td>0</td><td>0x00</td><td>授予 QoS 0</td><td>SUBACK</td></tr>    <tr><td>1</td><td>0x01</td><td>授予 QoS 1</td><td>SUBACK</td></tr>    <tr><td>2</td><td>0x02</td><td>授予 QoS 2</td><td>SUBACK</td></tr>    <tr><td>4</td><td>0x04</td><td>携带遗嘱的断开链接</td><td>DISCONNECT</td></tr>    <tr><td>16</td><td>0x16</td><td>没有匹配的订阅者</td><td>PUBACK，PUBREC</td></tr>    <tr><td>17</td><td>0x11</td><td>没有存在的订阅</td><td>UNSUBACK</td></tr>    <tr><td>24</td><td>0x18</td><td>继续认证</td><td>AUTH</td></tr>    <tr><td>25</td><td>0x19</td><td>重新认证</td><td>AUTH</td></tr>    <tr><td>128</td><td>0x80</td><td>未指定错误</td><td>CONNACK，PUBACK，PUBREC，SUBACK，UNSUBACK，DISCONNECT</td></tr>    <tr><td>129</td><td>0x81</td><td>格式错误的包</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>130</td><td>0x82</td><td>协议错误</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>CONNACK，PUBACK，PUBREC，SUBACK，UNSUBACK，DISCONNECT</td></tr>    <tr><td>132</td><td>0x84</td><td>协议版本不支持</td><td>CONNACK</td></tr>    <tr><td>133</td><td>0x85</td><td>客户端ID不可用</td><td>CONNACK</td></tr>    <tr><td>134</td><td>0x86</td><td>用户名或密码错误</td><td>CONNACK</td></tr>    <tr><td>135</td><td>0x87</td><td>未经授权</td><td>CONNACK，PUBACK，PUBREC，SUBACK，UNSUBACK，DISCONNECT</td></tr>    <tr><td>136</td><td>0x88</td><td>服务器不可用</td><td>CONNACK</td></tr>    <tr><td>137</td><td>0x89</td><td>服务器忙</td><td>CONNACK</td></tr>    <tr><td>138</td><td>0x8A</td><td>被禁止</td><td>CONNACK</td></tr>    <tr><td>139</td><td>0x8B</td><td>服务器关闭</td><td>DISCONNECT</td></tr>    <tr><td>140</td><td>0x8C</td><td>认证方式错误</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>141</td><td>0x8D</td><td>保活超时</td><td>DISCONNECT</td></tr>    <tr><td>142</td><td>0x8E</td><td>会话被接管</td><td>DISCONNECT</td></tr>    <tr><td>143</td><td>0x8F</td><td>主题过滤器不可用</td><td>SUBACK，UNSUBACK，DISCONNECT</td></tr>    <tr><td>144</td><td>0x90</td><td>主题名不可用</td><td>CONNACK，PUBACK，PUBREC，DISCONNECT</td></tr>    <tr><td>145</td><td>0x91</td><td>包ID已被使用</td><td>PUBACK，PUBREC，SUBACK，UNSUBACK</td></tr>    <tr><td>146</td><td>0x92</td><td>包ID未找到</td><td>PUBREL，PUBCOMP</td></tr>    <tr><td>147</td><td>0x93</td><td>超出接收最大值</td><td>DISCONNECT</td></tr>    <tr><td>148</td><td>0x94</td><td>主题别名不可用</td><td>DISCONNECT</td></tr>    <tr><td>149</td><td>0x95</td><td>包过大</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>150</td><td>0x96</td><td>消息频率过高</td><td>DISCONNECT</td></tr>    <tr><td>151</td><td>0x97</td><td>超限</td><td>CONNACK，PUBACK，PUBREC，SUBACK，DISCONNECT</td></tr>    <tr><td>152</td><td>0x98</td><td>管理员行为</td><td>DISCONNECT</td></tr>    <tr><td>153</td><td>0x99</td><td>载荷格式错误</td><td>CONNACK，PUBACK，PUBREC，DISCONNECT</td></tr>    <tr><td>154</td><td>0x9A</td><td>不支持保留消息</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>155</td><td>0x9B</td><td>不支持的 QoS</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>156</td><td>0x9C</td><td>使用另一台服务器</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>157</td><td>0x9D</td><td>服务器迁移</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>158</td><td>0x9E</td><td>不支持共享订阅</td><td>SUBACK，DISCONNECT</td></tr>    <tr><td>159</td><td>0x9F</td><td>连接频率超限</td><td>CONNACK，DISCONNECT</td></tr>    <tr><td>160</td><td>0xA0</td><td>最大连接时间</td><td>DISCONNECT</td></tr>    <tr><td>161</td><td>0xA1</td><td>不支持订阅ID</td><td>SUBACK，DISCONNECT</td></tr>    <tr><td>162</td><td>0xA2</td><td>不支持通配符订阅</td><td>SUBACK，DISCONNECT</td></tr>  </tbody></table><p><em>非规范性评论</em></p><p><em>对于 0x91（包ID已被使用）的原因码，对此的处理应是处理重复状态，或是使用 Clean Start 为 1 的标识重新创建连接来重置会话，或是检查客户端或服务器的实现是否有缺陷。</em></p><h1 id="3-MQTT包"><a href="#3-MQTT包" class="headerlink" title="3 MQTT包"></a>3 MQTT包</h1><h2 id="3-1-CONNECT-连接请求"><a href="#3-1-CONNECT-连接请求" class="headerlink" title="3.1 CONNECT - 连接请求"></a>3.1 CONNECT - 连接请求</h2><p><span class="vcMarked">当客户端和服务器的网络连接建立后，客户端向服务器发送的第一个数据包<strong>必须</strong>是 CONNECT 包</span> <span class="vcReferred">[MQTT-3.1.0-1]</span>。</p><p>一个客户端在一次网络连接中只能发送一个 CONNECT 包。<span class="vcMarked">服务器<strong>必须</strong>将客户端发送的第二个 CONNECT 包视为协议错误并关闭网络连接</span> <span class="vcReferred">[MQTT-3.1.0-2]</span>。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><p>CONNECT 的载荷包含一个或更多的字段，包括唯一的客户端ID，遗嘱主题，遗嘱载荷，用户名和密码。除了客户端ID以外的字段都可以省略，他们的存在与否根据可变头中的标识确定。</p><h3 id="3-1-1-CONNECT固定头"><a href="#3-1-1-CONNECT固定头" class="headerlink" title="3.1.1 CONNECT固定头"></a>3.1.1 CONNECT固定头</h3><p>图3‑1 CONNECT 包固定头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（1）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2...</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度</strong></p><p>表示可变头长度和载荷长度的总和，使用变长整数表示。</p><h3 id="3-1-2-CONNECT可变头"><a href="#3-1-2-CONNECT可变头" class="headerlink" title="3.1.2 CONNECT可变头"></a>3.1.2 CONNECT可变头</h3><p>CONNECT 包中的可变头按固定顺序提供下列字段：协议名、协议版本、连接标识、保活时间和属性集。属性集的编码方式请参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><h4 id="3-1-2-1-协议名"><a href="#3-1-2-1-协议名" class="headerlink" title="3.1.2.1 协议名"></a>3.1.2.1 协议名</h4><p>图3-2 协议名字节</p><table>  <thead>    <tr><td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="10">协议名</td></tr>    <tr><td>byte 1</td><td>长度高位（MSB）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td>长度低位（LSB）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>    <tr><td>byte 3</td><td>'M'</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>    <tr><td>byte 4</td><td>'Q'</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>    <tr><td>byte 5</td><td>'T'</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>    <tr><td>byte 6</td><td>'T'</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>  </tbody></table><p>协议名是 UTF-8字符串表示的大写 “MQTT”，就像上图所示。这个字符串、他的位置和他的长度在未来的 MQTT 规范版本中永远不会改变。</p><p>支持多种协议的服务器可以通过协议名称来判断收到的数据是否是 MQTT 数据。<span class="vcMarked">协议名称<strong>必须</strong>是 <code>UTF-8字符串</code>表示的 “MQTT”。如果服务器不想接收此连接，同时又想告知客户端服务器是一个 MQTT 服务器，<strong>可以</strong>发送一个带有 0x84（协议版本不支持）原因码的 CONNACK，随后服务器<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.1.2-1]</span>。</p><p><em>非规范性评论</em></p><p><em>数据包检查器（例如防火墙）可以使用协议名称来识别 MQTT 流量。</em></p><h4 id="3-1-2-2-协议版本"><a href="#3-1-2-2-协议版本" class="headerlink" title="3.1.2.2 协议版本"></a>3.1.2.2 协议版本</h4><p>图3‑3 协议版本字节</p><table>  <thead>    <tr><td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="10">协议版本</td></tr>    <tr><td>byte 7</td><td>版本（5）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>  </tbody></table><p>此处的单字节无符号值表示了客户端使用的协议的版本。MQTT 5.0 版本的协议版本的值应为 5（0x05）。</p><p>支持多个协议版本的服务器可以通过协议版本字段来判断客户端使用何种版本的 MQTT 协议。<span class="vcMarked">如果客户端使用的协议版本不为 5 而且服务器不想接受此 CONNECT 包，服务器<strong>可以</strong>发送一个带有 0x84（协议版本不支持）原因码的 CONNACK，随后服务器<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.1.2-2]</span>。</p><h4 id="3-1-2-3-连接标识"><a href="#3-1-2-3-连接标识" class="headerlink" title="3.1.2.3 连接标识"></a>3.1.2.3 连接标识</h4><p>连接标志字节包含了几个指定 MQTT 连接行为的参数。他还用来指示载荷中的某些字段是否存在。</p><p>图3‑4 连接标识位</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td></td><td>用户名标识</td><td>密码标识</td><td>遗嘱保留消息</td><td colspan="2">遗嘱QoS</td><td>遗嘱标识</td><td>全新开始</td><td>保留</td></tr>    <tr><td>byte 8</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>0</td></tr>  </tbody></table><p><span class="vcMarked">服务器<strong>必须</strong>验证 CONNECT 包中的保留位的值是 0</span> <span class="vcReferred">[MQTT-3.1.2-3]</span>。如果保留位的值非 0，则视为一个格式错误的包，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><h4 id="3-1-2-4-全新开始"><a href="#3-1-2-4-全新开始" class="headerlink" title="3.1.2.4 全新开始"></a>3.1.2.4 全新开始</h4><p><strong>位置：</strong>连接标识字节中的比特位 1。</p><p>这个比特位指定了此连接是一个全新的会话还是一个已经存在会话的延续。参考 <a href="#4-1-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">4.1</a> 了解关于会话状态的定义。</p><p><span class="vcMarked">如果接收到全新开始值置为 1 的 CONNECT 包，客户端和服务器<strong>必须</strong>丢弃任何已经存在的会话并开始一个新的会话</span> <span class="vcReferred">[MQTT-3.1.2-4]</span>。因此，当 CONNECT 包中的全新开始值置为 1 时，对应的 CONNACK 包中的会话存在总是会被至为0。</p><p><span class="vcMarked">如果服务器接收到的 CONNECT 包中的全新开始被置为 0 并且服务器中已经存在和客户端ID关联的会话，服务器<strong>必须</strong>基于已经存在的会话状态恢复客户端的连接</span> <span class="vcReferred">[MQTT-3.1.2-5]</span>。<span class="vcMarked">如果服务器接收到的 CONNECT 包中的全新开始被置为 0 并且服务器中没有和客户端ID关联的会话，服务器<strong>必须</strong>创建一个新的会话</span> <span class="vcReferred">[MQTT-3.1.2-6]</span>。</p><h4 id="3-1-2-5-遗嘱标识"><a href="#3-1-2-5-遗嘱标识" class="headerlink" title="3.1.2.5 遗嘱标识"></a>3.1.2.5 遗嘱标识</h4><p><strong>位置：</strong>连接标识字节中的比特位 2。</p><p><span class="vcMarked">如果遗嘱标识被置为 1，则表示遗嘱消息<strong>必须</strong>被存储在服务器中，并且关联到此会话</span> <span class="vcReferred">[MQTT-3.1.2-7]</span>。遗嘱消息由 CONNECT 载荷中的遗嘱属性集、遗嘱主题和遗嘱载荷组成。<span class="vcMarked">遗嘱消息<strong>必须</strong>在网络连接断开后的遗嘱延迟间隔时间过期后或会话结束时发布，除非由于服务器接收到一个带有 0x00（普通断开）原因码的 DISCONNECT 包从而删除了遗嘱消息，或是在遗嘱延迟间隔时间过期前接收了一个带有相同客户端ID的连接</span> <span class="vcReferred">[MQTT-3.1.2-8]</span>。</p><p>遗嘱消息被发布的场景包括不限于：</p><ul><li>服务器检测到了 I&#x2F;O 错误或网络故障</li><li>客户端没有成功在保活时间内通信</li><li>客户端在没有发送原因码为 0x00（普通断开）的 DISCONNECT 包的前提下断开网络连接</li><li>服务器在没有收到原因码为 0x00（普通断开）的 DISCONNECT 包的前提下断开网络连接</li></ul><p><span class="vcMarked">当遗嘱标识被置为 1 时，载荷中<strong>必须</strong>包括遗嘱属性集、遗嘱主题和遗嘱载荷字段</span> <span class="vcReferred">[MQTT-3.1.2-9]</span>。<span class="vcMarked">当服务器发布遗嘱后或服务器从客户端收到了原因码为 0x00（普通断开）的 DISCONNECT 包后，服务器<strong>必须</strong>从会话状态中删除遗嘱消息</span> <span class="vcReferred">[MQTT-3.1.2-10]</span>。</p><p>服务器应该在下列两种情况中的某一种先发生时发布遗嘱消息：网络连接断开后经过了遗嘱延迟间隔时间、会话结束。如果发生了服务器关闭或故障，服务器也许可以在随后的重启之后发布遗嘱消息。当此种情况发生时，服务器故障发生的时间和遗嘱消息发布的时间之间可能会有延迟。</p><p>参考 <a href="#3-1-3-2-%E9%81%97%E5%98%B1%E5%B1%9E%E6%80%A7%E9%9B%86">3.1.3.2</a> 了解关于遗嘱延迟间隔的消息。</p><p><em>非规范性评论</em></p><p><em>客户端可以设置遗嘱延迟间隔大于会话过期间隔，再发送带有原因码 0x04（携带遗嘱的断开链接）的 DISCONNECT 断开连接。这样可以使用遗嘱消息来通知会话已过期。</em></p><h4 id="3-1-2-6-遗嘱QoS"><a href="#3-1-2-6-遗嘱QoS" class="headerlink" title="3.1.2.6 遗嘱QoS"></a>3.1.2.6 遗嘱QoS</h4><p><strong>位置：</strong>连接标识字节中的比特位 4 和 3。</p><p>这两个比特位指定了发布遗嘱消息时使用的 QoS 等级。</p><p><span class="vcMarked">当遗嘱标识被置为 0 时，遗嘱 QoS <strong>必须</strong>被置为 0（0x00）</span> <span class="vcReferred">[MQTT-3.1.2-11]</span>。</p><p><span class="vcMarked">当遗嘱标识被置为 1 时，遗嘱QoS的值可以是 0（0x00），1（0x01）或 2（0x02）</span> <span class="vcReferred">[MQTT-3.1.2-12]</span>。当值为 3（0x03）时视为格式错误的包，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 查看关于错误处理的信息。</p><h4 id="3-1-2-7-遗嘱保留消息"><a href="#3-1-2-7-遗嘱保留消息" class="headerlink" title="3.1.2.7 遗嘱保留消息"></a>3.1.2.7 遗嘱保留消息</h4><p><strong>位置：</strong>连接标识字节中的比特位 5。</p><p>这个比特位指定了当遗嘱消息发布时是否会被保留。</p><p><span class="vcMarked">当遗嘱标识被置为 0 时，遗嘱保留消息的值<strong>必须</strong>被置为 0</span> <span class="vcReferred">[MQTT-3.1.2-13]</span>。<span class="vcMarked">当遗嘱标识被置为 1 且遗嘱保留消息被置为 0 时，服务器<strong>必须</strong>将遗嘱消息作为一个非保留消息发布</span> <span class="vcReferred">[MQTT-3.1.2-14]</span>。<span class="vcMarked">当遗嘱标识被置为 1 且遗嘱保留消息被置为 1 时，服务器<strong>必须</strong>将遗嘱消息作为一个保留消息发布</span> <span class="vcReferred">[MQTT-3.1.2-15]</span>。</p><h4 id="3-1-2-8-用户名标识"><a href="#3-1-2-8-用户名标识" class="headerlink" title="3.1.2.8 用户名标识"></a>3.1.2.8 用户名标识</h4><p><strong>位置：</strong>连接标识字节中的比特位 7。</p><p><span class="vcMarked">当用户名标识被置为 0 时，载荷中<strong>必须不</strong>存在用户名</span> <span class="vcReferred">[MQTT-3.1.2-16]</span>。<span class="vcMarked">当用户名标识被置为 1 时，载荷中<strong>必须</strong>存在用户名</span> <span class="vcReferred">[MQTT-3.1.2-17]</span>。</p><h4 id="3-1-2-9-密码标识"><a href="#3-1-2-9-密码标识" class="headerlink" title="3.1.2.9 密码标识"></a>3.1.2.9 密码标识</h4><p><strong>位置：</strong>连接标识字节中的比特位 6。</p><p><span class="vcMarked">当密码标识被置为 0 时，载荷中<strong>必须不</strong>存在密码</span> <span class="vcReferred">[MQTT-3.1.2-18]</span>。<span class="vcMarked">当密码标识被置为 1 时，载荷中<strong>必须</strong>存在密码</span> <span class="vcReferred">[MQTT-3.1.2-19]</span>。</p><p><em>非规范性评论</em></p><p><em>本版协议允许在不使用用户名时使用密码，和 MQTT v3.1.1 不同。这反映了密码作为密码以外的凭证的常见用途。</em></p><h4 id="3-1-2-10-保活时间"><a href="#3-1-2-10-保活时间" class="headerlink" title="3.1.2.10 保活时间"></a>3.1.2.10 保活时间</h4><p>图3-5 保活时间字节</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 9</td><td colspan="8">保活时间高位（MSB）</td></tr>    <tr><td>byte 10</td><td colspan="8">保活时间地位（LSB）</td></tr>  </tbody></table><p>保活时间是一个表示时间间隔秒数的 2字节整数。他是允许客户端在发送一个 MQTT 包后到发送下一个数据包之间的最大时间间隔。客户端有责任确保两个 MQTT 包之间的时间间隔不超过保活时间。<span class="vcMarked">如果保活时间不为 0 且没有任何其他需要发送的数据包，客户端<strong>必须</strong>发送 PINGREQ 包</span> <span class="vcReferred">[MQTT-3.1.2-20]</span>。</p><p><span class="vcMarked">如果服务器在 CONNACK 中提供了服务器保活时间，则客户端<strong>必须</strong>采用服务器保活时间的值来替代自己发送的保活时间的值</span> <span class="vcReferred">[MQTT-3.1.2-21]</span>。</p><p>不论保活时间的值如何设置，客户端可以在任何时间发送 PINGREQ，并通过检查相应的 PINGRESP 来确认服务器与网络是否可用。</p><p><span class="vcMarked">如果保活时间为非零值且服务器在 1.5 倍的保活时间内没有收到来自客户端的任何 MQTT 包，服务器<strong>必须</strong>断开到客户端的网络连接并视为网络连接故障</span> <span class="vcReferred">[MQTT-3.1.2-22]</span>。</p><p>如果客户端在发送 PINGREQ 的合理时间后依然没有收到 PINGRESP，客户端应断开到服务器的网络连接。</p><p>保活时间的值为 0 表示关闭保活机制。当保活时间为 0 时客户端没有义务按任何特定时间发送 MQTT 包。</p><p><em>非规范性评论</em></p><p><em>服务器可能会因为其他原因关闭向客户端的连接，例如服务器关机。设置保活时间并非意味着客户端可以持续保持连接。</em></p><p><em>非规范性评论</em></p><p><em>保活时间的具体值是由应用程序设置的，通常来说，是几分钟。保活时间的最大值 65535 表示 18小时12分钟15秒。</em></p><h4 id="3-1-2-11-CONNECT属性集"><a href="#3-1-2-11-CONNECT属性集" class="headerlink" title="3.1.2.11 CONNECT属性集"></a>3.1.2.11 CONNECT属性集</h4><h5 id="3-1-2-11-1-属性长度"><a href="#3-1-2-11-1-属性长度" class="headerlink" title="3.1.2.11.1 属性长度"></a>3.1.2.11.1 属性长度</h5><p>CONNECT 包可变头中的属性集长度，使用变长整数编码。</p><h5 id="3-1-2-11-2-会话过期间隔"><a href="#3-1-2-11-2-会话过期间隔" class="headerlink" title="3.1.2.11.2 会话过期间隔"></a>3.1.2.11.2 会话过期间隔</h5><p>会话过期间隔的属性ID是<strong>17 (0x11) Byte</strong>。</p><p>随后跟随 4字节整数 用来表示会话过期间隔，单位为秒。在属性集中出现超过一次会话过期间隔视为协议错误。</p><p>当没有设置会话过期间隔是使用 0 作为默认值。如果会话过期间隔的值为 0 或者没有设置，当网络连接断开时会话立即结束。</p><p>如果会话过期间隔被设置为 0xFFFFFFFF (UINT_MAX)，表示会话不会过期。</p><p><span class="vcMarked">当会话过期间隔的值大于 0 时，客户端和服务器都<strong>必须</strong>在网络连接断开后存储会话状态</span> <span class="vcReferred">[MQTT-3.1.2-23]</span>。</p><p><em>非规范性评论</em></p><p><em>客户端或服务器的时钟可能在某些时间内没有运行，例如当客户端或服务器被关闭时。这可能会导致状态被延迟删除。</em></p><p>参考 <a href="#4-1-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">4.1</a> 了解更多关于会话的信息。参考 <a href="#4-1-1-%E5%AD%98%E5%82%A8%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">4.1.1</a> 了解更多关于会话状态存储的细节和限制。</p><p>当会话过期时，客户端与服务器不需要自动删除会话状态。</p><p><em>非规范性评论</em></p><p><em>将全新开始标识设置为 1 并将会话过期间隔设置为 0，等同于在 MQTT v3.1.1 规范中将 CleanSession 设置为 1。将全新开始标识设置为 0 且不设置会话过期间隔，等同于在 MQTT v3.1.1 规范中将 CleanSession 设置为 0。</em></p><p><em>非规范性评论</em></p><p><em>一个只想处理其在线时消息的客户端可以将全新开始标识设置为 1 同时将会话过期间隔设置为 0。这样他将不会收到任何在他离线时产生的消息，并且他必须在每次连接后重新订阅所有他需要的主题。</em></p><p><em>非规范性评论</em></p><p><em>当客户端使用一个间歇性可用的网络连接服务器时，客户端可以设置一个较短的会话过期间隔这样每当网络连接可用时他都会重连并继续进行可靠的消息传递。而当客户端没有重连时，允许会话超时，这样应用消息就会丢失。</em></p><p><em>非规范性评论</em></p><p><em>当一个客户端使用较长的会话过期间隔连接服务器时，这意味着他希望服务器能够在他断开连接后的较长时间里维护会话状态。客户端只有在明确的意识到自己会在某个时间点重连时才使用这种较长的会话过期间隔。当一个客户端决定未来不再使用此会话，他应该在断开时将会话过期间隔设置为0。</em></p><p><em>非规范性评论</em></p><p><em>客户端总是应该基于 CONNACK 中的会话存在标识来判断服务器是否保存有该客户端的会话状态。</em></p><p><em>非规范性评论</em></p><p><em>客户端可以依赖服务器返回的会话存在标识来判断会话是否过期，而不必自己实现会话过期机制。如果客户端自己实现了会话过期机制，那么则必须在自己的会话状态中记录何时该会话状态需要被删除。</em></p><h5 id="3-1-2-11-3-接收最大值"><a href="#3-1-2-11-3-接收最大值" class="headerlink" title="3.1.2.11.3 接收最大值"></a>3.1.2.11.3 接收最大值</h5><p>接收最大值的属性ID是<strong>33 (0x21) Byte</strong>。</p><p>随后跟随 2字节整数 用来表示有状态数据接收的最大值。接收最大值在属性集中出现超过一次，或接收最大值的值为0，均为协议错误。</p><p>客户端使用此值限制他同时处理的 QoS1 和 QoS2 包发布动作数量。没有任何机制限制服务器可能尝试的对 QoS0 包的发布。</p><p>接收最大值的值仅对当前网络连接有效。如果没有设置接收最大值那么他的默认值是 65535。</p><p>参考 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.9 流量控制</a> 了解关于接收最大值的使用细节。</p><h5 id="3-1-2-11-4-最大包尺寸"><a href="#3-1-2-11-4-最大包尺寸" class="headerlink" title="3.1.2.11.4 最大包尺寸"></a>3.1.2.11.4 最大包尺寸</h5><p>最大包尺寸的属性ID是<strong>33 (0x21) Byte</strong>。</p><p>随后跟随 4字节整数 用来表示客户端可以接受的最大包尺寸。如果没有设置最大包尺寸，则其受限于固定头中的剩余长度限制，除此外并没有其他限制。</p><p>在属性集中出现超过一次最大包尺寸或其值为 0 均视为协议错误。</p><p><em>非规范性评论</em></p><p><em>当包的尺寸需要被限制时，应用程序有责任选择一个合适的最大包尺寸的值。</em></p><p>最大包尺寸表示 <strong>MQTT 包完整的字节数</strong>，其定义参考 <a href="#2-1-4-%E5%89%A9%E4%BD%99%E9%95%BF%E5%BA%A6">2.1.4</a>。客户端使用最大包尺寸告知服务器，客户端不会处理超过此尺寸限制的信息。</p><p><span class="vcMarked">服务器<strong>必须不</strong>向客户端发送超过最大包尺寸的数据包</span> <span class="vcReferred">[MQTT-3.1.2-24]</span>。如果客户端收到了超过其最大包尺寸限制的包，这被视为一个协议错误，客户端需要使用带有原因码 0x95（包过大）的 DISCONNECT 包来中断连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 的描述。</p><p><span class="vcMarked">当一个包因超过最大包尺寸而无法发送，服务器<strong>必须</strong>将其丢弃，并视为发送成功</span> <span class="vcReferred">[MQTT-3.1.2-25]</span>。</p><p>当某个包的尺寸大于共享订阅中的部分客户端的最大包尺寸，而又可以被另外的某些客户端接收时，服务器可以决定丢弃此包或者将其发送到可以接收此包的客户端。</p><p><em>非规范性评论</em></p><p><em>当一个包未被发送即被丢弃时，服务器可以将其放入“丢包队列”或者提供其他的诊断机制。此类行为实现不属于本规范的范畴。</em></p><h5 id="3-1-2-11-5-主题别名最大值"><a href="#3-1-2-11-5-主题别名最大值" class="headerlink" title="3.1.2.11.5 主题别名最大值"></a>3.1.2.11.5 主题别名最大值</h5><p>主题别名最大值的属性ID是<strong>34 (0x22) Byte</strong>。</p><p>随后跟随 2字节整数 表示主题别名的最大值。在属性集中出现超过一次主题别名最大值视为协议错误。如果主题别名最大值没有设置，则采用默认值 0。</p><p>主题别名最大值表示了客户端可以接受的来自服务器发送的主题别名的最大数量。客户端使用此值来约束他在本次连接中可以持有的主题别名数量。<span class="vcMarked">服务器<strong>必须不</strong>发送一个主题别名的值大于客户端设置的主题别名最大值的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.1.2-26]</span>。主题别名最大值的值为 0 表示客户端在本次连接中不支持任何主题别名。<span class="vcMarked">如果主题别名最大值未设置或值为 0，服务器<strong>必须不</strong>向客户端发送主题别名</span> <span class="vcReferred">[MQTT-3.1.2-27]</span>。</p><h5 id="3-1-2-11-6-请求响应信息"><a href="#3-1-2-11-6-请求响应信息" class="headerlink" title="3.1.2.11.6 请求响应信息"></a>3.1.2.11.6 请求响应信息</h5><p>请求响应信息的属性ID是<strong>25 (0x19) Byte</strong>。</p><p>随后跟随一个值为 0 或 1 的字节。在属性集中出现超过一次请求响应信息，或其值不为 1 或 0，均视为协议错误。如果请求响应信息没有设置，则采用默认值 0。</p><p>客户端通过此值请求服务器，希望服务器在 CONNACK 中回复响应信息。<span class="vcMarked">此值为 0 表示服务器<strong>必须不</strong>在 CONNACK 中回复响应信息</span> <span class="vcReferred">[MQTT-3.1.2-28]</span>。此值为 1 表示服务器可以在 CONNACK 中回复响应信息。</p><p><em>非规范性评论</em></p><p><em>即使客户端请求了，服务器也可以不在 CONNACK 中回复响应信息。</em></p><p>参考 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">4.10</a> 了解关于 请求&#x2F;响应 的更多信息。</p><h5 id="3-1-2-11-7-请求问题信息"><a href="#3-1-2-11-7-请求问题信息" class="headerlink" title="3.1.2.11.7 请求问题信息"></a>3.1.2.11.7 请求问题信息</h5><p>请求问题信息的属性ID是<strong>23 (0x17) Byte</strong>。</p><p>随后跟随一个值为 0 或 1 的字节。在属性集中出现超过一次请求问题信息，或其值不为 1 或 0，均视为协议错误。如果请求问题信息没有设置，则采用默认值 0。</p><p>客户端通过此值表示服务器是是否应该在故障时发送原因字符串或用户属性。</p><p><span class="vcMarked">如果请求问题信息的值为 0，服务器可以在 CONNACK 或 DISCONNECT 包中携带原因字符串或用户属性，但<strong>必须不</strong>在除 PUBLISH，CONNACK，DISCONNECT 之外的包中携带原因字符串或用户属性</span> <span class="vcReferred">[MQTT-3.1.2-29]</span>。如果请求问题信息的值为 0 且客户端接收到除 PUBLISH，CONNACK，DISCONNECT 之外的包中带有了原因字符串或用户属性，客户端使用带有原因码 0x82（协议错误）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 了解更多信息。</p><p>如果请求问题信息的值为 1，服务器可以在任何允许的包中返回原因字符串或用户属性。</p><h5 id="3-1-2-11-8-用户属性"><a href="#3-1-2-11-8-用户属性" class="headerlink" title="3.1.2.11.8 用户属性"></a>3.1.2.11.8 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 UTF-8字符串对。</p><p>用户属性可以出现多次，用来携带多个 键-值 对。同样的 键 允许出现超过一次。</p><p><em>非规范性评论</em></p><p>CONNECT 包中的用户属性可以用来从客户端向服务器发送连接过程中依赖的属性。这些属性的含义超出了本规范的范围。</p><h5 id="3-1-2-11-9-认证方式"><a href="#3-1-2-11-9-认证方式" class="headerlink" title="3.1.2.11.9 认证方式"></a>3.1.2.11.9 认证方式</h5><p>认证方式的属性ID是<strong>21 (0x15) Byte</strong>。</p><p>随后跟随 UTF-8字符串，其中包括了使用的增强认证方式的名称。认证方式在属性集中出现超过一次视为协议错误。</p><p>如果没有设置认证方式，将不会执行增强认证。参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a>。</p><p><span class="vcMarked">如果客户端再 CONNECK 包中设置了认证方式，那么在其收到 CONNACK 包之前，客户端<strong>必须不</strong>发送除了 AUTH 和 DISCONNECT 包之外的任何类型的包</span> <span class="vcReferred">[MQTT-3.1.2-30]</span>。</p><h5 id="3-1-2-11-10-认证数据"><a href="#3-1-2-11-10-认证数据" class="headerlink" title="3.1.2.11.10 认证数据"></a>3.1.2.11.10 认证数据</h5><p>认证数据的属性ID是<strong>22 (0x16) Byte</strong>。</p><p>随后跟随 二进制数据 其中包括认证数据。当认证方式不存在是提供认证数据，或是在任何情况下提供超过一次的认证数据，均视为协议错误。</p><p>认证数据的内容由认证方式决定。参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 了解更多关于增强认证的信息。</p><h4 id="3-1-2-12-可变头非规范性示例"><a href="#3-1-2-12-可变头非规范性示例" class="headerlink" title="3.1.2.12 可变头非规范性示例"></a>3.1.2.12 可变头非规范性示例</h4><p>图3-6 可变头示例</p><table>  <thead>    <tr><td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="10">协议名称</td></tr>    <tr>      <td>byte 1</td><td>长度高字节（MSB）（0）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 2</td><td>长度低字节（LSB）（4）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 3</td><td>‘M’</td>      <td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 4</td><td>‘Q’</td>      <td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 5</td><td>‘T’</td>      <td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 6</td><td>‘T’</td>      <td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td>    </tr>    <tr><td colspan="10">协议版本</td></tr>    <tr>      <td>byte 7</td><td>版本（5）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td>    </tr>    <tr><td colspan="10">连接标识</td></tr>    <tr>      <td>byte 8</td>      <td>        用户名标识（1）</br>        密码标识（1）</br>        遗嘱保留消息（0）</br>        遗嘱QoS（01）</br>        遗嘱标识（1）</br>        全新开始（1）</br>        保留（0）      </td>      <td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td>    </tr>    <tr><td colspan="10">保活时间</td></tr>    <tr>      <td>byte 9</td><td>保活时间高位（MSB）（0）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 10</td><td>保活时间低位（LSB）（10）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td>    </tr>    <tr><td colspan="10">属性集</td></tr>    <tr>      <td>byte 11</td><td>长度（5）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 12</td><td>属性ID：会话过期间隔（17）</td>      <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 13</td><td rowspan="4">会话过期间隔（10）</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 14</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 15</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 16</td>      <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td>    </tr>  </tbody></table><h3 id="3-1-3-CONNECT载荷"><a href="#3-1-3-CONNECT载荷" class="headerlink" title="3.1.3 CONNECT载荷"></a>3.1.3 CONNECT载荷</h3><p><span class="vcMarked">CONNECT 中的载荷包含了一个或多个 长度 + 内容 格式的字段，这些字段的存在与否由可变头中的标志位决定。这些字段的顺序是固定的，如果存在的话，<strong>必须</strong>按照 客户端ID，遗嘱属性集，遗嘱主题，遗嘱载荷，用户名，密码 这样的顺序出现</span> <span class="vcReferred">[MQTT-3.1.3-1]</span>。</p><h4 id="3-1-3-1-客户端ID"><a href="#3-1-3-1-客户端ID" class="headerlink" title="3.1.3.1 客户端ID"></a>3.1.3.1 客户端ID</h4><p>客户端ID用来在服务器端区分不同的客户端。每个连向服务器的客户端都拥有一个唯一的客户端ID。<span class="vcMarked">客户端ID<strong>必须</strong>被客户端和服务器用于关联客户端和服务器之间的会话状态</span> <span class="vcReferred">[MQTT-3.1.3-2]</span>。参考 <a href="#4-1-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">4.1</a> 了解更多关于会话状态的信息。</p><p><span class="vcMarked">客户端ID<strong>必须</strong>作为 CONNECT 包载荷中的第一个字段出现</span> <span class="vcReferred">[MQTT-3.1.3-3]</span>。</p><p><span class="vcMarked">客户端ID<strong>必须</strong>被编码为一个 <code>UTF-8字符串</code></span>，该数据类型的定义在 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> <span class="vcReferred">[MQTT-3.1.3-4]</span>。</p><p><span class="vcMarked">服务器<strong>必须</strong>允许客户端ID是长度为 1 到 23 个字节之间的 <code>UTF-8字符串</code>，且仅包含下列字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”</span> <span class="vcReferred">[MQTT-3.1.3-5]</span>。</p><p>服务器可以允许客户端ID的长度超过23字节。服务器可以允许客户端ID的内容包含上述以外的内容。</p><p><span class="vcMarked">服务器<strong>可以</strong>允许客户端传递长度为 0 的客户端ID，当此情况发生时，服务器<strong>必须</strong>将此情况作为一个特殊情况对待，并为客户端分配一个唯一的客户端ID</span> <span class="vcReferred">[MQTT-3.1.3-6]</span>。<span class="vcMarked">服务器之后<strong>必须</strong>正常处理此 CONNECT 包，就如同客户端本身携带了这个唯一的客户端ID一样，而且<strong>必须</strong>在 CONNACK 包中返回这个分配的客户端ID</span> <span class="vcReferred">[MQTT-3.1.3-7]</span>。</p><p><span class="vcMarked">如果服务器拒绝了客户端ID，服务器<strong>可以</strong>使用一个带有原因码 0x85（客户端ID不可用）的 CONNACK 包作为对客户端 CONNECT 包的响应，如同 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中描述的那样，之后服务器<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.1.3-8]</span>。</p><p><em>非规范性评论</em></p><p><em>客户端实现可以提供一个方便的生成随机客户端ID的方法。使用这种方法的客户端应该注意避免创建长期存在的孤立会话。</em></p><h4 id="3-1-3-2-遗嘱属性集"><a href="#3-1-3-2-遗嘱属性集" class="headerlink" title="3.1.3.2 遗嘱属性集"></a>3.1.3.2 遗嘱属性集</h4><p>如果遗嘱标识被置为 1，载荷中的下一个字段会是遗嘱属性集。遗嘱属性集决定了当遗嘱消息被发布时所使用的应用消息属性集，还决定了何时发布遗嘱消息。遗嘱属性集包含了属性长度和属性集内容。</p><h5 id="3-1-3-2-1-属性长度"><a href="#3-1-3-2-1-属性长度" class="headerlink" title="3.1.3.2.1 属性长度"></a>3.1.3.2.1 属性长度</h5><p>遗嘱属性集中的属性集长度是一个变长整数。</p><h5 id="3-1-3-2-2-遗嘱延迟间隔"><a href="#3-1-3-2-2-遗嘱延迟间隔" class="headerlink" title="3.1.3.2.2 遗嘱延迟间隔"></a>3.1.3.2.2 遗嘱延迟间隔</h5><p>遗嘱延迟间隔的属性ID是<strong>24 (0x18) Byte</strong>。</p><p>随后跟随 4字节整数，表示遗嘱延迟间隔时间，单位为秒。遗嘱延迟间隔在属性集中出现超过一次视为协议错误。如果遗嘱延迟间隔未设置，默认值为0，表示遗嘱发布前没有间隔时间。</p><p>服务器在遗嘱延迟间隔结束或是会话结束时发布遗嘱，这两种条件以先触发的为准。<span class="vcMarked">如果在遗嘱延迟间隔结束前，该会话被新的网络连接延续，服务器<strong>必须不</strong>发送遗嘱</span> <span class="vcReferred">[MQTT-3.1.3-9]</span>。</p><p><em>非规范性评论</em></p><p><em>遗嘱延迟间隔的一个作用是，当使用周期性可用的网络进行通信时，客户端使用遗嘱延迟间隔可以在遗嘱发布前重新连接并使用会话，而非每次连接断开后都发布遗嘱。</em></p><p><em>非规范性评论</em></p><p><em>当客户端和服务器的网络连接存在时，如果客户端再次使用相同的客户端ID连接到服务器，现有网络连接的遗嘱消息会被发布，除非新连接将 全新开始 标识置为 0 且遗嘱延迟间隔的值大于 0。如果遗嘱延迟间隔的值为 0，遗嘱消息会因为原有网络连接的关闭而发布，如果 全新开始 标识为 1 ，遗嘱消息会因为原有会话的结束而发布。</em></p><h5 id="3-1-3-2-3-载荷格式标识"><a href="#3-1-3-2-3-载荷格式标识" class="headerlink" title="3.1.3.2.3 载荷格式标识"></a>3.1.3.2.3 载荷格式标识</h5><p>载荷格式标识的属性ID是<strong>1 (0x01) Byte</strong>。</p><p>随后的值表示遗嘱载荷的格式：</p><ul><li>0（0x00）Byte 表示遗嘱消息是未指定的字节流，这等同于没有发送载荷格式标识。</li><li>1（0x01）Byte 表示遗嘱消息是 UTF-8字符串。载荷中的 UTF-8 数据必须符合 <a href="#1.3-Unicode">Unicode</a> 和 <a href="#1.3-RFC3629">RFC3629</a> 规范。</li></ul><p>载荷格式标识在属性集中出现超过一次视为协议错误。服务器可以验证遗嘱消息是否符合载荷格式标识指定的格式，如果不符合则发送一个带有原因码 0x99（载荷格式错误）的 CONNACK 报文，详情参考 4.13。</p><h5 id="3-1-3-2-4-消息过期间隔"><a href="#3-1-3-2-4-消息过期间隔" class="headerlink" title="3.1.3.2.4 消息过期间隔"></a>3.1.3.2.4 消息过期间隔</h5><p>消息过期间隔的属性ID是<strong>2 (0x02) Byte</strong>。</p><p>随后跟随 4字节整数 用来表示消息过期间隔。消息过期间隔在属性集中出现超过一次视为协议错误。</p><p>当消息过期间隔存在时，此四字节的整数表示遗嘱消息的存活时间（单位秒），同时也是服务器发送此遗嘱消息时使用的发布过期时间。</p><p>如果没有设置此值，服务器发布遗嘱消息时不设置消息过期时间。</p><h5 id="3-1-3-2-5-内容类型"><a href="#3-1-3-2-5-内容类型" class="headerlink" title="3.1.3.2.5 内容类型"></a>3.1.3.2.5 内容类型</h5><p>内容类型的属性ID是<strong>3 (0x03) Byte</strong>。</p><p>随后跟随 UTF-8字符串，表示遗嘱消息的内容类型。内容类型在属性集中出现超过一次视为协议错误。内容类型的值由发送方和接收方的应用程序定义。</p><h5 id="3-1-3-2-6-响应主题"><a href="#3-1-3-2-6-响应主题" class="headerlink" title="3.1.3.2.6 响应主题"></a>3.1.3.2.6 响应主题</h5><p>响应主题的属性ID是<strong>8 (0x08) Byte</strong>。</p><p>随后跟随 UTF-8字符串，作为响应消息的主题名称。响应主题在属性集中出现超过一次视为协议错误。响应主题的存在表示将遗嘱消息视为一个请求。</p><p>参考 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">4.10</a> 了解关于 请求&#x2F;响应 的更多信息。</p><h5 id="3-1-3-2-7-关联数据"><a href="#3-1-3-2-7-关联数据" class="headerlink" title="3.1.3.2.7 关联数据"></a>3.1.3.2.7 关联数据</h5><p>关联数据的属性ID是<strong>9 (0x09) Byte</strong>。</p><p>随后跟随 二进制数据。请求消息的发送者使用关联数据来识别接收到的响应消息针对哪个请求。关联数据在属性集中出现超过一次视为协议错误。如果关联数据未设置，请求方无需携带任何关联数据。</p><p>关联数据的值仅对请求消息的发送者和响应消息的接收者有意义。</p><p>参考 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">4.10</a> 了解关于 请求&#x2F;响应 的更多信息。</p><h5 id="3-1-3-2-8-用户属性"><a href="#3-1-3-2-8-用户属性" class="headerlink" title="3.1.3.2.8 用户属性"></a>3.1.3.2.8 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 UTF-8字符串对。用户属性允许出现多次来表示多个键值对。同样的键允许出现多次。</p><p><span class="vcMarked">服务器<strong>必须</strong>在发布遗嘱消息时维持用户属性的顺序</span> <span class="vcReferred">[MQTT-3.1.3-10]</span>。</p><p><em>非规范性评论</em></p><p><em>这个属性只是提供一种传输键值对的方式，键值对的含义和解释只有负责发送和接收该属性的应用程序了解。</em></p><h4 id="3-1-3-3-遗嘱主题"><a href="#3-1-3-3-遗嘱主题" class="headerlink" title="3.1.3.3 遗嘱主题"></a>3.1.3.3 遗嘱主题</h4><p>如果遗嘱标识被置为 1，载荷中的下一个字段会是遗嘱主题。<span class="vcMarked">遗嘱主题<strong>必须</strong>是一个 <code>UTF-8字符串</code></span>，参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> 中的定义<span class="vcReferred">[MQTT-3.1.3-11]</span>。</p><h4 id="3-1-3-4-遗嘱载荷"><a href="#3-1-3-4-遗嘱载荷" class="headerlink" title="3.1.3.4 遗嘱载荷"></a>3.1.3.4 遗嘱载荷</h4><p>如果遗嘱标识被置为 1，载荷中的下一个字段会是遗嘱载荷。如同 <a href="#3-1-2-5-%E9%81%97%E5%98%B1%E6%A0%87%E8%AF%86">3.1.2.5</a> 的定义，遗嘱载荷是会被发布遗嘱主题中的应用消息。遗嘱载荷字段内含有二进制数据。</p><h4 id="3-1-3-5-用户名"><a href="#3-1-3-5-用户名" class="headerlink" title="3.1.3.5 用户名"></a>3.1.3.5 用户名</h4><p>如果用户名标识被置为 1，载荷中的下一个字段会是用户名。<span class="vcMarked">用户名<strong>必须</strong>是一个 <code>UTF-8字符串</code></span>，参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> 中的定义<span class="vcReferred">[MQTT-3.1.3-12]</span>。用户名可以被服务器用作认证和授权。</p><h4 id="3-1-3-6-密码"><a href="#3-1-3-6-密码" class="headerlink" title="3.1.3.6 密码"></a>3.1.3.6 密码</h4><p>如果密码标识被置为 1，载荷中的下一个字段会是密码。密码字段内容是 二进制数据。虽然此字段被称为密码，但此字段实际上可以携带任何形式的凭据信息。</p><h3 id="3-1-4-CONNECT动作"><a href="#3-1-4-CONNECT动作" class="headerlink" title="3.1.4 CONNECT动作"></a>3.1.4 CONNECT动作</h3><p>请注意，服务器可以在同一 TCP 端口或其他网络端点上支持多个协议（包括其他版本的 MQTT 协议）。如果服务器确定协议是 MQTT v5.0，则它会按如下方式验证连接尝试。</p><ol><li>如果服务器在客户端的网络连接建立后的一段合理时间内没有收到 CONNECT 包，服务器应该关闭网络连接。</li><li><span class="vcMarked">服务器<strong>必须</strong>验证 CONNECT 包的格式符合 <a href="#3-1-CONNECT-%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82">3.1</a> 中的描述，如不符合则关闭网络连接</span> <span class="vcReferred">[MQTT-3.1.4-1]</span>。服务器可以参考 4.13 在关闭网络连接前使用带有 0x80 或更高值的原因码的 CONNACK 通知客户端。</li><li><span class="vcMarked">服务器<strong>可以</strong>检查 CONNECT 包中的内容是否满足更进一步的限制要求，并且<strong>应该</strong>进行认证和授权检查。如果其中任何检查失败，服务器<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.1.4-2]</span>。在关闭网络连接前，服务器可以参考 <a href="#3-2-CONNACK-%E2%80%93-%E8%BF%9E%E6%8E%A5%E5%9B%9E%E5%A4%8D">3.2</a> 和 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 发送一个带有 0x80 或更高值的原因码的符合情况的 CONNACK 包。</li></ol><p>如果验证成功，服务器施行下列动作。</p><ol><li><span class="vcMarked">如果客户端ID代表了一个已经连接到服务器的客户端，服务器参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 发送一个带有原因码 0x8E（会话被接管）的 DISCONNECT 包到当前已有连接的客户端，且<strong>必须</strong>关闭当前已有连接客户端的网络连接</span> <span class="vcReferred">[MQTT-3.1.4-3]</span>。如果已有连接的客户端包含遗嘱，遗嘱的发布情况参考 3.1.2.5。</li></ol><p><em>非规范性评论</em></p><p><em>如果已有连接的遗嘱延迟间隔值为0且存在遗嘱消息，遗嘱消息会因为网络连接断开的原因发布。当已有连接的会话过期间隔值为0，或是新连接的全新开始标识被置为 1时，如果已有连接存在遗嘱消息，那么遗嘱消息会被发布，因为原有会话已经在接管时结束。</em></p><ol start="2"><li><span class="vcMarked">服务器<strong>必须</strong>参考 <a href="#3-1-2-4-%E5%85%A8%E6%96%B0%E5%BC%80%E5%A7%8B">3.1.2.4</a> 中的描述处理全新开始标识</span> <span class="vcReferred">[MQTT-3.1.4-4]</span>。</li><li><span class="vcMarked">服务器<strong>必须</strong>使用带有原因码为 0x00（成功）的 CONNACK 回复 CONNECT 包</span> <span class="vcReferred">[MQTT-3.1.4-5]</span>。</li></ol><p><em>非规范性评论</em></p><p><em>如果服务器用于处理任何形式的业务关键数据，建议执行身份验证和授权检查。如果这些检查通过，服务器会使用带有原因码 0x00（成功）的 CONNACK 回复。如果检查失败，建议服务器根本不发送 CONNACK，因为这可能会提醒潜在攻击者 MQTT 服务器的存在，并鼓励此类攻击者发起拒绝服务或密码猜测攻击。</em></p><ol start="4"><li>启动消息传递和保活监控。</li></ol><p>客户端可以在发送 CONNECT 包之后立刻发送其他 MQTT 包；客户端无需等待接收到来自服务器的 CONNACK 包。<span class="vcMarked">如果服务器拒绝了 CONNECT，服务器<strong>必须不</strong>处理客户端在 CONNECT 包之后发送的任何除了 AUTH 以外的包</span> <span class="vcReferred">[MQTT-3.1.4-6]</span>。</p><p><em>非规范性评论</em></p><p><em>客户端通常会等待 CONNACK 数据包，然而，客户端可以选择在接受 CONNACK 前发送其他 MQTT 数据包，这样做可能会简化客户端实现，因为客户端无需监管连接状态。客户端需要接受在其收到 CONNACK 前，如果服务器拒绝了连接，其发送的数据都不会被服务器处理。</em></p><p><em>非规范性评论</em></p><p><em>在接收 CONNACK 之前发送其他 MQTT 包的客户端将不知道服务器约束以及是否正在使用任何现有会话。</em></p><p><em>非规范性评论</em></p><p><em>如果客户端在认证完成前就发送了过多的数据，服务器可以限制从网络连接读取数据或关闭网络连接。建议将此作为避免拒绝服务攻击的一种方法。</em></p><h2 id="3-2-CONNACK-连接确认"><a href="#3-2-CONNACK-连接确认" class="headerlink" title="3.2 CONNACK - 连接确认"></a>3.2 CONNACK - 连接确认</h2><p>CONNACK 包是由服务器发送用来响应客户端发送的 CONNECT 包的MQTT包。<span class="vcMarked">服务器<strong>必须</strong>在发送除 AUTH 外的其他任何MQTT包之前使用带有响应码 0x00（成功）的 CONNACK 包回复客户端</span> <span class="vcReferred">[MQTT-3.2.0-1]</span>。<span class="vcMarked">服务器<strong>必须不</strong>在一次网络连接中发送超过一个 CONNACK 包</span> <span class="vcReferred">[MQTT-3.2.0-2]</span>。</p><p>如果客户端没有在合理的时间内收到来自服务器的 CONNACK 包，客户端<strong>应该</strong>断开网络连接。一个“合理”的时间取决于应用程序的类型和通信基础设施。</p><h3 id="3-2-1-CONNACK固定头"><a href="#3-2-1-CONNACK固定头" class="headerlink" title="3.2.1 CONNACK固定头"></a>3.2.1 CONNACK固定头</h3><p>固定头格式参考 图3-7。</p><p><em>图3-7 CONNACK包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（2）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度字段</strong></p><p>这是使用可变整数编码的值，代表可变头的长度。</p><h3 id="3-2-2-CONNACK可变头"><a href="#3-2-2-CONNACK可变头" class="headerlink" title="3.2.2 CONNACK可变头"></a>3.2.2 CONNACK可变头</h3><p>CONNACK 包中的可变头按序包括了下列字段：连接回复标识，连接原因码，属性集。属性集的编码方式参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><h4 id="3-2-2-1-连接回复标识"><a href="#3-2-2-1-连接回复标识" class="headerlink" title="3.2.2.1 连接回复标识"></a>3.2.2.1 连接回复标识</h4><p><span class="vcMarked">Byte 1 是 “连接回复标识”。Bits 7-1 是保留字段，<strong>必须</strong>被置为 0</span> <span class="vcReferred">[MQTT-3.2.2-1]</span>。</p><p>Bit 0 是会话展示标识。</p><h5 id="3-2-2-1-1-会话展示"><a href="#3-2-2-1-1-会话展示" class="headerlink" title="3.2.2.1.1 会话展示"></a>3.2.2.1.1 会话展示</h5><p>会话展示标识位于连接回复标识的 bit 0。</p><p>会话展示标识向客户端通知服务器是否在使用一个与客户端有相同客户端ID的连接的会话状态。这允许客户端和服务器对会话状态是否存在有一致的观点。</p><p><span class="vcMarked">如果服务器接收连接的全新开始标识被置为 1，服务器<strong>必须</strong>在带有 0x00（成功）的原因码的 CONNACK 包中将会话展示置为 0</span> <span class="vcReferred">[MQTT-3.2.2-2]</span>。</p><p><span class="vcMarked">如果服务器接收到的连接中全新开始位被置为 0，且服务器持有对此客户端ID的会话状态，服务器<strong>必须</strong>在 CONNACK 包中将会话展示标识置为 1，其他情况下，服务器都<strong>必须</strong>在 CONNACK 包中将会话展示标识置为 0。这两种情况下服务器都<strong>必须</strong>在 CONNACK 中使用原因码 0x00（成功）</span> <span class="vcReferred">[MQTT-3.2.2-3]</span>。</p><p>如果客户端从服务器接收到的会话展示的值不符合预期，客户端按照如下步骤继续：</p><ul><li><span class="vcMarked">如果客户端不持有会话状态，且接收到的会话展示值为 1，客户端<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.2.2-4]</span>。如果客户端想要使用新的会话重启，客户端可以将全新开始标识置为 1 然后重新连接。</li><li><span class="vcMarked">如果客户端持有会话状态且收到的会话展示值为 0，如果客户端继续使用此网络连接，客户端<strong>必须</strong>丢弃会话状态</span> <span class="vcReferred">[MQTT-3.2.2-5]</span>。</li></ul><p><span class="vcMarked">如果服务器使用非 0 原因码的 CONNACK 包，服务器<strong>必须</strong>将会话展示的值置为 0</span> <span class="vcReferred">[MQTT-3.2.2-6]</span>。</p><h4 id="3-2-2-2-连接原因码"><a href="#3-2-2-2-连接原因码" class="headerlink" title="3.2.2.2 连接原因码"></a>3.2.2.2 连接原因码</h4><p>可变头中的 Byte 2 是连接原因码。</p><p>连接原因码的值如下表所示。当服务器收到一个格式正确的 CONNECT 包，但服务器无法完成连接时，服务器<strong>可以</strong>发送一个带有下表中合适原因码的 CONNACK 包。<span class="vcMarked">如果服务器发送的 CONNACK 包带有一个值为 128 或更高的原因码，服务器<strong>必须</strong>随后关闭网络连接</span> <span class="vcReferred">[MQTT-3.2.2-7]</span>。</p><p><em>表 3-1 原因码值</em></p><table><thead><tr><th>值</th><th>Hex制值</th><th>原因码名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>成功</td><td>连接被接受。</td></tr><tr><td>128</td><td>0x80</td><td>未指定错误</td><td>服务器不希望透露失败的原因，或者其他原因代码均不适用。</td></tr><tr><td>129</td><td>0x81</td><td>格式错误的包</td><td>无法正确解析 CONNECT 包中的数据。</td></tr><tr><td>130</td><td>0x82</td><td>协议错误</td><td>CONNECT 包中的数据不符合此规范。</td></tr><tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>CONNECT 有效，但未被该服务器接受。</td></tr><tr><td>132</td><td>0x84</td><td>不支持的协议版本</td><td>服务器不支持客户端请求的 MQTT 协议版本。</td></tr><tr><td>133</td><td>0x85</td><td>客户端ID无效</td><td>客户端标识符是有效的字符串，但不被服务器允许。</td></tr><tr><td>134</td><td>0x86</td><td>用户名或密码错误</td><td>服务器不接受客户端指定的用户名或密码</td></tr><tr><td>135</td><td>0x87</td><td>未经授权</td><td>客户端无权连接。</td></tr><tr><td>136</td><td>0x88</td><td>服务器无法使用</td><td>MQTT 服务器不可用。</td></tr><tr><td>137</td><td>0x89</td><td>服务器忙</td><td>服务器忙。稍后再试。</td></tr><tr><td>138</td><td>0x8A</td><td>禁止</td><td>该客户端已被管理员禁止。请联系服务器管理员。</td></tr><tr><td>140</td><td>0x8C</td><td>错误的身份验证方法</td><td>该身份验证方法不受支持或与当前使用的身份验证方法不匹配。</td></tr><tr><td>144</td><td>0x90</td><td>主题名称无效</td><td>遗嘱主题名称格式正确，但不被该服务器接受。</td></tr><tr><td>149</td><td>0x95</td><td>数据包太大</td><td>CONNECT 数据包超出了最大允许大小。</td></tr><tr><td>151</td><td>0x97</td><td>超出配额</td><td>已超出实现或管理员设定的限制。</td></tr><tr><td>153</td><td>0x99</td><td>载荷格式错误</td><td>遗嘱载荷与指定的载荷格式标识不匹配。</td></tr><tr><td>154</td><td>0x9A</td><td>不支持保留消息</td><td>服务器不支持保留消息，且遗嘱保留消息被置为 1。</td></tr><tr><td>155</td><td>0x9B</td><td>不支持 QoS</td><td>服务器不支持 QoS，且遗嘱 QoS 被置为 1。</td></tr><tr><td>156</td><td>0x9C</td><td>使用另一台服务器</td><td>客户端应暂时使用另一台服务器。</td></tr><tr><td>157</td><td>0x9D</td><td>服务器已迁移</td><td>客户端应永久使用另一台服务器。</td></tr><tr><td>159</td><td>0x9F</td><td>连接频率超限</td><td>已超出连接速率限制。</td></tr></tbody></table><p><span class="vcMarked">服务器发送的 CONNACK 包<strong>必须</strong>使用上表中之一的原因码</span> <span class="vcReferred">[MQTT-3.2.2-7]</span>。</p><p><em>非规范性评论</em></p><p><em>原因码 0x80（未指定错误）可以用在服务器了解故障原因，但不想透露给客户端的时候，或没有其他合适原因码可用的时候。</em></p><p><em>当在 CONNECT 中发现错误时，服务器可以选择不发送 CONNACK 而直接关闭连接，用以提升安全性。例如，当在一个公共网络中，且连接没有被授权，向客户端透露服务器是 MQTT 服务器可能是不明智的。</em></p><h4 id="3-2-2-3-CONNACK属性集"><a href="#3-2-2-3-CONNACK属性集" class="headerlink" title="3.2.2.3 CONNACK属性集"></a>3.2.2.3 CONNACK属性集</h4><h5 id="3-2-2-3-1-属性长度"><a href="#3-2-2-3-1-属性长度" class="headerlink" title="3.2.2.3.1 属性长度"></a>3.2.2.3.1 属性长度</h5><p>属性长度是变长整数编码的表示 CONNACK 中属性集长度的值。</p><h5 id="3-2-2-3-2-会话过期间隔"><a href="#3-2-2-3-2-会话过期间隔" class="headerlink" title="3.2.2.3.2 会话过期间隔"></a>3.2.2.3.2 会话过期间隔</h5><p>会话过期间隔的属性ID是<strong>17 (0x11) Byte</strong>。</p><p>随后跟随 <code>4字节整数</code> 用来表示会话过期间隔，单位为秒。在属性集中出现超过一次会话过期间隔视为协议错误。</p><p>如果会话过期间隔未设置，则使用 CONNECT 包中的值。服务器通过在 CONNACK 中的此属性告知客户端使用非客户端设置的值。参考 3.1.2.11.2 了解关于会话过期间隔的描述。</p><h5 id="3-2-2-3-3-接收最大值"><a href="#3-2-2-3-3-接收最大值" class="headerlink" title="3.2.2.3.3 接收最大值"></a>3.2.2.3.3 接收最大值</h5><p>接收最大值的属性ID是<strong>33 (0x21) Byte</strong>。</p><p>随后跟随 <code>2字节整数</code> 用来表示有状态数据接收的最大值。接收最大值在属性集中出现超过一次，或接收最大值的值为0，均为协议错误。</p><p>服务器使用此值限制他同时处理的 QoS1 和 QoS2 包发布动作数量。没有任何机制限制客户端可能尝试的对 QoS0 包的发布。</p><p>接收最大值的值仅对当前网络连接有效。如果没有设置接收最大值那么他的默认值是 65535。</p><p>参考 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.9 流量控制</a> 了解关于接收最大值的使用细节。</p><h5 id="3-2-2-3-4-最大QoS"><a href="#3-2-2-3-4-最大QoS" class="headerlink" title="3.2.2.3.4 最大QoS"></a>3.2.2.3.4 最大QoS</h5><p>最大QoS的属性ID是<strong>36 (0x24) Byte</strong>。</p><p>随后跟随值为 0 或 1 的 <code>Byte</code>。最大QoS在属性集中出现超过一次，或最大QoS的值不为 0 或 1，均为协议错误。如果接收最大值未设置，客户端可以使用的最大QoS值为 2。</p><p><span class="vcMarked">如果服务器不支持 QoS 1 或 QoS 2 的 PUBLISH，服务器<strong>必须</strong>发送一个带有其可以支持的最大QoS的 CONNACK 包</span> <span class="vcReferred">[MQTT-3.2.2-9]</span>。<span class="vcMarked">一个不支持 QoS 1 或 QoS 2 PUBLISH 的服务器<strong>必须</strong>依然接收包含 QoS 0、1 或 2 的 SUBSCRIBE 包</span> <span class="vcReferred">[MQTT-3.2.2-10]</span>。</p><p><span class="vcMarked">如果客户端从服务器接收了最大QoS，客户端<strong>必须不</strong>发送 QoS 等级超过最大QoS的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.2.2-11]</span>。服务器收到了超过已指定最大QoS等级的 PUBLISH 包视为协议错误。这种情况下需使用带有原因码 0x9B（不支持的 QoS）的 DISCONNECT 断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 错误处理。</p><p><span class="vcMarked">如果服务器收到包含超过其能力的遗嘱QoS的 CONNECT 数据包，服务器<strong>必须</strong>拒绝连接。服务器<strong>应该</strong>回复带有原因码 0x9B（不支持的 QoS）的 CONNACK 包，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 错误处理，且随后<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.2.2-12]</span>。</p><p><em>非规范性评论</em></p><p><em>客户端不必须支持 QOS 1 或 QOS 2 的 PUBLISH 包。在这种情况下，客户端只需简单的在 SUBSCRIBE 中将最大QoS字段设置为其可支持的值。</em></p><h5 id="3-2-2-3-5-保留消息可用"><a href="#3-2-2-3-5-保留消息可用" class="headerlink" title="3.2.2.3.5 保留消息可用"></a>3.2.2.3.5 保留消息可用</h5><p>保留消息可用的属性ID是<strong>37 (0x25) Byte</strong>。</p><p>随后跟随一个 <code>Byte</code>。当此字段存在时，此 Byte 表示服务器是否支持保留消息。值为 0 表示不支持保留消息。值为 1 表示支持保留消息。如果此字段不存在，默认表示支持保留消息。保留消息可用在属性集中出现超过一次，或保留消息可用的值不为 0 或 1，均为协议错误。</p><p><span class="vcMarked">如果服务器接收到的 CONNECT 包中包含遗嘱消息，且遗嘱保留消息的值为 1，同时服务器不支持保留消息，服务器<strong>必须</strong>拒绝此连接请求。服务器<strong>应该</strong>发送带有原因码 0x9A（不支持保留消息）的 CONNACK 且随后<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.2.2-13]</span>。</p><p><span class="vcMarked">一个收到了服务器发送的保留消息可用值为 0 的客户端，<strong>必须不</strong>发送带有保留消息标识为 1 的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.2.2-14]</span>。如果服务器收到了此种包，视为协议错误。服务器<strong>应该</strong>发送带有原因码为 0x9A（不支持保留消息）的 DISCONNECT 包，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><h5 id="3-2-2-3-6-最大包尺寸"><a href="#3-2-2-3-6-最大包尺寸" class="headerlink" title="3.2.2.3.6 最大包尺寸"></a>3.2.2.3.6 最大包尺寸</h5><p>最大包尺寸的属性ID是<strong>33 (0x21) Byte</strong>。</p><p>随后跟随 <code>4字节整数</code> 用来表示服务器可以接受的最大包尺寸。如果没有设置最大包尺寸，则其受限于固定头中的剩余长度限制，除此外并没有其他限制。</p><p>在属性集中出现超过一次最大包尺寸或其值为 0 均视为协议错误。</p><p>最大包尺寸表示 <strong>MQTT 包完整的字节数</strong>，其定义参考 <a href="#2-1-4-%E5%89%A9%E4%BD%99%E9%95%BF%E5%BA%A6">2.1.4</a>。服务器使用最大包尺寸告知客户端，服务器不会处理超过此尺寸限制的信息。</p><p><span class="vcMarked">客户端<strong>必须不</strong>向服务器发送超过最大包尺寸的数据包</span> <span class="vcReferred">[MQTT-3.2.2-15]</span>。如果服务器收到了超过其最大包尺寸限制的包，这被视为一个协议错误，服务器需要使用带有原因码 0x95（包过大）的 DISCONNECT 包来中断连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 的描述。</p><h5 id="3-2-2-3-7-分配的客户端ID"><a href="#3-2-2-3-7-分配的客户端ID" class="headerlink" title="3.2.2.3.7 分配的客户端ID"></a>3.2.2.3.7 分配的客户端ID</h5><p>分配的客户端ID的属性ID是<strong>18 (0x12) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示被分配的客户端ID。分配的客户端ID在属性集中出现超过一次视为协议错误。</p><p>由于在客户端发送的 CONNECT 包中的客户端ID长度为0，因此由服务器来分配客户端ID。</p><p><span class="vcMarked">如果客户端使用长度为 0 的客户端ID连接，服务器<strong>必须</strong>使用带有分配的客户端ID的 CONNACK 回复。分配的客户端ID<strong>必须</strong>是一个当前所有会话都没有使用的全新ID</span> <span class="vcReferred">[MQTT-3.2.2-16]</span>。</p><h5 id="3-2-2-3-8-主题别名最大值"><a href="#3-2-2-3-8-主题别名最大值" class="headerlink" title="3.2.2.3.8 主题别名最大值"></a>3.2.2.3.8 主题别名最大值</h5><p>主题别名最大值的属性ID是<strong>34 (0x22) Byte</strong>。</p><p>随后跟随 <code>2字节整数</code> 表示主题别名的最大值。在属性集中出现超过一次主题别名最大值视为协议错误。如果主题别名最大值没有设置，则采用默认值 0。</p><p>主题别名最大值表示了服务器可以接受的来自客户端发送的主题别名的最大数量。服务器使用此值来约束他在本次连接中可以持有的主题别名数量。<span class="vcMarked">客户端<strong>必须不</strong>能发送一个主题别名的值大于服务器设置的主题别名最大值的 PUBLISH 包 </span> <span class="vcReferred">[MQTT-3.2.2-17]</span>。主题别名最大值的值为 0 表示服务器在本次连接中不支持任何主题别名。<span class="vcMarked">如果主题别名最大值未设置或值为 0，客户端<strong>必须不</strong>向服务器发送主题别名</span> <span class="vcReferred">[MQTT-3.2.2-18]</span>。</p><h5 id="3-2-2-3-9-原因字符串"><a href="#3-2-2-3-9-原因字符串" class="headerlink" title="3.2.2.3.9 原因字符串"></a>3.2.2.3.9 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示本次响应的原因。原因字符串是一个被设计用来诊断问题的人类可读的字符串，原因字符串<strong>不应该</strong>被客户端解析。</p><p>服务器使用本字段向客户端提供课外的信息。<span class="vcMarked">如果因为添加原因字符串会导致 CONNACK 的包尺寸超过了客户端限制的最大包尺寸，服务器<strong>必须不</strong>发送此属性</span> <span class="vcReferred">[MQTT-3.2.2-19]</span>。原因字符串在属性出现超过一次视为协议错误。</p><p><em>非规范性评论</em></p><p><em>客户端使用原因字符串的正确用法包括将其在异常中抛出或将其写入日志。</em></p><h5 id="3-2-2-3-10-用户属性"><a href="#3-2-2-3-10-用户属性" class="headerlink" title="3.2.2.3.10 用户属性"></a>3.2.2.3.10 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用来向客户端提供包括诊断消息在内的扩展信息。<span class="vcMarked">如果添加该属性会导致 CONNACK 的包尺寸大于客户端设置的最大包尺寸，服务器<strong>必须不</strong>添加此属性</span> <span class="vcReferred">[MQTT-3.2.2-20]</span>。用户属性可以出现多次，用来携带多个 键-值 对。同样的 键 允许出现超过一次。</p><p>本属性的内容和含义不由本规范定义。CONNACK 的接收者在接收到本属性后<strong>可以</strong>选择忽略。</p><h5 id="3-2-2-3-11-通配符订阅可用"><a href="#3-2-2-3-11-通配符订阅可用" class="headerlink" title="3.2.2.3.11 通配符订阅可用"></a>3.2.2.3.11 通配符订阅可用</h5><p>通配符订阅可用的属性ID是<strong>40 (0x28) Byte</strong>。</p><p>随后跟随一个 <code>Byte</code>。当该字段存在时，该 byte 表示服务器是否支持通配符订阅。值为 0 表示不支持通配符订阅。值为 1 表示支持通配符订阅。当该字段不存在时，默认表示支持通配符订阅。通配符订阅可用在属性集中出现超过一次，或其值不为 0 或者 1，均视为协议错误。</p><p>如果服务器不支持通配符订阅，但接收到了一个包含通配符的 SUBSCRIBE 包，则视为一个协议错误。服务器需要使用带有原因码 0xA2（不支持通配符订阅）的 DISCONNECT 包断开连接，具体参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><p>如果服务器支持通配符订阅，他仍然可以拒绝包含某种特别通配符的订阅请求。在这种情况下服务器<strong>可以</strong>发送一个带有原因码 0xA2（不支持通配符订阅）的 SUBACK包。</p><h5 id="3-2-2-3-12-订阅ID可用"><a href="#3-2-2-3-12-订阅ID可用" class="headerlink" title="3.2.2.3.12 订阅ID可用"></a>3.2.2.3.12 订阅ID可用</h5><p>订阅ID可用的属性ID是<strong>41 (0x29) Byte</strong>。</p><p>随后跟随一个 <code>Byte</code>。当该字段存在时，该 byte 表示服务器是否支持订阅ID。值为 0 表示不支持订阅ID。值为 1 表示支持订阅ID。当该字段不存在时，默认表示支持订阅ID。订阅ID可用在属性集中出现超过一次，或其值不为 0 或者 1，均视为协议错误。</p><p>如果服务器不支持订阅ID，但接收到了一个包含订阅ID的 SUBSCRIBE 包，则视为一个协议错误。服务器需要使用带有原因码 0xA1（不支持订阅ID）的 DISCONNECT 包断开连接，具体参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><h5 id="3-2-2-3-13-共享订阅可用"><a href="#3-2-2-3-13-共享订阅可用" class="headerlink" title="3.2.2.3.13 共享订阅可用"></a>3.2.2.3.13 共享订阅可用</h5><p>共享订阅可用的属性ID是<strong>42 (0x2A) Byte</strong>。</p><p>随后跟随一个 <code>Byte</code>。当该字段存在时，该 byte 表示服务器是否支持共享订阅。值为 0 表示不支持共享订阅。值为 1 表示支持共享订阅。当该字段不存在时，默认表示支持共享订阅。共享订阅可用在属性集中出现超过一次，或其值不为 0 或者 1，均视为协议错误。</p><p>如果服务器不支持共享订阅，但接收到了一个包含共享订阅的 SUBSCRIBE 包，则视为一个协议错误。服务器要使用带有原因码 0x9E（不支持共享订阅）的 DISCONNECT 包断开连接，具体参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><h5 id="3-2-2-3-14-服务器保活时间"><a href="#3-2-2-3-14-服务器保活时间" class="headerlink" title="3.2.2.3.14 服务器保活时间"></a>3.2.2.3.14 服务器保活时间</h5><p>服务器保活时间的属性ID是<strong>19 (0x13) Byte</strong>。</p><p>随后跟随一个 <code>2字节整数</code> 表示服务器指定的保活时间。<span class="vcMarked">如果服务器在 CONNACK 中发送了服务器保活时间，客户端<strong>必须</strong>使用此值代替其在 CONNECT 中发送的保活时间</span> <span class="vcReferred">[MQTT-3.2.2-21]</span>。<span class="vcMarked">如果服务器没有设置服务器保活时间，服务器<strong>必须</strong>使用客户端在 CONNECT 包中设置的保活时间</span> <span class="vcReferred">[MQTT-3.2.2-22]</span>。服务器保活时间在属性集中出现超过一次视为协议错误。</p><p><em>非规范性评论</em></p><p><em>服务器保活时间的主要用途是让服务器通知客户端，他将比客户端指定的保活时间更早地断开与客户端的不活动连接。</em></p><h5 id="3-2-2-3-15-响应信息"><a href="#3-2-2-3-15-响应信息" class="headerlink" title="3.2.2.3.15 响应信息"></a>3.2.2.3.15 响应信息</h5><p>响应信息的属性ID是<strong>26 (0x1A) Byte</strong>。</p><p>随后跟随一个 <code>UTF-8字符串</code> 用来表示构建响应主题的基础。客户端如何通过响应信息构建响应主题不由本规范定义。响应信息在属性集中出现超过一次视为协议错误。</p><p>如果客户端发送的请求响应信息值为 1，服务器<strong>可选</strong>则是否在 CONNACK 中包括响应信息。</p><p><em>非规范性评论</em></p><p><em>响应信息的常见用法是将响应信息作为响应主题中的某一部分，该部分为此客户端在其会话周期内保留。这一部分往往不能是一个随机的名称，因为请求客户端和响应客户端都需要通过授权才能使用此主题。这部分通常特定客户端的主题树的跟。为了让服务器能够返回此信息，通常需要进行一些正确的配置。使用本机制可以在服务端一次性配置响应信息，而非是在请求客户端和响应客户端中各自完成。</em></p><p>参考 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">4.10</a> 了解更多关于 请求&#x2F;响应 的信息。</p><h5 id="3-2-2-3-16-服务引用"><a href="#3-2-2-3-16-服务引用" class="headerlink" title="3.2.2.3.16 服务引用"></a>3.2.2.3.16 服务引用</h5><p>服务引用的属性ID是<strong>28 (0x1C) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code>，可被客户端用于定位到另一台服务器。服务引用在属性集中出现超过一次视为协议错误。</p><p>服务器在原因码为 0x9C（使用另一台服务器）或 0x9D（服务器迁移）的 CONNACK 或 DISCONNECT 包中使用服务引用，具体用法参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><p>参考 <a href="#4-11-%E6%9C%8D%E5%8A%A1%E9%87%8D%E5%AE%9A%E5%90%91">4.11</a> 了解服务引用的用法。</p><h5 id="3-2-2-3-17-认证方式"><a href="#3-2-2-3-17-认证方式" class="headerlink" title="3.2.2.3.17 认证方式"></a>3.2.2.3.17 认证方式</h5><p>认证方式的属性ID是<strong>21 (0x15) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code>，内含认真方式的名称。认证方式在属性集中出现超过一次视为协议错误。参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 了解跟多关于增强认证的信息。</p><h5 id="3-2-2-3-18-认证数据"><a href="#3-2-2-3-18-认证数据" class="headerlink" title="3.2.2.3.18 认证数据"></a>3.2.2.3.18 认证数据</h5><p>认证数据的属性ID是<strong>22 (0x16) Byte</strong>。</p><p>随后跟随 <code>二进制数据</code>，内含认证数据。数据的内容由认证方式和当然交换状态定义。认证数据在属性集中出现超过一次视为协议错误。参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 了解跟多关于增强认证的信息。</p><h3 id="3-2-3-CONNACK载荷"><a href="#3-2-3-CONNACK载荷" class="headerlink" title="3.2.3 CONNACK载荷"></a>3.2.3 CONNACK载荷</h3><p>CONNACK 没有载荷。</p><h2 id="3-3-PUBLISH-发布消息"><a href="#3-3-PUBLISH-发布消息" class="headerlink" title="3.3 PUBLISH - 发布消息"></a>3.3 PUBLISH - 发布消息</h2><p>PUBLISH 包可以由客户端发往服务端，或由服务端发往客户端，用于传输应用消息。</p><h3 id="3-3-1-PUBLISH-固定头"><a href="#3-3-1-PUBLISH-固定头" class="headerlink" title="3.3.1 PUBLISH 固定头"></a>3.3.1 PUBLISH 固定头</h3><p><em>图 3‑8 – PUBLISH 包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（3）</td><td>重复标识</td><td colspan="2">QoS等级</td><td>保留消息</td></tr>    <tr><td></td><td>0</td><td>0</td><td>1</td><td>1</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>    <tr><td>byte 2...</td><td colspan="8">剩余长度</td></tr>  </tbody></table><h4 id="3-3-1-1-重复标识"><a href="#3-3-1-1-重复标识" class="headerlink" title="3.3.1.1 重复标识"></a>3.3.1.1 重复标识</h4><p><strong>位置：</strong> byte 1，bit 3。</p><p>如果重复标识的值为 0，这表示这是客户端或服务器第一次尝试发送此 PUBLISH 包。如果重复标识的值为 1，这表示本包可能是之前尝试发送包的重传。</p><p><span class="vcMarked">当客户端或服务器尝试重传 PUBLISH 包时，他们<strong>必须</strong>把重复标志置为 1</span> <span class="vcReferred">[MQTT-3.3.1-1]</span>。<span class="vcMarked">对于 QoS 0 的消息，重复标识<strong>必须</strong>被置为 0</span> <span class="vcReferred">[MQTT-3.3.1-2]</span>。</p><p>当服务器将 PUBLISH 包转发给订阅者时，来自传入 PUBLISH 包的重复标识不会传播。<span class="vcMarked">转发的 PUBLISH 包的重复标识独立于接收的 PUBLISH 包，此值仅被本次转发包是否为重传独立决定</span> <span class="vcReferred">[MQTT-3.3.1-3]</span>。</p><p><em>非规范性评论</em></p><p><em>MQTT包的接收方接收到重复标志为 1 的包并不能假设他已经接收到了此包的早期副本。</em></p><p><em>非规范性评论</em> </p><p><em>需要注意的是，重复标识仅表示 MQTT 包的重复，并不能表示其中应用消息的重复。当使用 QoS 1 时，客户端有可能接收到重复标志为 0 的包，但其中包含的应用消息却是早已接收的，只是包ID不同。章节 <a href="#2-2-1-%E5%8C%85ID">2.2.1</a> 提供了更多关于包ID的信息。</em></p><h4 id="3-3-1-2-QoS"><a href="#3-3-1-2-QoS" class="headerlink" title="3.3.1.2 QoS"></a>3.3.1.2 QoS</h4><p><strong>位置：</strong> byte 1，bit 2-1。</p><p>该字段表示应用消息传送的保障级别。QoS 级别如下表所示。</p><p>表 3-2 QoS 定义</p><table><thead><tr><th>QoS 值</th><th>bit 2</th><th>bit 1</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>至多一次</td></tr><tr><td>1</td><td>0</td><td>1</td><td>至少一次</td></tr><tr><td>2</td><td>1</td><td>0</td><td>确保一次</td></tr><tr><td>-</td><td>1</td><td>1</td><td>保留 - 不可使用</td></tr></tbody></table><p>如果客户端在 CONNACK 中向服务器提示了最大QoS，之后收到了超过最大QoS值的 PUBLISH 包，服务器使用带有原因码 0x9B（不支持的QoS）的 DISCONNECT 包断开连接，如同 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中的描述。</p><p><span class="vcMarked">PUBLISH 包<strong>必须不</strong>能将 QoS 的两个 bit 都设置为 1</span> <span class="vcReferred">[MQTT-3.3.1-4]</span>。如果服务器或者客户端接收到了两个 bit 都为 1 的 PUBLISH 包，视为格式错误的包，使用带有原因码 0x81（格式错误的包）的 DISCONNECT 断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><h4 id="3-3-1-3-保留消息"><a href="#3-3-1-3-保留消息" class="headerlink" title="3.3.1.3 保留消息"></a>3.3.1.3 保留消息</h4><p><strong>位置：</strong> byte 1，bit 0。</p><p><span class="vcMarked">当客户端向服务器发送的 PUBLISH 包中的保留消息被置为 1 时，服务器<strong>必须</strong>在此主题下保存此应用消息，替换任何已经存在的消息</span> <span class="vcReferred">[MQTT-3.3.1-5]</span>，之后该保留消息可以被发布给订阅该主题的订阅者。<span class="vcMarked">如果载荷为空，服务器照常处理，只不过该同名主题下现有的保留消息<strong>必须</strong>被移除，未来的订阅者也不会再收到保留消息</span> <span class="vcReferred">[MQTT-3.3.1-6]</span>。<span class="vcMarked">带有空载荷的保留消息<strong>必须不</strong>被服务器作为保留消息存储</span> <span class="vcReferred">[MQTT-3.3.1-7]</span>。</p><p><span class="vcMarked">如果客户端发送到服务器的 PUBLISH 包中的保留消息值为 0，服务器<strong>必须不</strong>将该消息作为保留消息存储且<strong>必须不</strong>删除或替换已经存在的保留消息</span> <span class="vcReferred">[MQTT-3.3.1-8]</span>。</p><p>如果服务器回复的 CONNACK 带有保留消息可用标识且其值为 0，此时服务器又收到了带有保留消息值为 1 的 PUBLISH 包，服务器需使用带有原因码 0x9A（不支持保留消息）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><p>当一个新的非共享订阅创建时，如果存在保留消息，每个匹配主题名上的保留消息都按照订阅选项中的保留消息处理标识的指示发往客户端。这些消息发送时的保留消息标识都置为 1。保留消息是否发送由订阅选项中的保留消息处理字段控制。当客户端进行订阅时：</p><ul><li><span class="vcMarked">如果保留消息处理值为 0，服务器<strong>必须</strong>将匹配订阅主题过滤器的保留消息发送给客户端</span> <span class="vcReferred">[MQTT-3.3.1-9]</span>。</li><li><span class="vcMarked">如果保留消息处理值为 1，当该订阅之前不存在时，服务器<strong>必须</strong>将匹配订阅主题过滤器的保留消息发送给客户端，反之当该订阅之前存在时，服务器<strong>必须不</strong>发送保留消息</span> <span class="vcReferred">[MQTT-3.3.1-10]</span>。</li><li><span class="vcMarked">如果保留消息处理值为 2，服务器<strong>必须不</strong>发送保留消息</span> <span class="vcReferred">[MQTT-3.3.1-11]</span>。</li></ul><p>参考 <a href="#3-8-3-1-%E8%AE%A2%E9%98%85%E9%80%89%E9%A1%B9">3.8.3.1</a> 了解关于订阅选项的定义。</p><p>当服务器接收到保留消息值为 1，QoS 值为 0 的 PUBLISH 包，服务器<strong>应该</strong>存储这个新的 QoS 值为 0 的消息作为该主题新的保留消息，但是<strong>可以</strong>在任何时候丢弃他。如果服务器丢弃了该消息，该主题下将没有保留消息。</p><p>如果主题下的保留消息过期，他将会被丢弃且主题下将没有保留消息。</p><p>服务器向已经建立的连接转发的应用消息中保留消息的值是由订阅选项中的保留消息引用发布选项决定的。参考 <a href="#3-8-3-1-%E8%AE%A2%E9%98%85%E9%80%89%E9%A1%B9">3.8.3.1</a> 了解关于订阅选项的定义。</p><ul><li><span class="vcMarked">如果保留消息引用发布的值为 0，服务器<strong>必须</strong>在转发应用消息时将保留消息值置为 0，无论其收到的 PUBLISH 包中的保留消息值如何设置</span> <span class="vcReferred">[MQTT-3.3.1-12]</span>。</li><li><span class="vcMarked">如果保留消息引用发布的值为 1，服务器<strong>必须</strong>使用和收到的 PUBLISH 包中保留消息值相同的保留消息值</span> <span class="vcReferred">[MQTT-3.3.1-13]</span>。</li></ul><p><em>非规范性评论</em></p><p><em>当发布者不规律的发布状态消息时，保留消息非常有用。新的非共享订阅者会受到最新的状态。</em></p><h4 id="3-3-1-4-剩余长度"><a href="#3-3-1-4-剩余长度" class="headerlink" title="3.3.1.4 剩余长度"></a>3.3.1.4 剩余长度</h4><p>剩余长度是 <code>变长整数</code>，表示可变头与载荷的总长度。</p><h3 id="3-3-2-PUBLISH可变头"><a href="#3-3-2-PUBLISH可变头" class="headerlink" title="3.3.2 PUBLISH可变头"></a>3.3.2 PUBLISH可变头</h3><p>PUBLISH 可变头按顺序包含下列字段：主题名称，包ID，属性集。属性集的编码规则参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><h4 id="3-3-2-1-主题名称"><a href="#3-3-2-1-主题名称" class="headerlink" title="3.3.2.1 主题名称"></a>3.3.2.1 主题名称</h4><p>主题名称决定了载荷发布的信息通道。</p><p><span class="vcMarked">主题名称<strong>必须</strong>作为 PUBLISH 包可变头的第一个字段。他<strong>必须</strong>采用 <code>UTF-8字符串</code> 编码</span>，定义参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> <span class="vcReferred">[MQTT-3.3.2-1]</span>。</p><p><span class="vcMarked">PUBLISH 包中的主题名称<strong>必须不</strong>包含通配符</span> <span class="vcReferred">[MQTT-3.3.2-2]</span>。</p><p><span class="vcMarked">服务器发往客户端的 PUBLISH 包中的主题名称必须匹配订阅者的主题过滤器</span>，匹配流程参考 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">4.7</a> <span class="vcReferred">[MQTT-3.3.2-3]</span>。然而，考虑到服务器允许进行主题名称映射，转发的 PUBLISH 包的主题名称可以与原始 PUBLISH 包的主题名称不同。</p><p>为了减少 PUBLISH 包的尺寸，发送者可以使用主题别名。主题别名的描述参考 <a href="#3-3-2-3-4-%E4%B8%BB%E9%A2%98%E5%88%AB%E5%90%8D">3.3.2.3.4</a>。主题名称长度为 0 且没有主题别名视为协议错误。</p><h4 id="3-3-2-2-包ID"><a href="#3-3-2-2-包ID" class="headerlink" title="3.3.2.2 包ID"></a>3.3.2.2 包ID</h4><p>仅当 QoS 等级为 1 或 2 的 PUBLISH 包中存在包ID字段，章节 <a href="#2-2-1-%E5%8C%85ID">2.2.1</a> 提供了更多关于包ID的信息。</p><h4 id="3-3-2-3-PUBLISH属性集"><a href="#3-3-2-3-PUBLISH属性集" class="headerlink" title="3.3.2.3 PUBLISH属性集"></a>3.3.2.3 PUBLISH属性集</h4><h5 id="3-3-2-3-1-属性长度"><a href="#3-3-2-3-1-属性长度" class="headerlink" title="3.3.2.3.1 属性长度"></a>3.3.2.3.1 属性长度</h5><p>属性长度是变长整数编码的表示 PUBLISH 中属性集长度的值。</p><h5 id="3-3-2-3-2-载荷格式标识"><a href="#3-3-2-3-2-载荷格式标识" class="headerlink" title="3.3.2.3.2 载荷格式标识"></a>3.3.2.3.2 载荷格式标识</h5><p>载荷格式标识的属性ID是<strong>1 (0x01) Byte</strong>。</p><p>随后跟随的值表示载荷格式，二选其一：</p><ul><li>0（0x00）Byte 表示载荷格式未指定，等同于没有发送载荷格式字段。</li><li>1（0x01）Byte 表示载荷是UTF-8编码的字符数据。载荷中的UTF-8数据<strong>必须</strong>是编码良好的UTF-8格式，符合 <a href="#1.3-Unicode">Unicode</a> 规范和 <a href="#1.3-RFC3629">RFC3629</a>。</li></ul><p><span class="vcMarked">服务器<strong>必须</strong>将载荷格式标识原封不动的发送给所有应用消息的接收者</span> <span class="vcReferred">[MQTT-3.3.2-4]</span>。接收者<strong>可以</strong>验证载荷是否和更是标志匹配，当不匹配时，发送带有原因码 0x99（载荷格式错误）的 PUBACK、PUBREC 或 DISCONNECT，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。参考 <a href="#5-4-9-%E5%A4%84%E7%90%86%E7%A6%81%E6%AD%A2%E7%9A%84Unicode%E7%A0%81%E6%AE%B5">5.4.9</a> 了解关于验证载荷格式的安全建议。</p><h5 id="3-3-2-3-3-消息过期间隔"><a href="#3-3-2-3-3-消息过期间隔" class="headerlink" title="3.3.2.3.3 消息过期间隔"></a>3.3.2.3.3 消息过期间隔</h5><p>载荷格式标识的属性ID是<strong>2 (0x02) Byte</strong>。</p><p>随后跟随 <code>4字节整数</code>，表示消息过期间隔。</p><p><span class="vcMarked">当该字段存在时，此四字节的值表示以秒为单位的应用消息生命时间。如果消息过期间隔已经超时，且服务器尚未设法开始向前传递到匹配的订阅者，服务器<strong>必须</strong>删除面向该订阅者的该消息的副本</span> <span class="vcReferred">[MQTT-3.3.2-5]</span>。</p><p>如果该字段不存在，应用消息不会过期。</p><p><span class="vcMarked">客户端发送给服务器的 PUBLISH 包中的消息过期间隔<strong>必须</strong>被设置为服务器接收的消息过期间隔的值减去消息在服务器中等待的时间</span> <span class="vcReferred">[MQTT-3.3.2-6]</span>。参考 <a href="#4-1-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">4.1</a> 了解关于存储状态的更多细节和限制。</p><h5 id="3-3-2-3-4-主题别名"><a href="#3-3-2-3-4-主题别名" class="headerlink" title="3.3.2.3.4 主题别名"></a>3.3.2.3.4 主题别名</h5><p>主题别名的属性ID是<strong>35 (0x23) Byte</strong>。</p><p>随后跟随 <code>2字节整数</code> 表示主题别名的值。主题别名在属性集中出现超过一次视为协议错误。</p><p>主题别名是一个用于替代主题名来区分主题的整数值。使用主题别名可以减少 PUBLISH 包的尺寸，主题别名在主题名较长且同一个主题名被反复使用的网络连接中有很大作用。</p><p>发送者可以决定是否使用主题别名，以及主题别名的值。他在 PUBLISH 包中创建了一个非零长度主题名和主题别名值的映射。接收者正常处理 PUBLISH 包，但需要同样添加该主题别名到主题名的映射。</p><p>一旦接收者设置了主题别名的映射，发送者可以发送包含主图别名的 PUBLISH 包，其中主题名可以为零长度。接收者将按照其中包含正常主题名的方式对待此 PUBLISH 包。</p><p>发送者可以在同一网络连接中通过再次发送一个带有相同的主题别名和不同的主题名 PUBLISH 包的方式改变主题别名的映射。</p><p>主题别名映射仅在单次网络连接中存在，其生命周期等同于网络连接的生命周期。<span class="vcMarked">接收者<strong>必须不</strong>能将主题别名从一个网络连接转发到另一个网络连接</span> <span class="vcReferred">[MQTT-3.3.2-7]</span>。</p><p>主题别名的值不可为 0。<span class="vcMarked">发送者<strong>必须不</strong>能发送一个包含主题别名值为 0 的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.3.2-8]</span>。</p><p><span class="vcMarked">客户端<strong>必须不</strong>发送包含主题别名值超过服务器 CONNACK 中设置的主题别名最大值的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.3.2-9]</span>。<span class="vcMarked">客户端<strong>必须</strong>接收所有大于 0 且小于或等于其 CONNECT 包中设置的主题别名最大值的主题别名</span> <span class="vcReferred">[MQTT-3.3.2-10]</span>。</p><p><span class="vcMarked">服务器<strong>必须不</strong>发送包含主题别名值超过客户端 CONNECT 包中设置的主题别名最大值的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.3.2-11]</span>。<span class="vcMarked">服务器<strong>必须</strong>接收所有大于 0 且小于等于其 CONNACK 包中设置的主题别名最大值的主题别名</span> <span class="vcReferred">[MQTT-3.3.2-12]</span>。</p><p>客户端和服务器使用的主题别名映射是互相独立的。因此，当一个客户端发送的 PUBLISH 包中的主题别名为 1，同时服务器发送的 PUBLISH 包中的主题别名也为 1 一般来说引用了不同的主题。</p><h5 id="3-3-2-3-5-响应主题"><a href="#3-3-2-3-5-响应主题" class="headerlink" title="3.3.2.3.5 响应主题"></a>3.3.2.3.5 响应主题</h5><p>响应主题的属性ID是<strong>8 (0x08) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 作为响应消息的主题名。<span class="vcMarked">响应主题<strong>必须</strong>使用 <code>UTF-8字符串</code> 格式</span>，其定义参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> <span class="vcReferred">[MQTT-3.3.2-13]</span>。<span class="vcMarked">响应主题<strong>必须不</strong>包含通配符</span> <span class="vcReferred">[MQTT-3.3.2-14]</span>。响应主题在属性集中出现超过一次视为协议错误。响应主题的出现表示该消息是一个请求。</p><p>参考 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">4.10</a> 了解更多关于 请求&#x2F;响应 的信息。</p><p><span class="vcMarked">服务器<strong>必须</strong>向所有接收该应用消息的订阅者原封不动的转发响应主题</span> <span class="vcReferred">[MQTT-3.3.2-15]</span>。</p><p><em>非规范性评论</em></p><p><em>带有响应主题的应用消息的接收者通过使用响应主题作为 PUBLISH 的主题名称来发送响应。如果请求消息包含关联数据，则响应方还应该将该关联数据作为响应消息的 PUBLISH 数据包中的属性。</em></p><h5 id="3-3-2-3-6-关联数据"><a href="#3-3-2-3-6-关联数据" class="headerlink" title="3.3.2.3.6 关联数据"></a>3.3.2.3.6 关联数据</h5><p>关联数据的属性ID是<strong>9 (0x09) Byte</strong>。</p><p>随后跟随 <code>二进制数据</code>。关联数据是由发送方添加在请求消息里，用于在响应消息中确定响应消息和请求消息的关联关系。关联数据在属性集中出现超过一次视为协议错误。如果没有设置关联数据，表示请求者无需任何关联数据。</p><p><span class="vcMarked">服务器<strong>必须</strong>将关联数据原封不动的转发给接收应用消息的订阅者</span> <span class="vcReferred">[MQTT-3.3.2-16]</span>。关联数据的值仅对请求的发送者和响应的接收者有意义。</p><p><em>非规范性评论</em></p><p><em>接受了包含响应主题和关联数据的应用消息的接收者，通过响应主题发送 PUBLISH 包作为响应。同时也应该在响应的 PUBLISH 包中原封不动的设置关联数据。</em></p><p><em>非规范性评论</em></p><p><em>如果响应中的关联数据内容改变会导致应用程序故障，那么此数据应该通过加密、哈希等手段来确保其改变可以被监测。</em></p><p>参考 <a href="#4-10-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94">4.10</a> 了解更多关于 请求&#x2F;响应 的信息。</p><h5 id="3-3-2-3-7-用户属性"><a href="#3-3-2-3-7-用户属性" class="headerlink" title="3.3.2.3.7 用户属性"></a>3.3.2.3.7 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。用户属性可以出现多次，用来携带多个 键-值 对。同样的 键 允许出现超过一次。</p><p><span class="vcMarked">服务器<strong>必须</strong>将 PUBLISH 包中的所有用户属性原封不动的转发给客户端</span> <span class="vcReferred">[MQTT-3.3.2-17]</span>。<span class="vcMarked">服务器<strong>必须</strong>在转发应用消息时维护用户属性的顺序</span> <span class="vcReferred">[MQTT-3.3.2-18]</span>。</p><p><em>非规范性评论</em></p><p><em>该属性旨在提供一种传输应用层键-值对的方法，其含义和解释只有负责发送和接收它们的应用程序了解。</em></p><h5 id="3-3-2-3-8-订阅ID"><a href="#3-3-2-3-8-订阅ID" class="headerlink" title="3.3.2.3.8 订阅ID"></a>3.3.2.3.8 订阅ID</h5><p>订阅ID的属性ID是<strong>11 (0x0B) Byte</strong>。</p><p>随后跟随 <code>变长整数</code> 表示订阅动作的ID。</p><p>订阅ID的取值范围是 1 到 268435455。订阅ID的值为0视为协议错误。如果本次发布是匹配了多次重复订阅的发布，属性集中出现多次订阅ID也是合理的，此种情况下他们的顺序不重要。</p><h5 id="3-3-2-3-9-内容类型"><a href="#3-3-2-3-9-内容类型" class="headerlink" title="3.3.2.3.9 内容类型"></a>3.3.2.3.9 内容类型</h5><p>内容类型的属性ID是<strong>3 (0x03) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 描述了应用消息的内容类型。<span class="vcMarked">内容类型<strong>必须</strong>是 <code>UTF-8字符串</code> 格式</span>，其定义参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> <span class="vcReferred">[MQTT-3.3.2-19]</span>。</p><p>内容格式在属性集中出现超过一次视为协议错误。内容格式的值由发送方和接收方定义。</p><p><span class="vcMarked">服务器<strong>必须</strong>将内容格式原封不动的转发给所有接收应用消息的订阅者</span> <span class="vcReferred">[MQTT-3.3.2-20]</span>。</p><p><em>非规范性评论</em></p><p><em>这个UTF-8编码的字符串可以使用 MIME 类型字符串来描述应用消息的类型。当然，由于该字段由发送方和接收方负责定义和解释，MQTT不会检查该字段的内容或格式。</em></p><p><em>非规范性示例</em></p><p><em>图 3-9 展示了一个 PUBLISH 包的例子，其主题名为 “a&#x2F;b”，其包ID为10，且没有属性集。</em></p><p>图 3-9 PUBLISH 包可变头非规范性示例</p><table>  <thead>    <tr>      <td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>    </tr>  </thead>  <tbody>    <tr>      <td colspan="10">主题名称</td>    </tr>    <tr>      <td>byte 1</td><td>长度高位（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 2</td><td>长度低位（LSB）（3）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td>    </tr>    <tr>      <td>byte 3</td><td>'a'（0x61）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 4</td><td>'/'（0x2F）</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td>    </tr>    <tr>      <td>byte 5</td><td>'b'（0x62）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td>    </tr>    <tr>      <td colspan="10">包ID</td>    </tr>    <tr>      <td>byte 6</td><td>包ID高位（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 7</td><td>包ID低位（LSB）（10）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td>    </tr>    <tr>      <td colspan="10">属性集长度</td>    </tr>    <tr>      <td>byte 8</td><td>无属性</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>  </tbody></table><h3 id="3-3-3-PUBLISH载荷"><a href="#3-3-3-PUBLISH载荷" class="headerlink" title="3.3.3 PUBLISH载荷"></a>3.3.3 PUBLISH载荷</h3><p>载荷包含着被发布的应用消息。其内容和格式是由应用程序选择的。载荷的长度可由可变头中的剩余长度字段减去可变头长度计算所得。PUBLISH 包携带 0 长度的载荷也是合法的。</p><h3 id="3-3-4-PUBLISH动作"><a href="#3-3-4-PUBLISH动作" class="headerlink" title="3.3.4 PUBLISH动作"></a>3.3.4 PUBLISH动作</h3><p><span class="vcMarked">PUBLISH 包的接收者<strong>必须</strong>使用 PUBLISH 包中 QoS 对应的方式响应此包</span> <span class="vcReferred">[MQTT-3.3.4-1]</span>。</p><p>表 3-3 PUBLISH 包响应方式</p><table><thead><tr><th>Qos等级</th><th>响应方式</th></tr></thead><tbody><tr><td>QoS 0</td><td>无</td></tr><tr><td>QoS 1</td><td>PUBACK 包</td></tr><tr><td>QoS 2</td><td>PUBREC 包</td></tr></tbody></table><p>客户端使用 PUBLISH 包将应用消息发送给服务器，以便由服务器转发给相关订阅者。</p><p>服务器使用 PUBLISH 包将应用消息发给每个匹配的订阅者客户端。如果订阅时的 SUBSCRIBE 包携带有订阅ID，则 PUBLISH 包也携带此订阅ID。</p><p>当客户端使用带有通配符的主题过滤器订阅时，客户端的订阅可能会重叠，因此一次消息发布可能匹配多个过滤器。<span class="vcMarked">在这种情况下服务器<strong>必须</strong>使用这些重叠订阅中最高的 QoS 等级来发布此数据</span> <span class="vcReferred">[MQTT-3.3.4-2]</span>。此外，服务器可以发送此信息的多个副本，每个额外的订阅发送一个副本，且采用每个订阅建立时的 QoS 设置。</p><p>如果客户端收到一个不请自来的应用消息（并非来自其订阅的频道），其中包括了超过客户端最大 QoS 的 QoS，客户端将使用带有原因码 0x9B（不支持的 QoS）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中的描述。</p><p><span class="vcMarked">如果客户端在重叠订阅时设置了订阅ID，服务器<strong>必须</strong>在为该订阅发布消息时将订阅ID放入消息中</span> <span class="vcReferred">[MQTT-3.3.4-3]</span>。<span class="vcMarked">如果服务器发送该消息的单一副本，服务器<strong>必须</strong>将所有包含订阅ID的订阅动作的订阅ID放入 PUBLISH 包中，他们的顺序不重要</span> <span class="vcReferred">[MQTT-3.3.4-4]</span>。<span class="vcMarked">如果服务器发送该消息的多个副本，服务器<strong>必须</strong>在每个副本中放入对应订阅动作的订阅ID</span> <span class="vcReferred">[MQTT-3.3.4-5]</span>。</p><p>客户端可能对某个发布动作进行了多次订阅，且使用相同的订阅ID。在这种情况下，PUBLISH 包将携带多个相同的订阅ID。</p><p>PUBLISH 包因接收 SUBSCRIBE 包携带的订阅ID之外，通过其他方式携带订阅ID视为协议错误。<span class="vcMarked">从客户端发往服务器的 PUBLISH 包<strong>必须不</strong>携带订阅ID</span> <span class="vcReferred">[MQTT-3.3.4-6]</span>。</p><p>如果是共享订阅，则只有正在接收消息的客户端发送的 SUBSCRIBE 包中的订阅ID会在 PUBLISH 包中返回。</p><p>PUBLISH 包的接收者基于QoS等级的动作描述参考 <a href="#4-3-QoS%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B">4.3</a>。</p><p>如果 PUBLISH 包包含主题别名，接收者按照如下流程处理：</p><ol><li>主题别名值为 0 或大于主题别名最大值视为协议错误，接收者使用带有原因码 0x94（主题别名不可用）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</li><li>如果接收者已经建立了对该主题别名的映射，则</li></ol><ul><li>如果包中的主题名长度为 0，则接收者使用主题别名对应的主题名</li><li>如果包中的主题名长度不为 0，则接收者使用该主题名处理此包，随后更新主题别名映射，将主题别名与主题名关联</li></ul><ol start="3"><li>如果接收者尚未建立对该主题别名的映射，则</li></ol><ul><li>如果包中的主题名长度为 0，则视为一个协议错误，使用带有原因码 0x82（协议错误）的 DISCONNECT 包断开连接，参考 <a href="#4-3-QoS%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B">4.3</a></li><li>如果包中的主题名长度不为 0，则接收者使用该主题名处理此包，随后更新主题别名映射，将主题别名与主题名关联</li></ul><p><em>非规范性评论</em></p><p><em>如果服务器向采用其他版本的客户端（例如 MQTT V3.1.1）发送应用消息，这些客户端可能不支持属性集或者本协议中的其他特性，有些应用消息中的信息可能会丢失，依赖于这些信息的应用程序可能无法正常工作。</em></p><p><span class="vcMarked">当客户端没有接收到足够的 PUBACK、PUBCOMP 或带有大于等于 128 原因码的 PUBREC 时，客户端<strong>必须不</strong>发送QoS 1 或 QoS 2 的 PUBLISH 包导致其需接收的返回数量超过接收最大值</span> <span class="vcReferred">[MQTT-3.3.4-7]</span>。如果服务器接收且未使用 PUBACK 或 PUBCOMP 返回的 QoS 1 或 QoS 2 的包超过其接收最大值时，服务器使用带有原因码 0x93（超出接收最大值）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。参考 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.9</a> 了解更多关于流量控制的信息。</p><p><span class="vcMarked">客户端不能延迟任何包的发送，除了因未收到接受回复而达到接收最大值因此未能发送的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.3.4-8]</span>。接受最大值的值仅对当前网络连接有效。</p><p><em>非规范性评论</em></p><p><em>客户端可以选择发送小于接受最大值的包让服务器处理，即使客户端实际上有更多的消息需要发送。</em></p><p><em>非规范性评论</em></p><p><em>客户端可以选择在其停发 QoS 1 和 QoS 2 的 PUBLISH 包时，同时停发 QoS 0 的 PUBLISH 包。</em></p><p><em>非规范性评论</em></p><p><em>如果客户端在接收到 CONNACK 前就发送 QoS 1 或 QoS 2 的 PUBLISH包，可能存在断开连接的风险，因为他的发送可能超过接受最大值。</em></p><p><span class="vcMarked">当服务器没有接收到足够的 PUBACK、PUBCOMP 或带有大于等于 128 原因码的 PUBREC 时，服务器<strong>必须不</strong>发送QoS 1 或 QoS 2 的 PUBLISH 包导致其需接收的返回数量超过接收最大值</span> <span class="vcReferred">[MQTT-3.3.4-9]</span>。如果客户端接收且未使用 PUBACK 或 PUBCOMP 返回的 QoS 1 或 QoS 2 的包超过其接收最大值时，客户端使用带有原因码 0x93（超出接收最大值）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。参考 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.9</a> 了解更多关于流量控制的信息。</p><p><span class="vcMarked">服务器不能延迟任何包的发送，除了因未收到接受回复而达到接收最大值因此未能发送的 PUBLISH 包</span> <span class="vcReferred">[MQTT-3.3.4-10]</span>。</p><p><em>非规范性评论</em></p><p><em>服务器可以选择发送小于接受最大值的包让客户端处理，即使服务器实际上有更多的消息需要发送。</em></p><p><em>非规范性评论</em></p><p><em>服务器可以选择在其停发 QoS 1 和 QoS 2 的 PUBLISH 包时，同时停发 QoS 0 的 PUBLISH 包。</em></p><h2 id="3-4-PUBACK-发布确认"><a href="#3-4-PUBACK-发布确认" class="headerlink" title="3.4 PUBACK - 发布确认"></a>3.4 PUBACK - 发布确认</h2><p>PUBACK 包是 QoS 1 的 PUBLISH 包的响应。</p><h3 id="3-4-1-PUBACK固定头"><a href="#3-4-1-PUBACK固定头" class="headerlink" title="3.4.1 PUBACK固定头"></a>3.4.1 PUBACK固定头</h3><p><em>图 3‑10 PUBACK 包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（4）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变头的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-4-2-PUBACK可变头"><a href="#3-4-2-PUBACK可变头" class="headerlink" title="3.4.2 PUBACK可变头"></a>3.4.2 PUBACK可变头</h3><p>PUBACK 包的可变头按序包含下列字段：对应 PUBLISH 包的包ID，PUBACK 原因码，属性集长度，属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><p>图 3-11 PUBACK 包可变头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="8">包ID高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">包ID低位（LSB）</td></tr>    <tr><td>byte 3</td><td colspan="8">PUBACK 原因码</td></tr>    <tr><td>byte 4</td><td colspan="8">属性集长度</td></tr>  </tbody></table><h4 id="3-4-2-1-PUBACK原因码"><a href="#3-4-2-1-PUBACK原因码" class="headerlink" title="3.4.2.1 PUBACK原因码"></a>3.4.2.1 PUBACK原因码</h4><p>可变头中的 Byte 3 是 PUBACK 原因码。如果剩余长度的值为 2，表示没有设置原因码，采用默认值 0x00（成功）。</p><p>表 3‑4 PUBACK 原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>成功</td><td>消息已接收。继续处理 QoS 1 消息。</td></tr><tr><td>16</td><td>0x10</td><td>没有匹配的订阅者</td><td>消息已接收但没有订阅者。此内容只由服务器发送。如果服务器了解没有匹配的订阅者，服务器<strong>可以</strong>使用此原因码代替 0x00（成功）。</td></tr><tr><td>128</td><td>0x80</td><td>未指定错误</td><td>接收者没有接收消息，接收者不想透露原因或原因与其他原因码不匹配。</td></tr><tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>PUBLISH 包合法但接收者不想接收。</td></tr><tr><td>135</td><td>0x87</td><td>未经授权</td><td>PUBLISH 包未经授权。</td></tr><tr><td>144</td><td>0x90</td><td>主题名不可用</td><td>主题名格式正确，但不被此客户端或服务器接受。</td></tr><tr><td>145</td><td>0x91</td><td>包ID已被使用</td><td>包ID已经被使用。这可能表示客户端与服务器之间的会话状态不匹配。</td></tr><tr><td>151</td><td>0x97</td><td>超限</td><td>超出了实现或管理员设置的限制。</td></tr><tr><td>153</td><td>0x99</td><td>载荷格式错误</td><td>载荷格式与载荷格式标识不匹配。</td></tr></tbody></table><p><span class="vcMarked">客户端或服务器发送的 PUBACK 包<strong>必须</strong>采用上述之一的 PUBACK 原因码</span> <span class="vcReferred">[MQTT-3.4.2-1]</span>。当原因码为 0x00（成功）且没有属性集时，原因码与属性集长度可以省略。此时 PUBACK 的剩余长度值为 2。</p><h4 id="3-4-2-2-PUBACK属性集"><a href="#3-4-2-2-PUBACK属性集" class="headerlink" title="3.4.2.2 PUBACK属性集"></a>3.4.2.2 PUBACK属性集</h4><h5 id="3-4-2-2-1-属性集长度"><a href="#3-4-2-2-1-属性集长度" class="headerlink" title="3.4.2.2.1 属性集长度"></a>3.4.2.2.1 属性集长度</h5><p>表示 PUBACK 可变头中属性集长度的值，采用 <code>变长整数</code> 编码。如果剩余长度的值小于 4，表示没有属性集长度，其值视为 0。</p><h5 id="3-4-2-2-2-原因字符串"><a href="#3-4-2-2-2-原因字符串" class="headerlink" title="3.4.2.2.2 原因字符串"></a>3.4.2.2.2 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示此响应关联的原因。原因字符串是人类可读的用于诊断故障的字符串，没有义务被接收端解析。</p><p>发送方使用此字段向接收方传递额外的信息。<span class="vcMarked">如果添加此字段会导致 PUBACK 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.4.2-2]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-4-2-2-3-用户属性"><a href="#3-4-2-2-3-用户属性" class="headerlink" title="3.4.2.2.3 用户属性"></a>3.4.2.2.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 PUBACK 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.4.2-3]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h3 id="3-4-3-PUBACK载荷"><a href="#3-4-3-PUBACK载荷" class="headerlink" title="3.4.3 PUBACK载荷"></a>3.4.3 PUBACK载荷</h3><p>PUBACK 包没有载荷。</p><h3 id="3-4-4-PUBACK动作"><a href="#3-4-4-PUBACK动作" class="headerlink" title="3.4.4 PUBACK动作"></a>3.4.4 PUBACK动作</h3><p>这部分在 <a href="#4-3-2-Qos-1%EF%BC%9A%E8%87%B3%E5%B0%91%E4%B8%80%E6%AC%A1">4.3.2</a> 中描述。</p><h2 id="3-5-PUBREC-发布签收（QoS-2-交付第一部分）"><a href="#3-5-PUBREC-发布签收（QoS-2-交付第一部分）" class="headerlink" title="3.5 PUBREC - 发布签收（QoS 2 交付第一部分）"></a>3.5 PUBREC - 发布签收（QoS 2 交付第一部分）</h2><p>PUBREC 包是对 QoS 2 的 PUBLISH 包的响应。这是 QoS 2 协议交换的第二个包。</p><h3 id="3-5-1-PUBREC固定头"><a href="#3-5-1-PUBREC固定头" class="headerlink" title="3.5.1 PUBREC固定头"></a>3.5.1 PUBREC固定头</h3><p><em>图 3‑12 PUBREC固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（5）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度</strong></p><p>表示可变头的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-5-2-PUBREC可变头"><a href="#3-5-2-PUBREC可变头" class="headerlink" title="3.5.2 PUBREC可变头"></a>3.5.2 PUBREC可变头</h3><p>PUBREC 可变头按序包括下列字段：对应 PUBLISH 包的包ID、PUBREC 原因码、属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><p>图 3-13 PUBREC 包可变头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="8">包ID高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">包ID低位（LSB）</td></tr>    <tr><td>byte 3</td><td colspan="8">PUBREC 原因码</td></tr>    <tr><td>byte 4</td><td colspan="8">属性集长度</td></tr>  </tbody></table><h4 id="3-5-2-1-PUBREC原因码"><a href="#3-5-2-1-PUBREC原因码" class="headerlink" title="3.5.2.1 PUBREC原因码"></a>3.5.2.1 PUBREC原因码</h4><p>可变头中的 Byte 3 是 PUBREC 原因码。如果剩余长度的值为 2，表示没有设置原因码，采用默认值 0x00（成功）。</p><p>表 3‑5 PUBREC 原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>成功</td><td>消息已接收。继续处理 QoS 1 消息。</td></tr><tr><td>16</td><td>0x10</td><td>没有匹配的订阅者</td><td>消息已接收但没有订阅者。此内容只由服务器发送。如果服务器了解没有匹配的订阅者，服务器<strong>可以</strong>使用此原因码代替 0x00（成功）。</td></tr><tr><td>128</td><td>0x80</td><td>未指定错误</td><td>接收者没有接收消息，接收者不想透露原因或原因与其他原因码不匹配。</td></tr><tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>PUBLISH 包合法但接收者不想接收。</td></tr><tr><td>135</td><td>0x87</td><td>未经授权</td><td>PUBLISH 包未经授权。</td></tr><tr><td>144</td><td>0x90</td><td>主题名不可用</td><td>主题名格式正确，但不被此客户端或服务器接受。</td></tr><tr><td>145</td><td>0x91</td><td>包ID已被使用</td><td>包ID已经被使用。这可能表示客户端与服务器之间的会话状态不匹配。</td></tr><tr><td>151</td><td>0x97</td><td>超限</td><td>超出了实现或管理员设置的限制。</td></tr><tr><td>153</td><td>0x99</td><td>载荷格式错误</td><td>载荷格式与载荷格式标识不匹配。</td></tr></tbody></table><p><span class="vcMarked">客户端或服务器发送的 PUBREC 包<strong>必须</strong>采用上述之一的 PUBREC 原因码</span> <span class="vcReferred">[MQTT-3.5.2-1]</span>。当原因码为 0x00（成功）且没有属性集时，原因码与属性集长度可以省略。此时 PUBREC 的剩余长度值为 2。</p><h4 id="3-5-2-2-PUBREC属性集"><a href="#3-5-2-2-PUBREC属性集" class="headerlink" title="3.5.2.2 PUBREC属性集"></a>3.5.2.2 PUBREC属性集</h4><h5 id="3-5-2-2-1-属性长度"><a href="#3-5-2-2-1-属性长度" class="headerlink" title="3.5.2.2.1 属性长度"></a>3.5.2.2.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 PUBREC 可变头中的属性集长度。如果剩余长度的值小于 4，表示没有属性长度字段，其值视为 0。</p><h5 id="3-5-2-2-2-原因字符串"><a href="#3-5-2-2-2-原因字符串" class="headerlink" title="3.5.2.2.2 原因字符串"></a>3.5.2.2.2 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示此响应关联的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p>发送方使用此字段向接收方传递额外的信息。<span class="vcMarked">如果添加此字段会导致 PUBREC 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.5.2-2]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-5-2-2-3-用户属性"><a href="#3-5-2-2-3-用户属性" class="headerlink" title="3.5.2.2.3 用户属性"></a>3.5.2.2.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 PUBREC 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.5.2-3]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h3 id="3-5-3-PUBREC载荷"><a href="#3-5-3-PUBREC载荷" class="headerlink" title="3.5.3 PUBREC载荷"></a>3.5.3 PUBREC载荷</h3><p>PUBREC 包没有载荷。</p><h3 id="3-5-4-PUBREC动作"><a href="#3-5-4-PUBREC动作" class="headerlink" title="3.5.4 PUBREC动作"></a>3.5.4 PUBREC动作</h3><p>这部分在 <a href="#4-3-3-Qos-2%EF%BC%9A%E7%A1%AE%E4%BF%9D%E4%B8%80%E6%AC%A1">4.3.3</a> 中描述。</p><h2 id="3-6-PUBREL-发布释放（QoS-2-交付第二部分）"><a href="#3-6-PUBREL-发布释放（QoS-2-交付第二部分）" class="headerlink" title="3.6 PUBREL - 发布释放（QoS 2 交付第二部分）"></a>3.6 PUBREL - 发布释放（QoS 2 交付第二部分）</h2><p>PUBREL 包是对 PUBREC 包的响应。这是 QoS 2 协议交换的第三个包。</p><h3 id="3-6-1-PUBREL固定头"><a href="#3-6-1-PUBREL固定头" class="headerlink" title="3.6.1 PUBREL固定头"></a>3.6.1 PUBREL固定头</h3><p><em>图 3‑14 PUBREL固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（6）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><span class="vcMarked">PUBREL 包固定头中的 Bit 3、2、1、0 为保留字段，其值必须被分别设置为 0、0、1、0。服务器<strong>必须</strong>将其他值视为格式错误的包并关闭网络连接</span> <span class="vcReferred">[MQTT-3.6.1-1]</span>。</p><p><strong>剩余长度</strong></p><p>表示可变头的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-6-2-PUBREL可变头"><a href="#3-6-2-PUBREL可变头" class="headerlink" title="3.6.2 PUBREL可变头"></a>3.6.2 PUBREL可变头</h3><p>PUBREL 可变头按序包括下列字段：对应 PUBLISH 包的包ID、PUBREL 原因码、属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><p>图 3-15 PUBREL 包可变头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="8">包ID高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">包ID低位（LSB）</td></tr>    <tr><td>byte 3</td><td colspan="8">PUBREL 原因码</td></tr>    <tr><td>byte 4</td><td colspan="8">属性集长度</td></tr>  </tbody></table><h4 id="3-6-2-1-PUBREL原因码"><a href="#3-6-2-1-PUBREL原因码" class="headerlink" title="3.6.2.1 PUBREL原因码"></a>3.6.2.1 PUBREL原因码</h4><p>可变头中的 Byte 3 是 PUBREL 原因码。如果剩余长度的值为 2，表示没有设置原因码，采用默认值 0x00（成功）。</p><p>表 3‑6 PUBREL 原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>成功</td><td>消息已接收。继续处理 QoS 1 消息。</td></tr><tr><td>146</td><td>0x92</td><td>包ID未找到</td><td>未知的包ID。在恢复期间这不是错误，但在其他时间则表示客户端和服务器上的会话状态不匹配。</td></tr></tbody></table><p><span class="vcMarked">客户端或服务器发送的 PUBREL 包<strong>必须</strong>采用上述之一的 PUBREL 原因码</span> <span class="vcReferred">[MQTT-3.6.2-1]</span>。当原因码为 0x00（成功）且没有属性集时，原因码与属性集长度可以省略。此时 PUBREL 的剩余长度值为 2。</p><h4 id="3-6-2-2-PUBREL属性集"><a href="#3-6-2-2-PUBREL属性集" class="headerlink" title="3.6.2.2 PUBREL属性集"></a>3.6.2.2 PUBREL属性集</h4><h5 id="3-6-2-2-1-属性长度"><a href="#3-6-2-2-1-属性长度" class="headerlink" title="3.6.2.2.1 属性长度"></a>3.6.2.2.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 PUBREL 可变头中的属性集长度。如果剩余长度的值小于 4，表示没有属性长度字段，其值视为 0。</p><h5 id="3-6-2-2-2-原因字符串"><a href="#3-6-2-2-2-原因字符串" class="headerlink" title="3.6.2.2.2 原因字符串"></a>3.6.2.2.2 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示此响应关联的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p>发送方使用此字段向接收方传递额外的信息。<span class="vcMarked">如果添加此字段会导致 PUBREL 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.6.2-2]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-6-2-2-3-用户属性"><a href="#3-6-2-2-3-用户属性" class="headerlink" title="3.6.2.2.3 用户属性"></a>3.6.2.2.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 PUBREL 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.6.2-3]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h3 id="3-6-3-PUBREL载荷"><a href="#3-6-3-PUBREL载荷" class="headerlink" title="3.6.3 PUBREL载荷"></a>3.6.3 PUBREL载荷</h3><p>PUBREL 包没有载荷。</p><h3 id="3-6-4-PUBREL动作"><a href="#3-6-4-PUBREL动作" class="headerlink" title="3.6.4 PUBREL动作"></a>3.6.4 PUBREL动作</h3><p>这部分在 <a href="#4-3-3-Qos-2%EF%BC%9A%E7%A1%AE%E4%BF%9D%E4%B8%80%E6%AC%A1">4.3.3</a> 中描述。</p><h2 id="3-7-PUBCOMP-发布完成（QoS-2-交付第三部分）"><a href="#3-7-PUBCOMP-发布完成（QoS-2-交付第三部分）" class="headerlink" title="3.7 PUBCOMP - 发布完成（QoS 2 交付第三部分）"></a>3.7 PUBCOMP - 发布完成（QoS 2 交付第三部分）</h2><p>PUBCOMP 包是对 PUBREL 包的响应。这是 QoS 2 协议交换的第四个包，也是最后一个包。</p><h3 id="3-7-1-PUBCOMP固定头"><a href="#3-7-1-PUBCOMP固定头" class="headerlink" title="3.7.1 PUBCOMP固定头"></a>3.7.1 PUBCOMP固定头</h3><p><em>图 3‑16 PUBCOMP固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（7）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度</strong></p><p>表示可变头的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-7-2-PUBCOMP可变头"><a href="#3-7-2-PUBCOMP可变头" class="headerlink" title="3.7.2 PUBCOMP可变头"></a>3.7.2 PUBCOMP可变头</h3><p>PUBREL 可变头按序包括下列字段：对应 PUBLISH 包的包ID、PUBCOMP 原因码、属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><p>图 3-17 PUBCOMP 包可变头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="8">包ID高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">包ID低位（LSB）</td></tr>    <tr><td>byte 3</td><td colspan="8">PUBCOMP 原因码</td></tr>    <tr><td>byte 4</td><td colspan="8">属性集长度</td></tr>  </tbody></table><h4 id="3-7-2-1-PUBCOMP原因码"><a href="#3-7-2-1-PUBCOMP原因码" class="headerlink" title="3.7.2.1 PUBCOMP原因码"></a>3.7.2.1 PUBCOMP原因码</h4><p>可变头中的 Byte 3 是 PUBCOMP 原因码。如果剩余长度的值为 2，表示没有设置原因码，采用默认值 0x00（成功）。</p><p>表 3‑3 PUBCOMP 原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>成功</td><td>消息已接收。继续处理 QoS 1 消息。</td></tr><tr><td>146</td><td>0x92</td><td>包ID未找到</td><td>未知的包ID。在恢复期间这不是错误，但在其他时间则表示客户端和服务器上的会话状态不匹配。</td></tr></tbody></table><p><span class="vcMarked">客户端或服务器发送的 PUBCOMP 包<strong>必须</strong>采用上述之一的 PUBCOMP 原因码</span> <span class="vcReferred">[MQTT-3.7.2-1]</span>。当原因码为 0x00（成功）且没有属性集时，原因码与属性集长度可以省略。此时 PUBCOMP 的剩余长度值为 2。</p><h4 id="3-7-2-2-PUBCOMP属性集"><a href="#3-7-2-2-PUBCOMP属性集" class="headerlink" title="3.7.2.2 PUBCOMP属性集"></a>3.7.2.2 PUBCOMP属性集</h4><h5 id="3-7-2-2-1-属性长度"><a href="#3-7-2-2-1-属性长度" class="headerlink" title="3.7.2.2.1 属性长度"></a>3.7.2.2.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 PUBCOMP 可变头中的属性集长度。如果剩余长度的值小于 4，表示没有属性长度字段，其值视为 0。</p><h5 id="3-7-2-2-2-原因字符串"><a href="#3-7-2-2-2-原因字符串" class="headerlink" title="3.7.2.2.2 原因字符串"></a>3.7.2.2.2 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示此响应关联的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p>发送方使用此字段向接收方传递额外的信息。<span class="vcMarked">如果添加此字段会导致 PUBCOMP 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.7.2-2]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-7-2-2-3-用户属性"><a href="#3-7-2-2-3-用户属性" class="headerlink" title="3.7.2.2.3 用户属性"></a>3.7.2.2.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 PUBCOMP 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.7.2-3]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h3 id="3-7-3-PUBCOMP载荷"><a href="#3-7-3-PUBCOMP载荷" class="headerlink" title="3.7.3 PUBCOMP载荷"></a>3.7.3 PUBCOMP载荷</h3><p>PUBCOMP 包没有载荷。</p><h3 id="3-7-4-PUBCOMP动作"><a href="#3-7-4-PUBCOMP动作" class="headerlink" title="3.7.4 PUBCOMP动作"></a>3.7.4 PUBCOMP动作</h3><p>这部分在 <a href="#4-3-3-Qos-2%EF%BC%9A%E7%A1%AE%E4%BF%9D%E4%B8%80%E6%AC%A1">4.3.3</a> 中描述。</p><h2 id="3-8-SUBSCRIBE-订阅请求"><a href="#3-8-SUBSCRIBE-订阅请求" class="headerlink" title="3.8 SUBSCRIBE - 订阅请求"></a>3.8 SUBSCRIBE - 订阅请求</h2><p>SUBSCRIBE 包由客户端发送到服务器，用来创建一个或多个订阅。每个订阅将客户端注册到一个或多个其感兴趣的主题。服务器将到达该客户端订阅匹配的主题的应用消息使用 PUBLISH 包转发给客户端。SUBSCRIBE 包也基于每个订阅指定了服务器向客户端发送应用消息的最大QoS。</p><h3 id="3-8-1-SUBSCRIBE固定头"><a href="#3-8-1-SUBSCRIBE固定头" class="headerlink" title="3.8.1 SUBSCRIBE固定头"></a>3.8.1 SUBSCRIBE固定头</h3><p><em>图 3‑18 SUBSCRIBE固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（8）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><span class="vcMarked">SUBSCRIBE 包固定头中的 Bit 3、2、1、0 为保留字段，其值必须被分别设置为 0、0、1、0。服务器<strong>必须</strong>将其他值视为格式错误的包并关闭网络连接</span> <span class="vcReferred">[MQTT-3.8.1-1]</span>。</p><p><strong>剩余长度</strong></p><p>表示可变头和载荷的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-8-2-SUBSCRIBE可变头"><a href="#3-8-2-SUBSCRIBE可变头" class="headerlink" title="3.8.2 SUBSCRIBE可变头"></a>3.8.2 SUBSCRIBE可变头</h3><p>SUBSCRIBE 可变头按序包括下列字段：包ID、属性集。<a href="#2-2-1-%E5%8C%85ID">2.2.1</a> 提供了更多关于包ID的信息。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><p><em>非规范性示例</em></p><p><em>图 3-19 是一个 SUBSCRIBE 可变头的示例，其包ID为 10 且没有属性集。</em></p><p>图 3-19 SUBSCRIBE 可变头示例</p><table>  <thead>    <tr><td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="10">包ID</td></tr>    <tr><td>byte 1</td><td>包ID高位（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td>包ID低位（LSB）（10）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td>byte 3</td><td>属性集长度（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>  </tbody></table><h4 id="3-8-2-1-SUBSCRIBE属性集"><a href="#3-8-2-1-SUBSCRIBE属性集" class="headerlink" title="3.8.2.1 SUBSCRIBE属性集"></a>3.8.2.1 SUBSCRIBE属性集</h4><h5 id="3-8-2-1-1-属性长度"><a href="#3-8-2-1-1-属性长度" class="headerlink" title="3.8.2.1.1 属性长度"></a>3.8.2.1.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 SUBSCRIBE 可变头中的属性集长度。如果剩余长度的值小于 4，表示没有属性长度字段，其值视为 0。</p><h5 id="3-8-2-1-2-订阅ID"><a href="#3-8-2-1-2-订阅ID" class="headerlink" title="3.8.2.1.2 订阅ID"></a>3.8.2.1.2 订阅ID</h5><p>订阅ID属性ID是<strong>11 (0x0B) Byte</strong>。</p><p>随后跟随 <code>变长整数</code> 表示订阅ID。订阅ID的取值范围是 1 至 268435455。订阅ID的值为0视为协议错误。订阅ID在属性集中出现超过一次视为协议错误。</p><p>订阅ID将与此 SUBSCRIBE 包创建或修改的任何订阅关联。如果有订阅ID，他将存储在订阅中，如果没有订阅ID，将不会有订阅ID存储在订阅中。</p><p>参考 <a href="#3-8-3-1-%E8%AE%A2%E9%98%85%E9%80%89%E9%A1%B9">3.8.3.1</a> 了解更多关于订阅ID处理的信息。</p><h5 id="3-8-2-1-3-用户属性"><a href="#3-8-2-1-3-用户属性" class="headerlink" title="3.8.2.1.3 用户属性"></a>3.8.2.1.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。</p><p>用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><p><em>非规范性评论</em></p><p><em>SUBSCRIBE 中的用户属性可以被客户端用来向服务器发送一些订阅依赖的属性。这意味着这些属性并非本规范定义的。</em></p><h3 id="3-8-3-SUBSCRIBE载荷"><a href="#3-8-3-SUBSCRIBE载荷" class="headerlink" title="3.8.3 SUBSCRIBE载荷"></a>3.8.3 SUBSCRIBE载荷</h3><p>SUBSCRIBE 包的载荷内含一个主题过滤器列表，指定了客户端想要订阅的主题。<span class="vcMarked">主题过滤器<strong>必须</strong>是一个 <code>UTF-8字符串</code></span> <span class="vcReferred">[MQTT-3.8.3-1]</span>。每个主题过滤器之后都跟随着一个 byte 的订阅选项 。</p><p><span class="vcMarked">载荷<strong>必须</strong>至少包含一个主题过滤器和订阅选项对</span> <span class="vcReferred">[MQTT-3.8.3-2]</span>。没有载荷的 SUBSCRIBE 视为协议错误。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 了解关于错误处理的信息。</p><h4 id="3-8-3-1-订阅选项"><a href="#3-8-3-1-订阅选项" class="headerlink" title="3.8.3.1 订阅选项"></a>3.8.3.1 订阅选项</h4><p>订阅选项中的 Bit 0 和 Bit 1 表示最大QoS字段。这表示了服务器可以法相客户端的最大QoS等级。最大QoS的值为3视为协议错误。</p><p><span class="vcMarked">订阅选项中的 Bit 2 表示非本地选项。如果其值为 1，服务器<strong>必须不</strong>将应用消息转发给与发布者客户端ID相同的订阅者</span> <span class="vcReferred">[MQTT-3.8.3-3]</span>。<span class="vcMarked">在共享订阅中非本地选项值为 1 视为协议错误</span> <span class="vcReferred">[MQTT-3.8.3-4]</span>。</p><p>订阅选项中的 Bit 3 表示保留消息引用发布选项。其值为 1 时，向该订阅转发的应用消息保留其原本发布时的保留消息标识。其值为 0 时，向该订阅转发的应用消息的保留标志置为 0。订阅建立时发布的保留消息的保留消息标识值为 1。</p><p>订阅选项中的 Bit 4 和 Bit 5 表示保留消息处理选项。这个选项决定了当订阅建立时保留消息是否发送。这个选项不会对连接建立后的保留消息发送有任何影响。如果该主题过滤器下没有匹配的保留消息，该选项的所有值的表现都一致。该选项的值包括：</p><p>0 &#x3D; 在订阅建立后发送保留消息</p><p>1 &#x3D; 只有建立全新的订阅而非重复订阅时发送保留消息</p><p>2 &#x3D; 订阅建立时不发送保留消息</p><p>保留消息处理的值为 3 视为协议错误。</p><p>订阅选项中的 Bit 6 和 Bit 7 被保留以后使用。<span class="vcMarked">服务器<strong>必须</strong>将载荷中保留字段值非 0 的 SUBSCRIBE 包视为格式错误的包</span> <span class="vcReferred">[MQTT-3.8.3-5]</span>。</p><p><em>非规范性评论</em></p><p><em>非本地选项和保留消息引用发布选项可以用来将客户端的消息桥接到另一台服务器。</em></p><p><em>非规范性评论</em></p><p><em>当发生重连且客户端无法确定上次连接会话中订阅是否完成的时候，不对重复订阅发送保留消息的功能是很有用的。</em></p><p><em>非规范性评论</em></p><p><em>当客户端希望获得变化提醒且不关心初始状态时，不对新的订阅发送保留消息的功能是很有用的。</em></p><p><em>非规范性评论</em></p><p><em>对于不支持保留消息的服务器，所有的保留消息引用发布选项和保留消息处理选项的值结果都是相同的，订阅后服务器不会发送任何保留消息，且后续所有消息的保留消息标识的值都为 0。</em></p><p>图 3‑20 SUBSCRIBE 包载荷格式</p><table>  <thead>    <tr><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="9">主题过滤器</td></tr>    <tr><td>byte 1</td><td colspan="8">长度高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">长度低位（LSB）</td></tr>    <tr><td>byte 3..N</td><td colspan="8">主题过滤器</td></tr>    <tr><td colspan="9">订阅选项</td></tr>    <tr><td></td><td colspan="2">保留</td><td colspan="2">保留消息处理</td><td>RAP</td><td>NL</td><td colspan="2">QoS</td></tr>    <tr><td>byte N+1</td><td>0</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>  </tbody></table><p>RAP 表示保留消息引用发布。<br>NL 表示非本地。</p><p><em>非规范性示例</em></p><p><em>图 3.21 展示了 SUBSCRIBE 载荷中包含两个主题过滤器的示例。第一个是“a&#x2F;b”其 QoS 值为 1，第二个是 “c&#x2F;d”其 QoS 值为 2。</em></p><p>图 3‑21 - 载荷字节格式非规范性示例</p><table>  <thead>    <tr><td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="10">主题过滤器</td></tr>    <tr><td>byte 1</td><td>长度高字节（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td>长度低字节（LSB）（3）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>    <tr><td>byte 3</td><td>'a'（0x61）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>    <tr><td>byte 4</td><td>'/'（0x2F）</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>    <tr><td>byte 5</td><td>'b'（0x62）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td colspan="10">订阅选项</td></tr>    <tr><td>byte 6</td><td>订阅选项（1）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>    <tr><td colspan="10">主题过滤器</td></tr>    <tr><td>byte 7</td><td>长度高字节（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 8</td><td>长度低字节（LSB）（3）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>    <tr><td>byte 9</td><td>'c'（0x63）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>    <tr><td>byte 10</td><td>'/'（0x2F）</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>    <tr><td>byte 11</td><td>'d'（0x64）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>    <tr><td colspan="10">订阅选项</td></tr>    <tr><td>byte 12</td><td>订阅选项（2）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>  </tbody></table><h3 id="3-8-4-SUBSCRIBE动作"><a href="#3-8-4-SUBSCRIBE动作" class="headerlink" title="3.8.4 SUBSCRIBE动作"></a>3.8.4 SUBSCRIBE动作</h3><p><span class="vcMarked">当服务器从客户端收到 SUBSCRIBE 包，服务器<strong>必须</strong>使用 SUBACK 响应</span> <span class="vcReferred">[MQTT-3.8.4-1]</span>。<span class="vcMarked">SUBACK 中的包ID<strong>必须</strong>和其对应的 SUBSCRIBE 包中的包ID一致</span> <span class="vcReferred">[MQTT-3.8.4-2]</span>。</p><p>服务器允许在发送 SUBACK 之前就转发订阅所匹配的 PUBLISH 包。</p><p><span class="vcMarked">如果服务器接收到一个 SUBSCRIBE 包，其中包含的主题过滤器和现在会话中的一个订阅完全相同，服务器<strong>必须</strong>使用新订阅取代现有的订阅</span> <span class="vcReferred">[MQTT-3.8.4-3]</span>。新订阅的主题过滤器和原有订阅的完全相同，虽然其订阅选项可能不同。<span class="vcMarked">如果他的保留消息处理选项值为 0，且主题过滤器中现在有匹配的保留消息，服务器<strong>必须</strong>重新发送，但是服务器<strong>必须不</strong>能因为订阅的替换导致应用消息的丢失</span> <span class="vcReferred">[MQTT-3.8.4-4]</span>。</p><p>如果服务器接收到一个 SUBSCRIBE 包，其中包含的主题过滤器和现在会话中的订阅都不同，服务器创建一个新的非共享订阅。如果保留消息处理选项的值非 2，所有匹配的保留消息都要发往此客户端。</p><p>如果服务器接收到一个 SUBSCRIBE 包，其中包含的主题过滤器和服务器中已经存在的共享订阅相同，将该会话作为订阅者加入共享订阅。无需发送保留消息。</p><p>如果服务器接收到一个 SUBSCRIBE 包，其中包含共享订阅主题过滤器且和现有的共享订阅主题过滤器都不同，服务器创建一个新的共享订阅。该会话作为订阅者加入共享订阅。无需发送保留消息。</p><p>参考 <a href="#4-8-%E8%AE%A2%E9%98%85">4.8</a> 了解更多关于共享订阅的细节。</p><p><span class="vcMarked">如果一个服务器接受的 SUBSCRIBE 包包含有多个订阅主题，服务器<strong>必须</strong>像接收了多个独立的 SUBSCRIBE 包一个逐个处理，唯一的不同是服务器将所有订阅请求的响应放入一个 SUBACK 包中回复</span> <span class="vcReferred">[MQTT-3.8.4-5]</span>。</p><p><span class="vcMarked">服务器发往客户端的 SUBACK <strong>必须</strong>为每一个 主题过滤器&#x2F;订阅选项 对提供一个原因码</span> <span class="vcReferred">[MQTT-3.8.4-6]</span>。<span class="vcMarked">这个原因码<strong>必须</strong>提供服务器为此次订阅分配的最大QoS或是指明本次订阅失败</span> <span class="vcReferred">[MQTT-3.8.4-7]</span>。服务器也许会提供一个比订阅者请求的更低的最大QoS。<span class="vcMarked">发送给订阅者的应用消息中的QoS<strong>必须</strong>是原始 PUBLISH 包中的QoS和服务器分配的最大QoS两者中的较小值</span> <span class="vcReferred">[MQTT-3.8.4-8]</span>。当原始消息的QoS值为 1 且服务器分配的最大QoS值为 0 时，服务器被允许向订阅者发布消息的多个副本。</p><p><em>非规范性评论</em></p><p><em>如果订阅客户端对于某个特定主题被分配的最大QoS值为 1，QoS 值为 0 的应用消息通过该主题转发到客户端时QoS值为 0。这意味着客户端至多只能接收到此消息一次。另一方面，QoS 值为 2 的应用消息通过该主题转发，会被服务器降级为 QoS 1，因此客户端可能会多次收到该消息。</em></p><p><em>非规范性评论</em></p><p><em>如果订阅客户端被分配的最大QoS值为 0，随后原始 QoS 值为 2 的应用消息也可能在发往此客户端的路上丢失，但是服务器不应多次发送此消息。而同主题下 QoS 1 的消息则可能会丢失，也可能多次发给客户端。</em></p><p><em>非规范性评论</em></p><p><em>采用 QoS 2 订阅一个主题过滤器等同于宣布“我将使用该主题下所有发布消息的原始 QoS 值来接收消息”。这意味着发送者有责任决定被转发的应用消息的最大QoS等级，但是订阅者可以要求服务器将QoS降级到更适合其使用的级别。</em></p><p>订阅ID是服务器中会话状态的一部分，并在接收到匹配的 PUBLISH 包时在转发时返回给客户端。订阅ID在下面三种情况下被删除或修改：当服务器接收到 UNSUBSCRIBE 包时，当服务器再次收到相同主题过滤器的 SUBSCRIBE 包，其中订阅ID不同或未设置时，当服务器发送 CONNACK，其中的会话展示值为 0 时。</p><p>订阅ID并非是客户端会话状态的一部分。在一个有用的实现中，客户端会将订阅ID关联到其他的客户端侧状态，这个状态一般会在下面三种情况下被删除或修改：客户端取消订阅时，客户端再次订阅相同主题但使用不同的订阅ID或不使用订阅ID时，客户端接收到 CONNACK，且其中会话展示值为 0 时。</p><p>服务器不需要在重传的 PUBLISH 数据包中使用相同的订阅标识符集。 客户端可以通过发送包含主题过滤器的订阅数据包来重新创建订阅，该主题过滤器与当前会话中现有订阅的主题过滤器相同。 如果客户端在首次传输 PUBLISH 数据包后重新进行订阅并使用不同的订阅标识符，则允许服务器在任何重传中使用第一次传输中的标识符。 或者，允许服务器在重传期间使用新的标识符。 服务器在发送包含新标识符的 PUBLISH 数据包后，不允许恢复为旧标识符。</p><p>服务器无需在重传 PUBLISH 时保持相同的订阅ID。客户端可以通过发送和现有会话中订阅的主题过滤器完全相同的 SUBSCRIBE 包来重新订阅。如果客户端在服务器发送某个 PUBLISH 包后重新订阅了该主题并使用了不同的订阅ID，服务器可以使用第一次发送 PUBLISH 包时使用的订阅ID来进行重传。或者，服务器也可以使用新的订阅ID进行重传。但是服务器不允许在使用新的订阅ID发送 PUBLISH 包后再使用旧的订阅ID。</p><p><em>非规范性评论</em></p><p><em>用于说明订阅ID的使用场景</em></p><ul><li><p><em>客户端实现可以通过其编程接口意识到收到的某一次发布可能与其多次订阅匹配。客户端实现在每次订阅时创建一个新的订阅ID。当返回的发布消息携带多个订阅ID时，表示该消息匹配了多次订阅。</em></p></li><li><p><em>客户端实现可以在订阅中让订阅者将消息指向某个回调。客户端实现创建唯一的订阅ID并将其映射到回调。当收到发布时使用其中携带的订阅ID来决定调用哪个回调。</em></p></li><li><p><em>客户端实现可以在收到发布消息时返回订阅该消息的主题字符串。为了实现这一点，客户端生成一个唯一订阅ID和主题过滤器匹配。当收到应用消息时，客户都安时间使用订阅ID查找到原始的主题字符串，并返回给客户端应用程序。</em></p></li><li><p><em>网关将从服务器接收到的发布转发到已订阅网关的客户端时。网关实现可以维护一个包含客户端ID到订阅ID的映射。网关为其转发到服务器的每个主题过滤器生成唯一ID。当收到发布消息时，网关查找其收到的订阅ID用以匹配客户端ID。并将客户端ID添加到发送给客户端的 PUBLISH 包中。如果上游服务器因为消息匹配多个订阅而发送多个 PUBLISH 数据包，则此行为将镜像到客户端。</em></p></li></ul><h2 id="3-9-SUBACK-订阅确认"><a href="#3-9-SUBACK-订阅确认" class="headerlink" title="3.9 SUBACK - 订阅确认"></a>3.9 SUBACK - 订阅确认</h2><p>SUBACK 包由服务器发往客户端，用以确认 SUBSCRIBE 包的接收和处理。</p><p>SUBACK 包包含一个原因码列表，其内容是对 SUBSCRIBE 中每个订阅请求的答复，要么是分配的最大QoS值，要么是错误返回。</p><h3 id="3-9-1-SUBACK固定头"><a href="#3-9-1-SUBACK固定头" class="headerlink" title="3.9.1 SUBACK固定头"></a>3.9.1 SUBACK固定头</h3><p><em>图 3-22 SUBACK包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（9）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度</strong></p><p>表示可变头和载荷的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-9-2-SUBACK可变头"><a href="#3-9-2-SUBACK可变头" class="headerlink" title="3.9.2 SUBACK可变头"></a>3.9.2 SUBACK可变头</h3><p>SUBACK 可变头按序包括下列字段：对应 SUBSCRIBE 包的包ID，属性集。</p><h4 id="3-9-2-1-SUBACK属性集"><a href="#3-9-2-1-SUBACK属性集" class="headerlink" title="3.9.2.1 SUBACK属性集"></a>3.9.2.1 SUBACK属性集</h4><h5 id="3-9-2-1-1-属性长度"><a href="#3-9-2-1-1-属性长度" class="headerlink" title="3.9.2.1.1 属性长度"></a>3.9.2.1.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 SUBACK 可变头中的属性集长度。</p><h5 id="3-9-2-1-2-原因字符串"><a href="#3-9-2-1-2-原因字符串" class="headerlink" title="3.9.2.1.2 原因字符串"></a>3.9.2.1.2 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示此响应关联的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p>服务器使用此字段向客户端传递额外的信息。<span class="vcMarked">如果添加此字段会导致 SUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.9.2-1]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-9-2-1-3-用户属性"><a href="#3-9-2-1-3-用户属性" class="headerlink" title="3.9.2.1.3 用户属性"></a>3.9.2.1.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 SUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.9.2-2]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><p>图 3‑23 SUBACK 包可变头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="8">包ID高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">包ID低位（LSB）</td></tr>  </tbody></table><p><span class="vcTrans">译者认为这里缺失了属性长度</span></p><h3 id="3-9-3-SUBACK载荷"><a href="#3-9-3-SUBACK载荷" class="headerlink" title="3.9.3 SUBACK载荷"></a>3.9.3 SUBACK载荷</h3><p>载荷中包含一组原因码列表。每个原因码回复 SUBSCRIBE 包中一个对应的主题过滤器。<span class="vcMarked">SUBACK 中原因码的顺序<strong>必须</strong>与 SUBSCRIBE 中主题过滤器的顺序匹配</span> <span class="vcReferred">[MQTT-3.9.3-1]</span>。</p><p>表 3‑8 - 订阅原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>授予 QoS 0</td><td>订阅已被接收，向其发送的最大 QoS 值为 0。这个值可能会小于其请求时的值。</td></tr><tr><td>1</td><td>0x01</td><td>授予 QoS 1</td><td>订阅已被接收，向其发送的最大 QoS 值为 1。这个值可能会小于其请求时的值。</td></tr><tr><td>2</td><td>0x02</td><td>授予 QoS 2</td><td>订阅已被接收，服务器接收到的所有 QoS 值都会向其转发。</td></tr><tr><td>128</td><td>0x80</td><td>未指定错误</td><td>订阅未被接收，服务器不愿透露原因或其他原因码不匹配。</td></tr><tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>SUBSCRIBE 合法，但服务器未接收。</td></tr><tr><td>135</td><td>0x87</td><td>未经授权</td><td>客户端未被授予创建此订阅的权力。</td></tr><tr><td>143</td><td>0x8F</td><td>主题过滤器不可用</td><td>主题过滤器格式正确，但不允许此客户端使用。</td></tr><tr><td>145</td><td>0x91</td><td>包ID已被使用</td><td>所选的包ID已经在使用中。</td></tr><tr><td>151</td><td>0x97</td><td>超限</td><td>超过了实现或管理员规定的限制。</td></tr><tr><td>158</td><td>0x9E</td><td>不支持共享订阅</td><td>服务器对此客户端不支持共享订阅。</td></tr><tr><td>161</td><td>0xA1</td><td>不支持订阅ID</td><td>服务器不支持订阅ID；订阅未被接收。</td></tr><tr><td>162</td><td>0xA2</td><td>不支持通配符订阅</td><td>服务器不支持通配符订阅；订阅未被接收。</td></tr></tbody></table><p><span class="vcMarked">服务器发送的 SUBACK 包<strong>必须</strong>对每个收到的主题过滤器使用上表列出的原因码进行回复</span> <span class="vcReferred">[MQTT-3.9.3-2]</span>。</p><p><em>非规范性评论</em></p><p><em>SUBSCRIBE 包中的每个订阅主题总是会有一个对应的原因码。如果原因码的内容不是针对某个订阅主题的（例如 0x91（包ID已被使用）），此原因码需要被设置到对每一个订阅主题的回复上。</em></p><h2 id="3-10-UNSUBSCRIBE-取消订阅请求"><a href="#3-10-UNSUBSCRIBE-取消订阅请求" class="headerlink" title="3.10 UNSUBSCRIBE - 取消订阅请求"></a>3.10 UNSUBSCRIBE - 取消订阅请求</h2><p>UBSUBSCRIBE 包由客户端发往服务器，用来取消对主题的订阅。</p><h3 id="3-10-1-UNSUBSCRIBE固定头"><a href="#3-10-1-UNSUBSCRIBE固定头" class="headerlink" title="3.10.1 UNSUBSCRIBE固定头"></a>3.10.1 UNSUBSCRIBE固定头</h3><p><em>图 3‑28 UNSUBSCRIBE固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（10）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><span class="vcMarked">UNSUBSCRIBE 包固定头中的 Bit 3、2、1、0 为保留字段，其值必须被分别设置为 0、0、1、0。服务器<strong>必须</strong>将其他值视为格式错误的包并关闭网络连接</span> <span class="vcReferred">[MQTT-3.10.1-1]</span>。</p><p><strong>剩余长度</strong></p><p>表示可变头（2 bytes）和载荷的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-10-2-UNSUBSCRIBE可变头"><a href="#3-10-2-UNSUBSCRIBE可变头" class="headerlink" title="3.10.2 UNSUBSCRIBE可变头"></a>3.10.2 UNSUBSCRIBE可变头</h3><p>UNSUBSCRIBE 可变头按序包括下列字段：包ID，属性集。<a href="#2-2-1-%E5%8C%85ID">2.2.1</a> 提供了更多关于包ID的信息。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><h4 id="3-10-2-1-UNSUBSCRIBE属性集"><a href="#3-10-2-1-UNSUBSCRIBE属性集" class="headerlink" title="3.10.2.1 UNSUBSCRIBE属性集"></a>3.10.2.1 UNSUBSCRIBE属性集</h4><h5 id="3-10-2-1-1-属性长度"><a href="#3-10-2-1-1-属性长度" class="headerlink" title="3.10.2.1.1 属性长度"></a>3.10.2.1.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 UNSUBSCRIBE 可变头中的属性集长度。</p><h5 id="3-10-2-1-2-用户属性"><a href="#3-10-2-1-2-用户属性" class="headerlink" title="3.10.2.1.2 用户属性"></a>3.10.2.1.2 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。</p><p>用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><p><em>非规范性评论</em></p><p><em>UNSUBSCRIBE 中的用户属性可以被客户端用来向服务器发送一些订阅依赖的属性。这意味着这些属性并非本规范定义的。</em></p><h3 id="3-10-3-UNSUBSCRIBE载荷"><a href="#3-10-3-UNSUBSCRIBE载荷" class="headerlink" title="3.10.3 UNSUBSCRIBE载荷"></a>3.10.3 UNSUBSCRIBE载荷</h3><p>UNSUBSCRIBE 的载荷中包含着一组客户端希望取消订阅的主题过滤器列表。<span class="vcMarked">UNSUBSCRIBE 中的主题过滤器<strong>必须</strong>是 <code>UTF-8字符串</code></span> <span class="vcReferred">[MQTT-3.10.3-1]</span>，其定义参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a>，这些字符串逐个排放。</p><p><span class="vcMarked">UNSUBSCRIBE 包的载荷中<strong>必须</strong>至少包含一个主题过滤器</span> <span class="vcReferred">[MQTT-3.10.3-2]</span>。不携带载荷的 UNSUBSCRIBE 包视为协议错误。参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 了解关于错误处理的信息。</p><p><em>非规范性示例</em></p><p><em>图 3.30 展示了 UNSUBSCRIBE 载荷中包含两个主题过滤器的示例。第一个是“a&#x2F;b”，第二个是 “c&#x2F;d”。</em></p><p>图 3‑30 - 载荷字节格式非规范性示例</p><table>  <thead>    <tr><td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td colspan="10">主题过滤器</td></tr>    <tr><td>byte 1</td><td>长度高字节（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td>长度低字节（LSB）（3）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>    <tr><td>byte 3</td><td>'a'（0x61）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>    <tr><td>byte 4</td><td>'/'（0x2F）</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>    <tr><td>byte 5</td><td>'b'（0x62）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>    <tr><td colspan="10">主题过滤器</td></tr>    <tr><td>byte 7</td><td>长度高字节（MSB）（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 8</td><td>长度低字节（LSB）（3）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>    <tr><td>byte 9</td><td>'c'（0x63）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>    <tr><td>byte 10</td><td>'/'（0x2F）</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>    <tr><td>byte 11</td><td>'d'（0x64）</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>  </tbody></table><h3 id="3-10-4-UNSUBSCRIBE动作"><a href="#3-10-4-UNSUBSCRIBE动作" class="headerlink" title="3.10.4 UNSUBSCRIBE动作"></a>3.10.4 UNSUBSCRIBE动作</h3><p><span class="vcMarked">服务器<strong>必须</strong>逐字符的核对 UNSUBSCRIBE 包中提供的主题过滤器（无论其是否包含通配符）是否与其持有的当前客户端的订阅相同。如果任何过滤器被精确匹配，那么其拥有的订阅<strong>必须</strong>被删除</span> <span class="vcReferred">[MQTT-3.10.4-1]</span>，除此之外没有额外处理。</p><p>当服务器接收到 UNSUBSCRIBE 时：</p><ul><li><span class="vcMarked">服务器<strong>必须</strong>停止向该主题过滤器添加新的发往客户端的消息</span> <span class="vcReferred">[MQTT-3.10.4-2]</span>。</li><li><span class="vcMarked">服务器<strong>必须</strong>完成匹配该主题过滤器的，且已经开始发往客户端的 QoS 1 和 QoS 2 消息的交付</span> <span class="vcReferred">[MQTT-3.10.4-3]</span>。</li><li>服务器<strong>可以</strong>继续向客户端交付一些现有缓存中的消息。</li></ul><p><span class="vcMarked">服务器<strong>必须</strong>使用 UNSUBACK 包响应 UNSUBSCRIBE 请求</span> <span class="vcReferred">[MQTT-3.10.4-4]</span>。<span class="vcMarked">UNSUBACK 包<strong>必须</strong>和 UNSUBSCRIBE 包有相同的包ID。即使没有主题订阅被删除，服务器也<strong>必须</strong>使用 UNSUBACK 回复</span> <span class="vcReferred">[MQTT-3.10.4-5]</span>。</p><p><span class="vcMarked">如果服务器收到的 UNSUBSCIRIBE 包包含有多个主题过滤器，服务器<strong>必须</strong>按序处理就如同他按序逐个收到了 UNSUBSCRIBE 包，唯一不同是服务器仅需要使用一个 UNSUBACK 回复</span> <span class="vcReferred">[MQTT-3.10.4-6]</span>。</p><p>如果主题过滤器表示一个共享订阅，此会话需要被从共享订阅中移除。如果此会话是共享订阅关联的唯一一个会话，共享订阅需要被删除。参考 <a href="#4-8-2-%E5%85%B1%E4%BA%AB%E8%AE%A2%E9%98%85">4.8.2</a> 了解关于共享订阅处理的描述。</p><h2 id="3-11-UNSUBACK-取消订阅确认"><a href="#3-11-UNSUBACK-取消订阅确认" class="headerlink" title="3.11 UNSUBACK - 取消订阅确认"></a>3.11 UNSUBACK - 取消订阅确认</h2><p>UNSUBACK 包由服务器发往客户端，用于确认 UNSUBSCRIBE 包的接收和处理。</p><h3 id="3-11-1-UNSUBACK固定头"><a href="#3-11-1-UNSUBACK固定头" class="headerlink" title="3.11.1 UNSUBACK固定头"></a>3.11.1 UNSUBACK固定头</h3><p><em>图 3-31 UNSUBACK包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（11）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变头和载荷的长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-11-2-UNSUBACK可变头"><a href="#3-11-2-UNSUBACK可变头" class="headerlink" title="3.11.2 UNSUBACK可变头"></a>3.11.2 UNSUBACK可变头</h3><p>UNSUBACK 可变头按序包括下列字段：与其回复的 UNSUBSCRIBE 对应的包ID，属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><p>图 3-32 UNSUBACK 包可变头</p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="8">包ID高位（MSB）</td></tr>    <tr><td>byte 2</td><td colspan="8">包ID低位（LSB）</td></tr>  </tbody></table><p><span class="vcTrans">译者认为这里缺失了属性长度</span></p><h4 id="3-11-2-1-UNSUBACK属性集"><a href="#3-11-2-1-UNSUBACK属性集" class="headerlink" title="3.11.2.1 UNSUBACK属性集"></a>3.11.2.1 UNSUBACK属性集</h4><h5 id="3-11-2-1-1-属性长度"><a href="#3-11-2-1-1-属性长度" class="headerlink" title="3.11.2.1.1 属性长度"></a>3.11.2.1.1 属性长度</h5><p>属性长度是采用 <code>变长整数</code> 编码的 UNSUBACK 可变头中的属性集长度。</p><h5 id="3-11-2-1-2-原因字符串"><a href="#3-11-2-1-2-原因字符串" class="headerlink" title="3.11.2.1.2 原因字符串"></a>3.11.2.1.2 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示此响应关联的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p>服务器使用此字段向客户端传递额外的信息。<span class="vcMarked">如果添加此字段会导致 UNSUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.11.2-1]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-11-2-1-3-用户属性"><a href="#3-11-2-1-3-用户属性" class="headerlink" title="3.11.2.1.3 用户属性"></a>3.11.2.1.3 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 UNSUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.11.2-2]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h3 id="3-11-3-UNSUBACK载荷"><a href="#3-11-3-UNSUBACK载荷" class="headerlink" title="3.11.3 UNSUBACK载荷"></a>3.11.3 UNSUBACK载荷</h3><p>载荷带有一个原因码列表。每个原因码和 UNSUBSCRIBE 包中的一个主题过滤器对应。<span class="vcMarked">UNSUBACK 包中的原因码顺序<strong>必须</strong>和 UNSUBSCRIBE 包中的主题过滤器顺序一致</span> <span class="vcReferred">[MQTT-3.11.3-1]</span>。</p><p>无符号一字节的取消订阅原因码参见下表。<span class="vcMarked">服务器发送的 UNSUBACK 包<strong>必须</strong>对每个收到的主题过滤器使用下表之一的原因码</span> <span class="vcReferred">[MQTT-3.11.3-2]</span>。</p><p>表 3‑9 - 取消订阅原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>Success</td><td>订阅已被删除。</td></tr><tr><td>17</td><td>0x11</td><td>没有存在的订阅</td><td>没有匹配到客户端使用的主题过滤器。</td></tr><tr><td>2</td><td>0x02</td><td>授予 QoS 2</td><td>订阅已被接收，服务器接收到的所有 QoS 值都会向其转发。</td></tr><tr><td>128</td><td>0x80</td><td>未指定错误</td><td>订阅未被接收，服务器不愿透露原因或其他原因码不匹配。</td></tr><tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>UNSUBSCRIBE 合法，但服务器未接收。</td></tr><tr><td>135</td><td>0x87</td><td>未经授权</td><td>客户端未被授予取消此订阅的权力。</td></tr><tr><td>143</td><td>0x8F</td><td>主题过滤器不可用</td><td>主题过滤器格式正确，但不允许此客户端使用。</td></tr><tr><td>145</td><td>0x91</td><td>包ID已被使用</td><td>所选的包ID已经在使用中。</td></tr></tbody></table><p><em>非规范性评论</em></p><p><em>UNSUBSCRIBE 包中的每个主题过滤器总是会有一个对应的原因码。如果原因码的内容不是针对某个主题过滤器的（例如 0x91（包ID已被使用）），此原因码需要被设置到对每一个主题过滤器的回复上。</em></p><h2 id="3-12-PINGREQ-PING请求"><a href="#3-12-PINGREQ-PING请求" class="headerlink" title="3.12 PINGREQ - PING请求"></a>3.12 PINGREQ - PING请求</h2><p>PINGREQ 包由客户端发往服务器。可以用于：</p><ul><li>在没有其他 MQTT 包需要被发往服务器时，使用 PINGREQ 向服务器表明客户端依然在线。</li><li>请求服务器的响应，用来确认服务器是否在线。</li><li>测试网络连接，确保网络通讯正常。</li></ul><p>PINGREQ 包用于保活处理。参考 <a href="#3-1-2-10-%E4%BF%9D%E6%B4%BB%E6%97%B6%E9%97%B4">3.1.2.10</a> 了解更多细节。</p><h3 id="3-12-1-PINGREQ固定头"><a href="#3-12-1-PINGREQ固定头" class="headerlink" title="3.12.1 PINGREQ固定头"></a>3.12.1 PINGREQ固定头</h3><p><em>图 3.33 – PINGREQ 包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（12）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度（0）</td></tr>    <tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>  </tbody></table><h3 id="3-12-2-PINGREQ可变头"><a href="#3-12-2-PINGREQ可变头" class="headerlink" title="3.12.2 PINGREQ可变头"></a>3.12.2 PINGREQ可变头</h3><p>PINGRESP 包没有可变头。</p><h3 id="3-12-3-PINGREQ载荷"><a href="#3-12-3-PINGREQ载荷" class="headerlink" title="3.12.3 PINGREQ载荷"></a>3.12.3 PINGREQ载荷</h3><p>PINGREQ 包没有载荷。</p><h3 id="3-12-4-PINGREQ动作"><a href="#3-12-4-PINGREQ动作" class="headerlink" title="3.12.4 PINGREQ动作"></a>3.12.4 PINGREQ动作</h3><p><span class="vcMarked">服务器<strong>必须</strong>发送 PINGRESP 包用来响应 PINGREQ 包</span> <span class="vcReferred">[MQTT-3.12.4-1]</span>。</p><h2 id="3-13-PINGRESP-PING响应"><a href="#3-13-PINGRESP-PING响应" class="headerlink" title="3.13 PINGRESP - PING响应"></a>3.13 PINGRESP - PING响应</h2><p>PINGRESP 包由服务器发往客户端，用于响应 PINGREQ 包。他表示服务器处于可用状态。</p><p>PINGRESP 包用于保活处理。参考 <a href="#3-1-2-10-%E4%BF%9D%E6%B4%BB%E6%97%B6%E9%97%B4">3.1.2.10</a> 了解更多细节。</p><h3 id="3-13-1-PINGRESP固定头"><a href="#3-13-1-PINGRESP固定头" class="headerlink" title="3.13.1 PINGRESP固定头"></a>3.13.1 PINGRESP固定头</h3><p><em>图 3.34 – PINGRESP 包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（13）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度（0）</td></tr>    <tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>  </tbody></table><h3 id="3-13-2-PINGRESP可变头"><a href="#3-13-2-PINGRESP可变头" class="headerlink" title="3.13.2 PINGRESP可变头"></a>3.13.2 PINGRESP可变头</h3><p>PINGRESP 包没有可变头。</p><h3 id="3-13-3-PINGRESP载荷"><a href="#3-13-3-PINGRESP载荷" class="headerlink" title="3.13.3 PINGRESP载荷"></a>3.13.3 PINGRESP载荷</h3><p>PINGRESP 包没有载荷。</p><h3 id="3-13-3-PINGRESP动作"><a href="#3-13-3-PINGRESP动作" class="headerlink" title="3.13.3 PINGRESP动作"></a>3.13.3 PINGRESP动作</h3><p>客户端收到此包后无动作。</p><h2 id="3-14-DISCONNECT-断开通知"><a href="#3-14-DISCONNECT-断开通知" class="headerlink" title="3.14 DISCONNECT - 断开通知"></a>3.14 DISCONNECT - 断开通知</h2><p>DISCONNECT 包是客户端或服务器发送的最后一个 MQTT 包。他表示了网络连接中断的原因。客户端或服务器<strong>可以</strong>在断开网络连接前发送 DISCONNECT 包。如果网络连接并非在客户端发送原因码 0x00（普通断开）的 DISCONNECT 后关闭，且连接持有遗嘱消息，遗嘱消息将被发布。参考 <a href="#3-1-2-5-%E9%81%97%E5%98%B1%E6%A0%87%E8%AF%86">3.1.2.5</a> 了解更多细节。</p><p><span class="vcMarked">服务器<strong>必须不</strong>发送 DISCONNECT 包，除非在其发送了一个原因码小于 0x80 的 CONNACK 之后</span> <span class="vcReferred">[MQTT-3.14.0-1]</span>。</p><h3 id="3-14-1-DISCONNECT固定头"><a href="#3-14-1-DISCONNECT固定头" class="headerlink" title="3.14.1 DISCONNECT固定头"></a>3.14.1 DISCONNECT固定头</h3><p><em>图 3.35 – DISCONNECT 包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（14）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><span class="vcMarked">客户端或服务器必须确认保留字段值为 0。如果非 0，客户端或服务器发送一个带有原因码 0x81（格式错误的包）的 DISCONNECT 包，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中的描述</span> <span class="vcReferred">[MQTT-3.14.1-1]</span>。</p><p><strong>剩余长度字段</strong></p><p>表示可变头长度，采用 <code>变长整数</code> 编码。</p><h3 id="3-14-2-DISCONNECT可变头"><a href="#3-14-2-DISCONNECT可变头" class="headerlink" title="3.14.2 DISCONNECT可变头"></a>3.14.2 DISCONNECT可变头</h3><p>DISCONNECT 包可变头按序包括下列字段：断开原因码、属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><h4 id="3-14-2-1-断开原因码"><a href="#3-14-2-1-断开原因码" class="headerlink" title="3.14.2.1 断开原因码"></a>3.14.2.1 断开原因码</h4><p>可变头中的 Byte 1 是断开原因码。如果剩余长度的值小于 1，表示没有设置原因码，采用默认值 0x00（普通断开）。</p><p>一个 byte 的无符号断开原因码字段参考下表。</p><p>表 3‑10 断开原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名称</th><th>发送方</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>普通断开</td><td>客户端或服务器</td><td>普通断开连接。无需发布遗嘱。</td></tr><tr><td>4</td><td>0x04</td><td>携带遗嘱的断开链接</td><td>客户端</td><td>客户端希望断开连接，但要求服务器发布遗嘱。</td></tr><tr><td>128</td><td>0x80</td><td>未指定错误</td><td>客户端或服务器</td><td>连接被断开，发送方不想透露原因，或没有匹配原因的原因码。</td></tr><tr><td>129</td><td>0x81</td><td>格式错误的包</td><td>客户端或服务器</td><td>收到的包不符合本规范。</td></tr><tr><td>130</td><td>0x82</td><td>协议错误</td><td>客户端或服务器</td><td>收到非预期的或顺序错误的包。</td></tr><tr><td>131</td><td>0x83</td><td>特定实现错误</td><td>客户端或服务器</td><td>收到的包正确，但不能被本实现处理。</td></tr><tr><td>135</td><td>0x87</td><td>未经授权</td><td>服务器</td><td>请求未经授权。</td></tr><tr><td>137</td><td>0x89</td><td>服务器忙</td><td>服务器</td><td>服务器繁忙，无法继续处理该客户端的请求。</td></tr><tr><td>139</td><td>0x8B</td><td>服务器关闭</td><td>服务器</td><td>服务器已经关闭。</td></tr><tr><td>141</td><td>0x8D</td><td>保活超时</td><td>服务器</td><td>因在保活时间 1.5 倍的时间内未收到包，连接已经关闭。</td></tr><tr><td>142</td><td>0x8E</td><td>会话被接管</td><td>服务器</td><td>其他使用同样客户端ID的连接已连接，导致此连接关闭。</td></tr><tr><td>143</td><td>0x8F</td><td>主题过滤器不可用</td><td>服务器</td><td>主题过滤器格式正确，但不被服务器接受。</td></tr><tr><td>144</td><td>0x90</td><td>主题名不可用</td><td>客户端或服务器</td><td>主题名格式正确，但不被客户端或服务器接受。</td></tr><tr><td>147</td><td>0x93</td><td>超出接收最大值</td><td>客户端或服务器</td><td>客户端或服务器接受而未发送 PUBACK 或 PUBCOMP 的包超过了其接收最大值。</td></tr><tr><td>148</td><td>0x94</td><td>主题别名不可用</td><td>客户端或服务器</td><td>客户端或服务器接收的 PUBLISH 包中设置的主题别名大于其在 CONNECT 或 CONNACK 中设置的主题别名最大值。</td></tr><tr><td>149</td><td>0x95</td><td>包过大</td><td>客户端或服务器</td><td>包尺寸大于客户端或服务器设置的最大包尺寸。</td></tr><tr><td>150</td><td>0x96</td><td>消息频率过高</td><td>客户端或服务器</td><td>接收的数据频率过高。</td></tr><tr><td>151</td><td>0x97</td><td>超限</td><td>客户端或服务器</td><td>超出了该实现或管理员设置的限制。</td></tr><tr><td>152</td><td>0x98</td><td>管理员行为</td><td>客户端或服务器</td><td>连接被管理员关闭。</td></tr><tr><td>153</td><td>0x99</td><td>载荷格式错误</td><td>客户端或服务器</td><td>载荷格式与载荷格式标志不匹配。</td></tr><tr><td>154</td><td>0x9A</td><td>不支持保留消息</td><td>服务器</td><td>服务器不支持保留消息。</td></tr><tr><td>155</td><td>0x9B</td><td>不支持的 QoS</td><td>服务器</td><td>客户端选择的 QoS 大于 CONNACK 中设置的最大QoS。</td></tr><tr><td>156</td><td>0x9C</td><td>使用另一台服务器</td><td>服务器</td><td>客户端需要临时使用其他服务器。</td></tr><tr><td>157</td><td>0x9D</td><td>服务器迁移</td><td>服务器</td><td>服务器已经迁移，客户端需要永久改变其服务器地址。</td></tr><tr><td>158</td><td>0x9E</td><td>不支持共享订阅</td><td>服务器</td><td>服务器不支持共享订阅。</td></tr><tr><td>159</td><td>0x9F</td><td>连接频率超限</td><td>服务器</td><td>因连接频率过高，连接被关闭。</td></tr><tr><td>160</td><td>0xA0</td><td>最大连接时间</td><td>服务器</td><td>此链接超过了其被授予的最大连接时间。</td></tr><tr><td>161</td><td>0xA1</td><td>不支持订阅ID</td><td>服务器</td><td>服务器不支持订阅ID，订阅未被接受。</td></tr><tr><td>162</td><td>0xA2</td><td>不支持通配符订阅</td><td>服务器</td><td>服务器不支持通配符订阅，订阅未被接受。</td></tr></tbody></table><p><span class="vcMarked">客户端或服务器发送的 DISCONNECT 包<strong>必须</strong>使用上表之一的断开原因码</span> <span class="vcReferred">[MQTT-3.14.2-1]</span>。如果断开原因码的值是 0x00（普通断开）且没有属性集，原因码和属性长度可以被省略。此时 DISCONNECT 固定头中的剩余长度值为 0。</p><p><em>非规范性评论</em></p><p><em>DISCONNECT 包用来在没有响应包的情况下表示断开连接的原因（比如 QoS 0 的发布），或是当客户端或服务器无法继续处理连接时用以断开连接。</em></p><p><em>非规范性评论</em></p><p><em>DISCONNECT 提供的信息可以被客户端用来判断是否需要重连，或是等待多久以后尝试重连。</em></p><h4 id="3-14-2-2-DISCONNECT属性集"><a href="#3-14-2-2-DISCONNECT属性集" class="headerlink" title="3.14.2.2 DISCONNECT属性集"></a>3.14.2.2 DISCONNECT属性集</h4><h5 id="3-14-2-2-1-属性长度"><a href="#3-14-2-2-1-属性长度" class="headerlink" title="3.14.2.2.1 属性长度"></a>3.14.2.2.1 属性长度</h5><p>使用 <code>变长整数</code> 编码的 DISCONNECT 可变头中的属性集长度。如果剩余长度的值小于 2，表示属性集的长度为 0。</p><h5 id="3-14-2-2-2-会话过期间隔"><a href="#3-14-2-2-2-会话过期间隔" class="headerlink" title="3.14.2.2.2 会话过期间隔"></a>3.14.2.2.2 会话过期间隔</h5><p>会话过期间隔的属性ID是<strong>17 (0x11) Byte</strong>。</p><p>随后跟随 <code>4字节整数</code> 用来表示会话过期间隔，单位为秒。在属性集中出现超过一次会话过期间隔视为协议错误。</p><p>如果会话过期间隔未设置，则使用 CONNECT 包中的值。</p><p><span class="vcMarked">服务器发送的 DISCONNECT 包中<strong>必须不</strong>包括会话过期间隔</span> <span class="vcReferred">[MQTT-3.14.2-2]</span>。</p><p>如果 CONNECT 包中的会话过期间隔值为 0，客户端在 DISCONNECT 包中包括一个非 0 值的会话过期间隔视为协议错误。如果这样一个非 0 值的会话过期间隔的包被服务器接收，服务器无需将他作为一个合法的 DISCONNECT 包对待。服务器使用带有原因码 0x82（协议错误）的 DISCONNECT 包断开连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><h5 id="3-14-2-2-3-原因字符串"><a href="#3-14-2-2-3-原因字符串" class="headerlink" title="3.14.2.2.3 原因字符串"></a>3.14.2.2.3 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示断开连接的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p><span class="vcMarked">如果添加此字段会导致 DISCONNECT 的尺寸大于接收者的最大包尺寸，发送者<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.14.2-3]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-14-2-2-4-用户属性"><a href="#3-14-2-2-4-用户属性" class="headerlink" title="3.14.2.2.4 用户属性"></a>3.14.2.2.4 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 DISCONNECT 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.14.2-4]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h5 id="3-14-2-2-5-服务引用"><a href="#3-14-2-2-5-服务引用" class="headerlink" title="3.14.2.2.5 服务引用"></a>3.14.2.2.5 服务引用</h5><p>服务引用的属性ID是<strong>28 (0x1C) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示客户都安可以使用的其他服务器。服务引用在属性集中出现超过一次视为协议错误。</p><p>服务器发送原因码为 0x9C（使用另一台服务器）或 0x9D（服务器迁移）的 DISCONNECT 包时包括服务引用字段，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a>。</p><p>参考 <a href="#4-11-%E6%9C%8D%E5%8A%A1%E9%87%8D%E5%AE%9A%E5%90%91">4.11</a> 服务重定向了解如何使用服务引用的信息。</p><p>图 3‑24 DISCONNECT 包可变头非规范性示例</p><table>  <thead>    <tr>      <td></td><td>描述</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>    </tr>  </thead>  <tbody>    <tr>      <td colspan="10">断开原因码</td>    </tr>    <tr>      <td>byte 1</td><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td colspan="10">属性集</td>    </tr>    <tr>      <td>byte 2</td><td>属性长度（5）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 3</td><td>会话过期间隔标志（17）</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td>    </tr>    <tr>      <td>byte 4</td><td rowspan="4">会话过期间隔（0）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 5</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 6</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>    <tr>      <td>byte 7</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>    </tr>  </tbody></table><h3 id="3-14-3-DISCONNECT载荷"><a href="#3-14-3-DISCONNECT载荷" class="headerlink" title="3.14.3 DISCONNECT载荷"></a>3.14.3 DISCONNECT载荷</h3><p>DISCONNECT 包没有载荷。</p><h3 id="3-14-4-DISCONNECT动作"><a href="#3-14-4-DISCONNECT动作" class="headerlink" title="3.14.4 DISCONNECT动作"></a>3.14.4 DISCONNECT动作</h3><p><span class="vcMarked">发送 DISCONNECT 后，发送方将</span>：</p><ul><li><span class="vcMarked"><strong>必须不</strong>在此网络连接中再发送任何 MQTT 包</span> <span class="vcReferred">[MQTT-3.14.4-1]</span>。</li><li><span class="vcMarked"><strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-3.14.4-2]</span>。</li></ul><p><span class="vcMarked">当接收到带有原因码 0x00（成功） 的 DISCONNECT 包后，服务器将</span>：</p><ul><li><span class="vcMarked"><strong>必须</strong>不发送改连接的遗嘱消息，并丢弃</span> <span class="vcReferred">[MQTT-3.14.4-3]</span>，参考 <a href="#3-1-2-5-%E9%81%97%E5%98%B1%E6%A0%87%E8%AF%86">3.1.2.5</a> 中的描述。</li></ul><p>当接收到 DISCONNECT 后，接收者将：</p><ul><li><strong>应该</strong>关闭网络连接。</li></ul><h2 id="3-15-AUTH-认证交换"><a href="#3-15-AUTH-认证交换" class="headerlink" title="3.15 AUTH - 认证交换"></a>3.15 AUTH - 认证交换</h2><p>AUTH 包由客户端发送到服务器，或有服务器发送到客户端，作为增强认证交换的一部分，类似 挑战&#x2F;响应 的认证方式。当服务器或客户端的 CONNECT 包中没有包含相同的认证方式时，发送 AUTH 包视为协议错误。</p><h3 id="3-15-1-AUTH固定头"><a href="#3-15-1-AUTH固定头" class="headerlink" title="3.15.1 AUTH固定头"></a>3.15.1 AUTH固定头</h3><p><em>图 3.35 – AUTH 包固定头</em></p><table>  <thead>    <tr><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  </thead>  <tbody>    <tr><td>byte 1</td><td colspan="4">MQTT包类型（15）</td><td colspan="4">保留</td></tr>    <tr><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>    <tr><td>byte 2</td><td colspan="8">剩余长度</td></tr>  </tbody></table><p><span class="vcMarked">AUTH 包固定头中的 Bit 3、2、1、0 的内容保留且值必须为 0。客户端或服务器<strong>必须</strong>将任何其他值视为格式错误的包并断开网络连接</span> <span class="vcReferred">[MQTT-3.15.1-1]</span>。</p><p><strong>剩余长度字段</strong></p><p>使用 <code>变长整数</code> 编码的可变头长度。</p><h3 id="3-15-2-AUTH可变头"><a href="#3-15-2-AUTH可变头" class="headerlink" title="3.15.2 AUTH可变头"></a>3.15.2 AUTH可变头</h3><p>AUTH 包的可变头按序包括下列字段：认证原因码、属性集。属性集的编码规则和描述参考 <a href="#2-2-2-%E5%B1%9E%E6%80%A7%E9%9B%86">2.2.2</a>。</p><h4 id="3-15-2-1-认证原因码"><a href="#3-15-2-1-认证原因码" class="headerlink" title="3.15.2.1 认证原因码"></a>3.15.2.1 认证原因码</h4><p>可变头中的 Byte 0 是认证原因码。一个 byte 的无符号断开原因码字段参考下表。<span class="vcMarked">AUTH 包的发送者<strong>必须</strong>使用下表之一的认证原因码</span> <span class="vcReferred">[MQTT-3.15.2-1]</span>。</p><p>表 3‑11 认证原因码</p><table><thead><tr><th>值</th><th>Hex</th><th>原因码名称</th><th>发送方</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>成功</td><td>服务器</td><td>认证成功。</td></tr><tr><td>24</td><td>0x18</td><td>继续认证</td><td>客户端或服务器</td><td>使用下个步骤继续认证。</td></tr><tr><td>25</td><td>0x19</td><td>重新认证</td><td>客户端</td><td>初始化重新认证。</td></tr></tbody></table><p>如果认证原因码的值是 0x00（成功）且没有属性集，原因码和属性长度可以被省略。此时 AUTH 固定头中的剩余长度值为 0。</p><h4 id="3-15-2-2-AUTH属性集"><a href="#3-15-2-2-AUTH属性集" class="headerlink" title="3.15.2.2 AUTH属性集"></a>3.15.2.2 AUTH属性集</h4><h5 id="3-15-2-2-1-属性长度"><a href="#3-15-2-2-1-属性长度" class="headerlink" title="3.15.2.2.1 属性长度"></a>3.15.2.2.1 属性长度</h5><p>使用 <code>变长整数</code> 编码的 AUTH 包中的属性集长度。</p><h5 id="3-15-2-2-2-认证方式"><a href="#3-15-2-2-2-认证方式" class="headerlink" title="3.15.2.2.2 认证方式"></a>3.15.2.2.2 认证方式</h5><p>认证方式的属性ID是<strong>21 (0x15) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 包含认证方式字符串。认证方式的缺失或出现超过一次均视为协议错误。参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 了解更多关于增强认证的信息。</p><h5 id="3-15-2-2-3-认证数据"><a href="#3-15-2-2-3-认证数据" class="headerlink" title="3.15.2.2.3 认证数据"></a>3.15.2.2.3 认证数据</h5><p>认证数据的属性ID是<strong>22 (0x16) Byte</strong>。</p><p>随后跟随 <code>二进制数据</code>，其中包括认证数据。认证数据在属性集中出现超过一次视为协议错误。认证数据的内容是由认证方式决定的。参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 了解更多关于增强认证的信息。</p><h5 id="3-15-2-2-4-原因字符串"><a href="#3-15-2-2-4-原因字符串" class="headerlink" title="3.15.2.2.4 原因字符串"></a>3.15.2.2.4 原因字符串</h5><p>原因字符串的属性ID是<strong>31 (0x1F) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串</code> 表示断开连接的原因。原因字符串是人类可读的用于诊断故障的字符串，<strong>不应该</strong>被接收方解析。</p><p><span class="vcMarked">如果添加此字段会导致 AUTH 的尺寸大于接收者的最大包尺寸，发送者<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.15.2-2]</span>。原因字符串在属性集中出现超过一次视为协议错误。</p><h5 id="3-15-2-2-5-用户属性"><a href="#3-15-2-2-5-用户属性" class="headerlink" title="3.15.2.2.5 用户属性"></a>3.15.2.2.5 用户属性</h5><p>用户属性的属性ID是<strong>38 (0x26) Byte</strong>。</p><p>随后跟随 <code>UTF-8字符串对</code>。这个属性可以用于提供额外的诊断信息或者其他信息。<span class="vcMarked">如果添加此字段会导致 AUTH 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</span> <span class="vcReferred">[MQTT-3.15.2-3]</span>。用户属性可以出现多次用以发送多个键-值对。同样的键允许出现超过一次。</p><h3 id="3-15-3-AUTH载荷"><a href="#3-15-3-AUTH载荷" class="headerlink" title="3.15.3 AUTH载荷"></a>3.15.3 AUTH载荷</h3><p>AUTH 包没有载荷。</p><h3 id="3-15-4-AUTH动作"><a href="#3-15-4-AUTH动作" class="headerlink" title="3.15.4 AUTH动作"></a>3.15.4 AUTH动作</h3><p>参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 了解更多关于增强认证的信息。</p><h1 id="4-操作行为"><a href="#4-操作行为" class="headerlink" title="4 操作行为"></a>4 操作行为</h1><h2 id="4-1-会话状态"><a href="#4-1-会话状态" class="headerlink" title="4.1 会话状态"></a>4.1 会话状态</h2><p>为了实现 QoS 1 和 QoS 2 的协议流程，客户端和服务器需要设置一些与客户端ID关联的状态，这被称为会话状态。服务器同时也将订阅信息作为会话状态的一部分存储。</p><p>会话状态可以跨连续的多个网络连接持续保持。会话状态的持续时间为最近的一次网络连接存在时间加上会话过期间隔。</p><p>客户端的会话状包括：</p><ul><li>已经发送给服务器，但没有完成的 QoS 1 和 QoS 2 消息。</li><li>从服务器收到，但没有完成的 QoS 2 消息。</li></ul><p>服务器的会话状态包括：</p><ul><li>会话的存在，即便会话中其余所有内容均为空。</li><li>客户端订阅，包括所有订阅ID。</li><li>已经发送给服务器，但没有完成的 QoS 1 和 QoS 2 消息。</li><li>等待传输到客户端的 QoS 1 和 QoS 2 消息，<strong>可选</strong>的等待传输到客户端的 QoS 0 消息。</li><li>从客户端收到的，但没有完成的 QoS 2 消息。遗嘱消息和遗嘱延迟间隔。</li><li>如果会话当前未连接，存储会话结束和被丢弃的时间。</li></ul><p>保留消息在服务器中不做为会话状态的一部分，保留消息不会在会话结束时被删除。</p><h3 id="4-1-1-存储会话状态"><a href="#4-1-1-存储会话状态" class="headerlink" title="4.1.1 存储会话状态"></a>4.1.1 存储会话状态</h3><p><span class="vcMarked">客户端和服务器<strong>必须不</strong>在网络连接打开时丢弃会话状态</span> <span class="vcReferred">[MQTT-4.1.0-1]</span>。<span class="vcMarked">服务器<strong>必须</strong>在网络连接关闭且会话过期间隔到期后丢弃会话状态</span> <span class="vcReferred">[MQTT-4.1.0-2]</span>。</p><p><em>非规范性评论</em></p><p><em>客户端与服务器实现的存储能力当然会受到容量限制，并且可能受到管理策略的限制。存储的会话状态可以被管理员行为丢弃，也可以被一些自动机制丢弃。这具有终止会话的效果。这些操作可能是由资源限制或其他操作原因引起的。硬件或软件故障可能会导致客户端或服务器存储的会话状态丢失或损坏。谨慎评估客户端和服务器的存储能力以确保他们足以承载业务。</em></p><h3 id="4-1-2-会话状态非规范性示例"><a href="#4-1-2-会话状态非规范性示例" class="headerlink" title="4.1.2 会话状态非规范性示例"></a>4.1.2 会话状态非规范性示例</h3><p>例如，电表抄表解决方案可能使用 QoS 1 消息来保护读数免遭网络丢失。解决方案开发人员可能已经确定电源足够可靠，在这种情况下，客户端和服务器中的数据可以存储在易失性存储器中，而不会带来太大的丢失风险。</p><p>相反，停车计时器支付应用程序提供商可能会决定支付消息不应因网络或客户端故障而丢失。因此，它们要求所有数据在通过网络传输之前都写入非易失性存储器。</p><h2 id="4-2-网络连接"><a href="#4-2-网络连接" class="headerlink" title="4.2 网络连接"></a>4.2 网络连接</h2><p>MQTT 协议依赖于一个有序、无损、基于数据流的双向底层传输协议。本规范并不指定特定的传输层协议。</p><p>MQTT 协议需要一个底层传输来提供从客户端到服务器以及从服务器到客户端的有序、无损的字节流。 该规范不需要任何特定传输协议的支持。 客户端或服务器可以支持此处列出的任何传输协议，或满足本节要求的任何其他传输协议。客户端或服务器<strong>可以</strong>选择下表中的任意传输协议，或选择符合本 <a href="#4-2-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">章节</a> 要求的任意传输协议。</p><p><em>非规范性评论</em></p><p><em><a href="#1.4-RFC0793">RFC0793</a> 中定义的 TCP&#x2F;IP 可以被用于 MQTT 5.0。下列传输协议也可以：</em></p><ul><li><em>TLS <a href="#1.4-RFC5246">RFC5246</a></em></li><li><em>WebSocket <a href="#1.3-RFC6455">RFC6455</a></em></li></ul><p><em>非规范性评论</em></p><p><em>TCP 端口 8883 和 1883 已经向 IANA 注册为 MQTT TLS 端口和 MQTT 非 TLS 端口。</em></p><p><em>非规范性评论</em></p><p><em>无连接的网络传输如 UDP，不适用于 MQTT，因为这些协议可能造成丢包或乱序。</em></p><h2 id="4-3-QoS和协议流程"><a href="#4-3-QoS和协议流程" class="headerlink" title="4.3 QoS和协议流程"></a>4.3 QoS和协议流程</h2><p>MQTT 协议根据本章中定义的服务质量（QoS）交付应用消息。交付协议是对称的，在下面的描述中，客户端和服务器各自可以充当发送者或接收者的角色。传输协议仅涉及将应用消息从单个发送方传交付到接收方。当服务器向多个客户端交付应用消息时，每个客户端会被分别处理。用于发往客户端的出站消息的 QoS 等级可能和入站消息的 QoS 等级不同。</p><h3 id="4-3-1-QoS-0：至多一次"><a href="#4-3-1-QoS-0：至多一次" class="headerlink" title="4.3.1 QoS 0：至多一次"></a>4.3.1 QoS 0：至多一次</h3><p>消息根据底层网络的能力进行交付。接收方不发送任何响应，发送方也不执行重试。消息要么到达接收者一次，要么不到达。</p><p><span class="vcMarked">在 QoS 0 交付协议中，发送方</span></p><ul><li><span class="vcMarked"><strong>必须</strong>发送 QoS 0 且重复标志值为 0 的 PUBLISH 包。</span> <span class="vcReferred">[MQTT-4.3.1-1]</span>.</li></ul><p>在 QoS 0 交付协议中，接收方</p><ul><li>在收到 PUBLISH 包时获得消息的所有权</li></ul><p>图 4.1 – QoS 0 协议流图，非规范性示例</p><table><thead><tr><th>发送方动作</th><th>数据包</th><th>接收方动作</th></tr></thead><tbody><tr><td>PUBLISH QoS 0，DUP&#x3D;0</td><td></td><td></td></tr><tr><td></td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>将消息传递给适当的接收者</td></tr></tbody></table><h3 id="4-3-2-Qos-1：至少一次"><a href="#4-3-2-Qos-1：至少一次" class="headerlink" title="4.3.2 Qos 1：至少一次"></a>4.3.2 Qos 1：至少一次</h3><p>QoS 1 保证消息至少到达接收方一次。QoS 1 需要在 PUBLISH 可变头中携带一个包ID，并且这个包ID也会在回复的 PUBACK 中使用。<a href="#2-2-1-%E5%8C%85ID">2.2.1</a> 提供了更多关于包ID的信息。</p><p><span class="vcMarked">在 QoS 1 交付协议中，发送方</span></p><ul><li><span class="vcMarked"><strong>必须</strong>在每次发布新消息时选择一个未被使用的包ID</span> <span class="vcReferred">[MQTT-4.3.2-1]</span>。</li><li><span class="vcMarked"><strong>必须</strong>发送包含此包ID，且重复标志值为 0 的 PUBLISH 包</span> <span class="vcReferred">[MQTT-4.3.2-2]</span>。</li><li><span class="vcMarked"><strong>必须</strong>将此 PUBLISH 包视为 “未回复的” 直到从接收方收到了正确的 PUBACK</span>。参考 <a href="#4-4-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%87%8D%E8%AF%95">4.4</a> 了解关于未回复消息的讨论 <span class="vcReferred">[MQTT-4.3.2-3]</span>。</li></ul><p>发送方接收到 PUBACK 包后，此包ID可被重用。</p><p>需要注意，发送者被允许在等待接收回复时发送更多带有不同包ID的 PUBLISH 包。</p><p><span class="vcMarked">在 QoS 1 交付协议中，接收方</span></p><ul><li><span class="vcMarked"><strong>必须</strong>使用包含 PUBLISH 包中包ID的 PUBACK 包进行响应，拥有收到的消息的所有权</span> <span class="vcReferred">[MQTT-4.3.2-4]</span>。</li><li><span class="vcMarked">在发送 PUBACK 包后，接收方<strong>必须</strong>将到来的带有相同包ID的 PUBLISH 包视为新的应用消息，无论其重复标志如何设置</span> <span class="vcReferred">[MQTT-4.3.2-5]</span>。</li></ul><p>图 4.2 – QoS 1 协议流图，非规范性示例</p><table><thead><tr><th>发送方动作</th><th>数据包</th><th>接收方动作</th></tr></thead><tbody><tr><td>存储消息</td><td></td><td></td></tr><tr><td>发送 PUBLISH QoS 1，DUP&#x3D;0，&lt;包ID&gt;</td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>开始转发应用消息<sup>1</sup></td></tr><tr><td></td><td>&lt;———-</td><td>发送 PUBACK &lt;包ID&gt;</td></tr><tr><td>丢弃消息</td><td></td><td></td></tr></tbody></table><p><sup>1</sup>接收方无需在发送 PUBACK 前完成应用消息的转发。当原有的发送方收到 PUBACK 时，应用消息的所有权已经转移到了接收方。</p><h3 id="4-3-3-Qos-2：确保一次"><a href="#4-3-3-Qos-2：确保一次" class="headerlink" title="4.3.3 Qos 2：确保一次"></a>4.3.3 Qos 2：确保一次</h3><p>QoS 2 是最高级的 QoS，用于消息既不能丢失又不能重复的场合。使用 QoS 2 会带来额外的开销。</p><p>QoS 2 消息的可变头中带有包ID。章节 <a href="#2-2-1-%E5%8C%85ID">2.2.1</a> 提供了关于包ID的更多信息。QOS 2 PUBLISH 包的接收方使用两步确认过程来确认接收。</p><p><span class="vcMarked">在 QoS 2 交付协议中，发送方</span>：</p><ul><li><span class="vcMarked"><strong>必须</strong>在发布新消息时分配一个未使用的包ID</span> <span class="vcReferred">[MQTT-4.3.3-1]</span>。</li><li><span class="vcMarked"><strong>必须</strong>发送 QoS 2，重复标志值为 0，携带此包ID的 PUBLISH 包</span> <span class="vcReferred">[MQTT-4.3.3-2]</span>。</li><li><span class="vcMarked"><strong>必须</strong>在收到接收方发来的对应的 PUBREC 之前将此 PUBLISH 包视为 “未回复的”</span> <span class="vcReferred">[MQTT-4.3.3-3]</span>。参考 <a href="#4-4-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%87%8D%E8%AF%95">4.4</a> 了解关于未回复消息的讨论。</li><li><span class="vcMarked"><strong>必须</strong>在收到接收方发来的原因码小于 0x80 的 PUBREC 后，发送 PUBREL 包。此 PUBREL 包<strong>必须</strong>包含和原始 PUBLISH 包相同的包ID</span> <span class="vcReferred">[MQTT-4.3.3-4]</span>。</li><li><span class="vcMarked"><strong>必须</strong>在收到接收方发来的对应 PUBCOMP 之前将此 PUBREL 包视为 “未回复的”</span> <span class="vcReferred">[MQTT-4.3.3-5]</span>。</li><li><span class="vcMarked"><strong>必须不</strong>在发送 PUBREL 之后重发 PUBLISH 包</span> <span class="vcReferred">[MQTT-4.3.3-6]</span>。</li><li><span class="vcMarked"><strong>必须不</strong>在发送 PUBLISH 包之后使此应用消息过期</span> <span class="vcReferred">[MQTT-4.3.3-7]</span>。</li></ul><p>当发送者收到 PUBCOMP 包或原因码大于等于 0x80 的 PUBREC 包后，此包ID可被重用。</p><p>需要注意，发送者被允许在等待接收回复时发送更多带有不同包ID的 PUBLISH 包，关于流量控制的主题在 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.9</a> 中描述。</p><p><span class="vcMarked">在 QoS 2 交付协议中，接收方</span>：</p><ul><li><span class="vcMarked"><strong>必须</strong>使用和收到 PUBLISH 包相同的包ID的 PUBREC 包响应，拥有收到的消息的所有权</span> <span class="vcReferred">[MQTT-4.3.3-8]</span>。</li><li><span class="vcMarked">如果已经使用带有 0x80 或更大值的原因码的 PUBREC 包回复，接收方<strong>必须</strong>将后续带有相同包ID的 PUBLISH 包视为新应用消息</span> <span class="vcReferred">[MQTT-4.3.3-9]</span>。</li><li><span class="vcMarked">直到收到对应的 PUBREL 包为止，接收方<strong>必须</strong>使用 PUBREC 回复后续任何带有相同包ID的 PUBLISH 包。在此情形下<strong>必须不</strong>把重复的包转发给更进一步的消息使用者</span> <span class="vcReferred">[MQTT-4.3.3-10]</span>。</li><li><span class="vcMarked"><strong>必须</strong>使用和收到 PUBREL 包相同的包ID的 PUBCOMP 包响应 PUBREL 包</span> <span class="vcReferred">[MQTT-4.3.3-11]</span>。</li><li><span class="vcMarked">发送 PUBCOMP 包之后，接收方<strong>必须</strong>将后续带有相同包ID的 PUBLISH 包视为新应用消息</span> <span class="vcReferred">[MQTT-4.3.3-12]</span>。</li><li><span class="vcMarked">即使消息已经过期，也<strong>必须</strong>继续 QoS 2 的响应动作</span> <span class="vcReferred">[MQTT-4.3.3-13]</span>。</li></ul><h2 id="4-4-消息传递重试"><a href="#4-4-消息传递重试" class="headerlink" title="4.4 消息传递重试"></a>4.4 消息传递重试</h2><p><span class="vcMarked">当客户端使用全新开始值为 0 重连且存在会话时，客户端和服务器都<strong>必须</strong>使用原始的包ID重传所有未确认的 PUBLISH 包（其 QoS &gt; 0）和 PUBREL 包。这是客户端或服务器<strong>需要</strong>重传消息的唯一场景。客户端和服务器<strong>必须不</strong>在其他任何时间重传消息</span> <span class="vcReferred">[MQTT-4.4.0-1]</span>。</p><p><span class="vcMarked">如果接收到的 PUBACK 或 PUBREC 包含 0x80 或更大的原因代码，则相应的 PUBLISH 数据包将被视为已确认，且<strong>必须不</strong>被重传</span> <span class="vcReferred">[MQTT-4.4.0-2]</span>。</p><p>图 4.3 – QoS 2 协议流图，非规范性示例</p><table><thead><tr><th>发送方动作</th><th>数据包</th><th>接收方动作</th></tr></thead><tbody><tr><td>存储消息</td><td></td><td></td></tr><tr><td>发送 PUBLISH QoS 2，DUP&#x3D;0，&lt;包ID&gt;</td><td></td><td></td></tr><tr><td></td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>存储&lt;包ID&gt;，之后开始转发应用消息<sup>1</sup></td></tr><tr><td></td><td></td><td>PUBREC &lt;包ID&gt; &lt;原因码&gt;</td></tr><tr><td></td><td>&lt;———-</td><td></td></tr><tr><td>丢弃消息，存储收到的  PUBREC &lt;包ID&gt;</td><td></td><td></td></tr><tr><td>PUBREL &lt;包ID&gt;</td><td></td><td></td></tr><tr><td></td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>丢弃 &lt;包ID&gt;</td></tr><tr><td></td><td></td><td>发送 PUBCOMP &lt;包ID&gt;</td></tr><tr><td></td><td>&lt;———-</td><td></td></tr><tr><td>丢弃存储的状态</td><td></td><td></td></tr></tbody></table><p><sup>1</sup>接收方无需再发送 PUBREC 或 PUBCOMP 前完成消息交付。当原始的发送方收到 PUBREC 包时，应用消息的所有权转移给接收者。然而，接收者需要在接收所有权之前对所有可能导致转发失败的条件（例如限额、授权等）进行检查。接收者使用 PUBREC 中的原因码来表示接收成功或失败。</p><h2 id="4-5-消息接收"><a href="#4-5-消息接收" class="headerlink" title="4.5 消息接收"></a>4.5 消息接收</h2><p><span class="vcMarked">当服务器得到输入应用消息的所有权时，他<strong>必须</strong>把消息放入所有匹配订阅的客户端的会话状态</span> <span class="vcReferred">[MQTT-4.5.0-1]</span>。匹配规则在 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">4.7</a> 中定义。</p><p>在正常情况下，客户端会收到来自他已创建订阅中的消息。客户端还可能收到与他任何显式订阅不匹配的消息。这会在自动向客户端分配订阅时发生。客户端还可能在 UNSUBSCRIBE 包处理的过程中收到消息。<span class="vcMarked">无论何种情况，客户端<strong>必须</strong>按照匹配的 QoS 规则确认其收到包，无论客户端对包中的消息内容选择处理还是丢弃</span> <span class="vcReferred">[MQTT-4.5.0-2]</span>。</p><h2 id="4-6-消息顺序"><a href="#4-6-消息顺序" class="headerlink" title="4.6 消息顺序"></a>4.6 消息顺序</h2><p>在实现第 <a href="#4-3-QoS%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B">4.3</a> 中定义的协议流时，以下这些规则适用于客户端</p><ul><li><span class="vcMarked">当客户端重传 PUBLISH 包时，其必须按照原始 PUBLISH 包的顺序发送（包括 QoS 1 和 QoS 2 消息）</span> <span class="vcReferred">[MQTT-4.6.0-1]</span>。</li><li><span class="vcMarked">客户端<strong>必须</strong>按照接收 PUBLSIH 包的顺序发送 PUBACK 包（QoS 1 消息）</span> <span class="vcReferred">[MQTT-4.6.0-2]</span>。</li><li><span class="vcMarked">客户端<strong>必须</strong>按照接收 PUBLSIH 包的顺序发送 PUBREC 包（QoS 2 消息）</span> <span class="vcReferred">[MQTT-4.6.0-3]</span>。</li><li><span class="vcMarked">客户端<strong>必须</strong>按照接收 PUBREC 包的顺序发送 PUBREL 包（QoS 2 消息）</span> <span class="vcReferred">[MQTT-4.6.0-4]</span>。</li></ul><p>有序主题指的是客户端可以确定接收到该主题下的同一客户端发送的相同 QoS 的消息，其接收顺序和发送方的发送顺序是相同的。<span class="vcMarked">当服务器处理发布到有序主题的消息时，服务器<strong>必须</strong>保证其对消费者发送的 PUBLISH 包（对于相同主题和相同 QoS）的顺序和服务器从客户端接收这些包时相同</span> <span class="vcReferred">[MQTT-4.6.0-5]</span>。这是对上面列出规则的补充。</p><p><span class="vcMarked">默认情况下，服务器在转发非共享订阅上的消息时<strong>必须</strong>将每个主题视为有序主题。</span> <span class="vcReferred">[MQTT-4.6.0-6]</span>。 服务器<strong>可以</strong>提供管理或其他机制，以允许一个或多个主题不被视为有序主题。</p><p><em>非规范性评论</em></p><p><em>上面列出的规则确保当消息流发布到 QoS 1 的有序主题，订阅者收到的每条消息的副本最终将按照它们发布的顺序排列。如果重传，则可能先收到早已收到的重复消息。例如，发布者可能会按照 1，2，3，4 的顺序发送消息，但如果发送消息 3 后出现网络断开，订阅者可能会按照 1，2，3，2，3，4 的顺序接收消息 。</em></p><p><em>如果客户端和服务器都将接收最大值设置为 1，则它们会确保在任何时间 “正在发送” 的消息不超过一条。在这种情况下，即使在重新连接时，也不会在收到后发出的消息后重复收到先前的消息。例如，订户可能会按 1，2，3，3，4 的顺序接收它们，但不会按 1，2，3，2，3，4 的顺序接收它们。有关如何使用接收最大值的详细信息，请参考 <a href="#4-9-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.9</a> 流量控制。</em></p><h2 id="4-7-主题名和主题过滤器"><a href="#4-7-主题名和主题过滤器" class="headerlink" title="4.7 主题名和主题过滤器"></a>4.7 主题名和主题过滤器</h2><h3 id="4-7-1-主题通配符"><a href="#4-7-1-主题通配符" class="headerlink" title="4.7.1 主题通配符"></a>4.7.1 主题通配符</h3><p>主题级别分隔符用于结构化的主题名称。当使用主题级别分隔符时，他将主题名称分为多个 “主题级别”。</p><p>订阅用的主题过滤器可以包含特殊的通配符，这允许客户端一次订阅多个主题。</p><p><span class="vcMarked">通配符可以在主题过滤器中使用，但<strong>必须不</strong>在主题名称中使用</span> <span class="vcReferred">[MQTT-4.7.0-1]</span>。</p><h4 id="4-7-1-1-主题级别分隔符"><a href="#4-7-1-1-主题级别分隔符" class="headerlink" title="4.7.1.1 主题级别分隔符"></a>4.7.1.1 主题级别分隔符</h4><p>正斜杠（’&#x2F;‘ U+002F）用于在主题树中区分各个层级，且提供一个具有层级结构的主题名称。当订阅客户端在主题过滤器中使用了通配符时，主题级别分隔符十分重要。主题级别分隔符可以出现在主题过滤器或主题名称中的任何位置。响铃到主题级别分隔符表示零长度主题级别。</p><h4 id="4-7-1-2-多级通配符"><a href="#4-7-1-2-多级通配符" class="headerlink" title="4.7.1.2 多级通配符"></a>4.7.1.2 多级通配符</h4><p>井号（’#’ U+0023）是在主题中匹配任意数量层级的通配符。多级通配符可以表示父级和任意数量的子级。<span class="vcMarked">多级通配符<strong>必须</strong>单独使用或在主题级别分隔符后使用。在任意情况下他都<strong>必须</strong>是主题过滤器中的最后一个字符</span> <span class="vcReferred">[MQTT-4.7.1-1]</span>。</p><p><em>非规范性评论</em></p><p><em>例如，当客户端订阅了 “sport&#x2F;tennis&#x2F;player1&#x2F;#”，他将会收到下列主题中的消息：</em></p><ul><li><em>sport&#x2F;tennis&#x2F;player1</em></li><li><em>sport&#x2F;tennis&#x2F;player1&#x2F;ranking</em></li><li><em>sport&#x2F;tennis&#x2F;player1&#x2F;score&#x2F;wimbledon</em></li></ul><p><em>非规范性评论</em></p><ul><li><em>“sport&#x2F;#” 可以匹配到 “sport”，因为 # 的匹配包括父级。</em></li><li><em>“#” 是合法的，将会接收到所有的消息。</em></li><li><em>“sport&#x2F;tennis&#x2F;#” 是合法的</em></li><li><em>“sport&#x2F;tennis#” 是非法的</em></li><li><em>“sport&#x2F;tennis&#x2F;#&#x2F;ranking” 是非法的</em></li></ul><h4 id="4-7-1-3-单级通配符"><a href="#4-7-1-3-单级通配符" class="headerlink" title="4.7.1.3 单级通配符"></a>4.7.1.3 单级通配符</h4><p>加号（’+’ U+002B）实在主题中匹配单个层级的通配符。</p><p>单级通配符可以被用在主题过滤器中的任意层级，包括第一层和最后一层。<span class="vcMarked">当他被使用时，他<strong>必须</strong>占据过滤器中一个完整的级别</span> <span class="vcReferred">[MQTT-4.7.1-2]</span>。他可以在主题过滤器中的多个层级使用，也可以结合多级通配符共同使用。</p><p><em>非规范性评论</em></p><p><em>例如，“sport&#x2F;tennis&#x2F;+” 可以匹配 “sport&#x2F;tennis&#x2F;player1” 和 “sport&#x2F;tennis&#x2F;player2”，但是不能匹配 “sport&#x2F;tennis&#x2F;player1&#x2F;ranking”。同样，由于单级通配符只能匹配一个层级，“sport&#x2F;+” 无法匹配 “sport”，但可以匹配 “sport&#x2F;”。</em></p><ul><li><em>“+” 是合法的。</em></li><li><em>“+&#x2F;tennis&#x2F;#” 是合法的。</em></li><li><em>“sport+” 是非法的。</em></li><li><em>“sport&#x2F;+&#x2F;player1” 是合法的。</em></li><li><em>“&#x2F;finance” 可以被 “+&#x2F;+” 和 “&#x2F;+” 匹配，但不能被 “+” 匹配。</em></li></ul><h3 id="4-7-2-开头的主题"><a href="#4-7-2-开头的主题" class="headerlink" title="4.7.2 $开头的主题"></a>4.7.2 $开头的主题</h3><p><span class="vcMarked">服务器<strong>必须不</strong>将以通配符（# 或 +）开始的主题过滤器与以 $ 开头的主题名匹配</span> <span class="vcReferred">[MQTT-4.7.2-1]</span>。服务器<strong>应该</strong>防止客户端使用此类主题名称与其他客户端交换信息。服务器实现<strong>可以</strong>将 $ 开头的主题名称用于其他目的。</p><p><em>非规范性评论</em></p><ul><li><em>$SYS&#x2F; 已被广泛采用作为包含服务器特定信息或控制 API 的主题的前缀</em></li><li><em>应用程序不得将 $ 开头的主题用于私有目的</em></li></ul><p><em>非规范性评论</em></p><ul><li><em>订阅 “#” 不会收到任何 $ 开头主题的消息。</em></li><li><em>订阅 “+&#x2F;monitor&#x2F;Clients” 不会收到任何 “$SYS&#x2F;monitor&#x2F;Clients” 主题的消息。</em></li><li><em>订阅 “$SYS&#x2F;#” 会收到所有以 “$SYS&#x2F;” 开头的消息。</em></li><li><em>订阅 “$SYS&#x2F;monitor&#x2F;+” 会收到 “$SYS&#x2F;monitor&#x2F;Clients” 主题的消息。</em></li><li><em>如果客户端想要接收所有 $SYS&#x2F; 开头的消息和所有其他非 $ 开头的消息，他需要同时订阅 “#” 和 “$SYS&#x2F;#”。</em></li></ul><h3 id="4-7-3-主题语义和使用"><a href="#4-7-3-主题语义和使用" class="headerlink" title="4.7.3 主题语义和使用"></a>4.7.3 主题语义和使用</h3><p>下列规则适用于主题名称和主题过滤器：</p><ul><li><span class="vcMarked">所有的主题名称和主题过滤器<strong>必须</strong>至少包含一个字符</span> <span class="vcReferred">[MQTT-4.7.3-1]</span></li><li>主题名称和主题过滤器大小写敏感</li><li>主题名称和主题过滤器可以包含空格</li><li>添加前导的 ‘&#x2F;‘ 或结尾的 ‘&#x2F;‘ 会创建不同的主题名称或主题过滤器</li><li>只有 ‘&#x2F;‘ 字符的主题名称或主题过滤器是合法的</li><li><span class="vcMarked">主题名称和主题过滤器中必须不能包括 null 字符（Unicode U+0000）</span> <a href="#1.3-Unicode">Unicode</a> <span class="vcReferred">[MQTT-4.7.3-2]</span></li><li><span class="vcMarked">主题名称和主题过滤器是 <code>UTF-8字符串</code>；<strong>必须不</strong>超过 65535 字节</span> <span class="vcReferred">[MQTT-4.7.3-3]</span>。参考 <a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a></li></ul><p>主题名称和主题过滤器的层级数没有限制，换句话说其受到 <code>UTF-8字符串</code> 的限制。</p><p><span class="vcMarked">当进行订阅匹配时，服务器<strong>必须不</strong>对主题名称或主题过滤器执行任何标准化处理，或对无法识别的字符进行任何修改或替换</span> <span class="vcReferred">[MQTT-4.7.3-4]</span>。主题过滤器中的每个非通配符级别必须与主题名称中的相应级别逐个匹配，匹配才能成功。</p><p><em>非规范性评论</em></p><p><em>UTF-8 编码规则意味着主题过滤器和主题名称的比较可以通过比较编码的 UTF-8 字节来执行，或是通过比较解码的 Unicode 字符来执行。</em></p><p><em>非规范性评论</em></p><ul><li><em>“ACCOUNTS” 和 “Accounts” 是两个不同的主题名称</em></li><li><em>“Accounts payable” 是合法的主题名称</em></li><li><em>“&#x2F;finance” 和 “finance” 是不同的主题名称</em></li></ul><p>应用消息会发送到客户端订阅的主题过滤器与该消息发送的主题名称匹配的所有客户端。主题资源<strong>可以</strong>有管理员在服务器中预定义，也<strong>可以</strong>被服务器自动创建，当服务器第一次收到关于该主题的订阅或收到发往该主题的应用消息时。服务器也<strong>可以</strong>使用安全组件来授权某客户端对主题资源进行特定操作。</p><h2 id="4-8-订阅"><a href="#4-8-订阅" class="headerlink" title="4.8 订阅"></a>4.8 订阅</h2><p>MQTT 提供了两种订阅，共享订阅和非共享订阅。</p><p><em>非规范性评论</em></p><p><em>在较早版本的 MQTT 中，所有的订阅都是非共享订阅。</em></p><h3 id="4-8-1-非共享订阅"><a href="#4-8-1-非共享订阅" class="headerlink" title="4.8.1 非共享订阅"></a>4.8.1 非共享订阅</h3><p>非共享订阅仅与创建他的 MQTT 会话关联。每个订阅包含一个主题过滤器，决定了拿些主题的消息会被转发到此会话，还包括订阅选项。服务器负责收集匹配过滤器的消息，并在 MQTT 连接可用时将这些消息转发到此会话的 MQTT 连接。</p><p>一个会话不能对同主题名持有超过一个的非共享订阅，所以在会话中可以将主题过滤器用作区分订阅的键。</p><p>如果有多个客户端，都对相同的主题各自进行非共享订阅，每个客户端都会从主题中获得自己的应用消息副本。这意味着非共享订阅不能用于跨客户端之间的应用消息负载均衡，因为每个消息都会被发到所有的订阅客户端。</p><h3 id="4-8-2-共享订阅"><a href="#4-8-2-共享订阅" class="headerlink" title="4.8.2 共享订阅"></a>4.8.2 共享订阅</h3><p>共享订阅可以与多个订阅 MQTT 会话关联。与非共享订阅一样，持有主题过滤器和订阅选项；然而，发布到其主题过滤器的消息仅被转发到其中之一的订阅会话。当多个消费者客户端并发进行消息处理时，共享订阅非常有用。</p><p>共享订阅是用一种特殊格式的主题过滤器实现的。该过滤器的格式是：</p><p>$share&#x2F;{ShareName}&#x2F;{filter}</p><ul><li>$share 是小写字符串，表示此主题过滤器是一个共享订阅主题过滤器。</li><li>{ShareName} 是不包括 ‘&#x2F;‘ ‘+’ ‘#’ 的字符串</li><li>{filter} 字符串的剩余部分的格式和语义与非共享订阅中的主题过滤器相同。参考 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">4.7</a>。</li></ul><p><span class="vcMarked">共享订阅的主题过滤器<strong>必须</strong>以 $share&#x2F; 开始且<strong>必须</strong>包括至少一字符的共享名称</span> <span class="vcReferred">[MQTT-4.8.2-1]</span>。<span class="vcMarked">共享名称<strong>必须不</strong>包含字符 ‘&#x2F;‘、’+’、’#’，但<strong>必须</strong>在其后跟随 ‘&#x2F;‘ 字符。此 ‘&#x2F;‘ 字符后<strong>必须</strong>跟随主题过滤器</span> <span class="vcReferred">[MQTT-4.8.2-2]</span>，主题过滤器的描述参考 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">4.7</a>。</p><p><em>非规范性评论</em></p><p><em>共享订阅在 MQTT 服务器范围内定义，而非在会话内定义。共享名称包含在共享订阅的主题过滤器中，因此一台服务器上可以有多个具有相同 {filter} 的不同共享订阅。通常来说，应用程序使用共享名称表示共享订阅的会话组。</em></p><p><em>例子：</em></p><ul><li><em>共享订阅 “$share&#x2F;consumer1&#x2F;sport&#x2F;tennis&#x2F;+” 和 “$share&#x2F;consumer2&#x2F;sport&#x2F;tennis&#x2F;+” 是不同的共享订阅，他们可以被关联到不同的会话组。这两个订阅都可以匹配到与非共享订阅 “sport&#x2F;tennis&#x2F;+” 相同的内容。</em></li></ul><p><em>如果有消息被发布到 “sport&#x2F;tennis&#x2F;+”，那么会有一个消息副本被发送至 “$share&#x2F;consumer1&#x2F;sport&#x2F;tennis&#x2F;+”，还会有一个消息副本被发送至 “$share&#x2F;consumer2&#x2F;sport&#x2F;tennis&#x2F;+”，另外还会有更多的消息副本被发往使用非共享订阅 “sport&#x2F;tennis&#x2F;+” 的客户端。</em></p><ul><li><em>共享订阅 “$share&#x2F;consumer1&#x2F;&#x2F;finance” 和非共享订阅 “&#x2F;finance” 匹配相同的主题。</em></li></ul><p><em>需要注意 “$share&#x2F;consumer1&#x2F;&#x2F;finance” 和 “$share&#x2F;consumer1&#x2F;sport&#x2F;tennis&#x2F;+” 是不同的共享订阅，虽然他们有相同的共享名称。虽然它们可能以某种方式相关，但它们具有相同的共享名并不意味着它们之间存在特定关系。</em></p><p>共享订阅通过在 SUBSCRIBE 中使用共享订阅主题过滤器创建。当只有一个会话使用某个共享订阅时，共享订阅的行为就像非共享订阅一样，不同之处在于：</p><ul><li>当与发布消息进行匹配时，不会考虑 $share 和 {ShareName} 部分的内容。</li><li>当订阅初次建立时不会有保留消息被发送至会话。保留消息会在其发布时像其他匹配消息一样被发送到会话。</li></ul><p>一旦共享订阅存在，其他会话都可以使用同样的共享订阅主题过滤器加入订阅。新的会话将成为此共享订阅新关联的订阅者。保留消息不会发送给新的订阅者。之后每个匹配共享订阅的应用消息都会发给共享订阅的订阅者中的有且仅有一个的某个会话。</p><p>会话可以通过发送包含完整共享订阅主题过滤器的 UNSUBSCRIBE 包来显式的退出共享订阅。当会话终止时也会退出共享订阅。</p><p>共享订阅只要与至少一个会话关联（即已向其主题过滤器发出成功的订阅请求但尚未完成相应的取消订阅的会话），就会持续存在。当最初创建共享订阅的会话取消订阅时，共享订阅将继续存在，除非其取消时共享订阅中已经没有其他的会话。当不再有任何会话订阅共享订阅时，共享订阅就会结束，并且与其关联的任何未传递的消息都将被删除。</p><p>共享订阅注意事项</p><ul><li>如果有超过一个会话加入了共享订阅，服务器实现在每一条消息上都有自由选择使用哪个会话，并有自由制定选择会话的标准。</li><li>不同的订阅客户端可以在其 SUBSCRIBE 中请求不同的 QoS 等级。服务器可以决定向每个客户端授权的最大 QoS 等级，而且服务器被允许向不同的订阅者授予不同的 QoS 等级。当向客户端发送应用消息时，<span class="vcMarked">服务器<strong>必须</strong>遵守客户端订阅时授予的 QoS 等级</span> <span class="vcReferred">[MQTT-4.8.2-3]</span>，就像服务器向订阅者发布消息一样。</li><li>如果服务器正在向其选择的客户端发送 QoS 2 消息，而客户端的连接在消息完成前断开了，<span class="vcMarked">服务器<strong>必须</strong>在客户端重新连接时完成该消息的交付</span> <span class="vcReferred">[MQTT-4.8.2-4]</span>，如同 <a href="#4-3-3-Qos-2%EF%BC%9A%E7%A1%AE%E4%BF%9D%E4%B8%80%E6%AC%A1">4.3.3</a> 中的描述。<span class="vcMarked">如果该客户端的会话在其重连成功前终止了，服务器<strong>必须不</strong>将此应用消息发送给其他的订阅客户端</span> <span class="vcReferred">[MQTT-4.8.2-5]</span>。</li><li>如果服务器正在向其选择的客户端发送 QoS 1 消息，而在收到回复前客户端的连接中止了，服务器<strong>可以</strong>等待客户端重连之后重传消息给客户端。如果该客户端的会话在其重连成功前终止了，服务器<strong>应该</strong>将此应用消息发给此共享订阅中的其他客户端。一旦失去与第一个客户端的连接，服务器就<strong>可以</strong>尝试将消息发送到另一个客户端。</li><li><span class="vcMarked">如果客户端使用带有 0x80 或更大原因码的 PUBACK 或 PUBREC 响应来自服务器的 PUBLISH 包，服务器<strong>必须</strong>丢弃应用消息，并且不再尝试将消息发给其他订阅者</span> <span class="vcReferred">[MQTT-4.8.2-6]</span>。</li><li>客户端被允许在同一个会话上已经存在共享订阅的情况下向此共享订阅发送第二个 SUBSCRIBE 请求。例如，客户端这样做也许是为了修改订阅请求的 QoS 或是由于客户端不确定上一次连接断开前是否已经完成了订阅。这个操作不会增加会话与共享订阅的关联次数，因此只需发送一个 UNSUBSCRIBE 包会话即可离开共享订阅。</li><li>每个共享订阅都独立于其他共享订阅。可以有两个过滤器一致的共享订阅。在这种情况下，消息会同时匹配到两个共享订阅并且由他们各自处理。如果客户端同时使用了共享订阅和非共享订阅，且消息和两个订阅都匹配，客户端会因为非共享订阅收到消息的副本。消息的第二个副本会被交付到共享订阅中的其中一个订阅者，这可能会导致此客户端收到两份消息的副本。</li></ul><h2 id="4-9-流量控制"><a href="#4-9-流量控制" class="headerlink" title="4.9 流量控制"></a>4.9 流量控制</h2><p>客户端和服务器通过使用 <a href="#3-1-2-11-3-%E6%8E%A5%E6%94%B6%E6%9C%80%E5%A4%A7%E5%80%BC">3.1.2.11.3</a> 和 <a href="#3-2-2-3-3-%E6%8E%A5%E6%94%B6%E6%9C%80%E5%A4%A7%E5%80%BC">3.2.2.3.3</a> 中描述的接受最大值来控制其接收并未处理的 PUBLISH 包的数量。接受最大值创建了一个限制消息的发送配额，用来限制 QOS &gt; 0 的 PUBLISH 包，可以是未收到 PUBACK （针对 QoS 1）或未收到 PUBCOMP（针对 QoS 2）的 PUBLISH 包。PUBACK 和 PUBCOMP 会按照下述方式补充配额。</p><p><span class="vcMarked">客户端或服务器<strong>必须</strong>将其发送配额初始化为不超过接收最大值的非零值</span> <span class="vcReferred">[MQTT-4.9.0-1]</span>。</p><p><span class="vcMarked">每当客户端或服务器发送 QoS &gt; 0 的 PUBLISH 包，降低配额。如果发送配额值达到 0，客户端或服务器<strong>必须不</strong>再发送任何 QoS &gt; 0 的 PUBLISH 包</span> <span class="vcReferred">[MQTT-4.9.0-2]</span>。他<strong>可以</strong>继续发送 QoS 值为 0 的 PUBLISH 包，或是<strong>可以</strong>选择同样暂停发送这些包。<span class="vcMarked">即使配额值为 0，客户端和服务器<strong>必须</strong>继续处理和响应其他类型的 MQTT 包</span> <span class="vcReferred">[MQTT-4.9.0-3]</span>。</p><p>发送配额加 1：</p><ul><li>每当收到 PUBACK 包或 PUBCOMP 包，无论 PUBACK 包或 PUBCOMP 包是否携带错误码。</li><li>每当收到带有原因码大于等于 0x80 的 PUBREC 包。</li></ul><p>如果发送配额已等于初始发送配额，则不会增加。尝试增加超过初始发送配额可能是由于建立新的网络连接后重新传输 PUBREL 数据包造成的。</p><p>参考 <a href="#3-3-4-PUBLISH%E5%8A%A8%E4%BD%9C">3.3.4</a> 的描述了解当客户端或服务器发送的 PUBLISH 包超过被允许的接受最大值后会如果反应。</p><p>发送配额和接受最大值不会跨网络连接保留，而是如上文所述在每个新的网络连接中重新初始化。他们不是会话状态的一部分。</p><h2 id="4-10-请求-响应"><a href="#4-10-请求-响应" class="headerlink" title="4.10 请求 &#x2F; 响应"></a>4.10 请求 &#x2F; 响应</h2><p>有些应用程序或是标准可能希望通过 MQTT 实现请求&#x2F;响应式的交互。此版本的 MQTT 包括了四个可以用于实现此目的的属性：</p><ul><li>响应主题，参考 <a href="#3-3-2-3-5-%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98">3.3.2.3.5</a></li><li>关联数据，参考 <a href="#3-3-2-3-6-%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE">3.3.2.3.6</a></li><li>请求响应信息，参考 <a href="#3-1-2-11-6-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF">3.1.2.11.6</a></li><li>响应信息，参考 <a href="#3-2-2-3-15-%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF">3.2.2.3.15</a></li></ul><p>随后的非规范性章节描述了如何使用这些属性。</p><p>客户端通过发送带有 <a href="#3-3-2-3-5-%E5%93%8D%E5%BA%94%E4%B8%BB%E9%A2%98">3.3.2.3.5</a> 中描述的响应主题的应用消息来发送请求。请求中可以包括在 <a href="#3-3-2-3-6-%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE">3.3.2.3.6</a> 中描述的关联数据。</p><h3 id="4-10-1-基础请求响应（非规范性）"><a href="#4-10-1-基础请求响应（非规范性）" class="headerlink" title="4.10.1 基础请求响应（非规范性）"></a>4.10.1 基础请求响应（非规范性）</h3><p>请求&#x2F;响应交互过程如下：</p><ol><li>一个 MQTT 客户端（请求方）向主题发送请求信息。请求信息指带有响应主题的应用消息。</li><li>另一个 MQTT 客户端（响应方）已经订阅了请求方发布时所用的主题，因此收到了请求消息。可能会有多个响应方订阅了此主题，也可能没有。</li><li>响应方根据请求消息采取适当的操作，然后向请求消息中携带的响应主题中的主题名称发布响应消息。</li><li>在通常用法中，请求者已经订阅了响应主题，从而接收响应消息。然而，其他客户端可能也订阅了响应主题，因此响应消息也会由这些客户端接收和处理。与请求消息一样，响应消息的主题可以被多个客户端订阅，也可能没有客户端订阅。</li></ol><p>如果请求消息包含关联数据，响应方会在响应信息中复制此数据，这些数据被响应消息的接收方用来将响应消息和原始请求进行关联。响应消息不包括响应主题属性。</p><p>如果请求消息包含关联数据属性，则响应方将此属性复制到响应消息中，并且响应消息的接收方使用该属性将响应消息与原始请求关联起来。 响应消息不包括响应主题属性。</p><p>MQTT 服务器转发请求消息中的响应主题和关联数据，以及响应消息中的关联数据。服务器将请求消息和响应消息当作其他应用消息一样对待。</p><p>请求方往往在发布请求消息之前就订阅响应主题。如果当响应消息发布时响应主题没有订阅者，响应消息将不会被交付到任何客户端。</p><p>请求消息和响应消息可以使用任意等级的 QoS，且响应方可以使用一个会话过期间隔非 0 的会话。通常来说会先确认响应方在线，然后使用 QoS 0 等级发送请求消息。当然，这不是必须的。</p><p>响应方可以使用共享订阅来创建响应客户端池。但请主题，使用共享订阅时，消息在多个客户端之间的交付顺序是无法保证的。</p><p>请求者有责任确保其具有发布请求主题以及订阅其设置的响应主题的必要权限。响应者有责任确保其有订阅请求主题和发布到响应主题的权限。虽然主题授权不在本规范范围内，但建议服务器实现此类授权。</p><h3 id="4-10-2-确定响应主题的值（非规范性）"><a href="#4-10-2-确定响应主题的值（非规范性）" class="headerlink" title="4.10.2 确定响应主题的值（非规范性）"></a>4.10.2 确定响应主题的值（非规范性）</h3><p>请求方可以使用任何方式（包括本地配置）确定响应主题的主题名称。为了避免不同请求方之间的冲突，最好能确保请求方使用的响应主题对于该客户端来说是唯一的。由于请求方和响应方通常需要获得这些主题的授权，使用随机主题名称对于授权来说可能是个挑战。</p><p>为了帮助解决这个问题，本规范在 CONNACK 数据包中定义了一个称为响应信息的属性。服务器可以使用此属性来指导客户端选择要使用的响应主题。该机制对于客户端和服务器都是可选的。在连接时，客户端通过设置 CONNECT 数据包中的请求响应信息属性来请求服务器发送响应信息。之后服务器会在 CONNACK 数据包中发送响应信息属性（格式为 <code>UTF-8字符串</code>）。</p><p>本规范没有定义响应信息的内容，但它可用于传递主题树的全局唯一部分，该部分至少在其会话的生命周期内为该客户端保留。使用此机制允许此配置在服务器中完成一次，而不是在每个客户端中完成。</p><p>参考 <a href="#3-1-2-11-6-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF">3.1.2.11.6</a> 了解关于响应信息的定义。</p><h2 id="4-11-服务重定向"><a href="#4-11-服务重定向" class="headerlink" title="4.11 服务重定向"></a>4.11 服务重定向</h2><p>服务器可以通过发送带有原因码 0x9C（使用另一台服务器）或 0x9D（服务器迁移）的 CONNACK 包或 DISCONNECT 包通知客户端使用另一台服务器，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中的描述。当发送这类的原因码时，服务器<strong>可以</strong>包括服务引用属性，用来携带客户端<strong>应该</strong>使用的服务器地址。</p><p>原因码 0x9C（使用另一台服务器）表示客户端<strong>应该</strong>临时性的切换到另一台服务器。另一台服务器要么是客户端已知的，要么是写在服务引用中。</p><p>原因码 0x9D（服务器迁移）表示客户端<strong>应该</strong>永久性的切换到另一台服务器。另一台服务器要么是客户端已知的，要么是写在服务引用中。</p><p>服务引用是 <code>UTF-8字符串</code>。其值是空格分隔引用列表。引用的格式不在此处规范。</p><p><em>非规范性评论</em></p><p><em>建议每个引用都包含一个名称，其后可选的包含冒号和端口号。如果名称包含冒号，则名称字符串可以括在方括号内（’[‘和’]‘）。方括号括起来的名称不能包含右方括号 (‘]‘) 字符。这用于表示使用冒号分隔符的 IPv6 文字地址。 这是 <a href="#1.4-RFC3986">RFC3986</a> 中描述的 URI 授权的简化版本。</em></p><p><em>非规范性评论</em></p><p><em>服务引用中的名称通常表示主机名、DNS 名称 <a href="#1.4-RFC1035">RFC1035</a>、SRV 名称 <a href="#1.4-RFC2782">RFC2782</a> 或文字 IP 地址。冒号分隔符后面的值通常是十进制的端口号。如果端口信息来自名称解析（例如使用 SRV）或者是默认的，无需携带端口号。</em></p><p><em>非规范性评论</em></p><p><em>如果提供多个服务引用，则期望客户选择其中之一。</em></p><p><em>非规范性评论</em></p><p><em>服务引用的例子：</em></p><p><em>myserver.xyz.org</em></p><p><em>myserver.xyz.org:8883</em></p><p><em>10.10.151.22:8883 [fe80::9610:3eff:fe1c]:1883</em></p><h2 id="4-12-增强认证"><a href="#4-12-增强认证" class="headerlink" title="4.12 增强认证"></a>4.12 增强认证</h2><p>MQTT CONNECT 包支持使用用户名和密码字段对网络连接进行基本身份验证。虽然这些字段是为简单的密码身份验证而命名的，但它们可用于携带其他形式的身份验证，例如传递 token。</p><p>增强认证扩展了这种基础的认证方式，添加了挑战&#x2F;响应式的认证。他可能涉及在 CONNECT 后， CONNACK 前，在客户端和服务器之间交换 AUTH 数据包。</p><p>为了开始增强认证，客户端需要在 CONNECT 包属性集中携带认证方式属性。他选择了需要使用的认证方式。<span class="vcMarked">如果服务器不支持客户端提供的认证方式，服务器<strong>可以</strong>发送带有原因码 0x8C（认证方式错误）或原因码 0x87（未经授权）的 CONNACK 包，并<strong>必须</strong>关闭网络连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中的描述</span> <span class="vcReferred">[MQTT-4.12.0-1]</span>。</p><p>认证方法是客户端和服务器之间就 CONNECT 数据包中的认证数据和其他字段的含义、以及完成认证所需的客户端和服务器交换和处理达成的协议。</p><p><em>非规范性评论</em></p><p><em>通常情况下，认证方法采用 SASL 机制，使用注册名称有助于相互交流。但是，认证方法并不局限于使用注册的 SASL 机制。</em></p><p>如果客户端选择的认证方法规定客户端先发送数据，则客户端应在 CONNECT 数据包中包含认证数据属性。该属性可用于根据认证方法提供数据。认证数据的内容由认证方法定义。</p><p><span class="vcMarked">如果服务器需要额外信息来完成认证，他可以向客户端发送一个 AUTH 数据包。此数据包<strong>必须</strong>包含原因码 0x18（继续认证）</span> <span class="vcReferred">[MQTT-4.12.0-2]</span>。如果认证方法要求服务器向客户端发送认证数据，则会在认证数据属性中发送。</p><p><span class="vcMarked">客户端通过发送另一个 AUTH 包来响应来自服务器的 AUTH 包。此包必须包含原因码 0x18（继续认证）</span> <span class="vcReferred">[MQTT-4.12.0-3]</span>。如果认证方法要求客户端向服务器发送认证数据，则会在认证数据属性中发送。</p><p>客户端和服务器会根据需要交换 AUTH 数据包，直到服务器通过发送原因码为 0 的 CONNACK 包接受认证。如果接受认证需要向客户端发送数据，则会在认证数据属性中发送。</p><p>客户端可以在认证过程中的任何时候关闭连接。他<strong>可以</strong>在此之前发送一个 DISCONNECT 数据包。<span class="vcMarked">服务器可以在认证过程的任何点拒绝认证。他<strong>可以</strong>根据 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 的描述发送一个原因码为 0x80 或以上的 CONNACK 数据包，并<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-4.12.0-4]</span>。</p><p><span class="vcMarked">如果初始 CONNECT 包包含认证方法，则所有 AUTH 包和任何成功的 CONNACK 包都必须包含和 CONNECT 包中相同值的 认证方法</span> <span class="vcReferred">[MQTT-4.12.0-5]</span>。</p><p>增强认证的实现对于客户端和服务器都是<strong>可选</strong>的。<span class="vcMarked">如果客户端没有在 CONNECT 包中包含认证方法，则服务器<strong>必须不</strong>发送 AUTH 包，也<strong>必须不</strong>在 CONNACK 包中包含认证方法</span> <span class="vcReferred">[MQTT-4.12.0-6]</span>。<span class="vcMarked">如果客户端没有在 CONNECT 包中包含认证方法，则客户端<strong>必须不</strong>向服务器发送 AUTH 包</span> <span class="vcReferred">[MQTT-4.12.0-7]</span>。</p><p>如果客户端没有在 CONNECT 包中包含认证方法属性，服务器<strong>应该</strong>使用 CONNECT 数据包、TLS 会话和网络连接中的一些或所有信息进行认证。</p><p><em>SCRAM挑战的非规范性示例</em></p><ul><li><em>客户端到服务器：CONNECT Authentication Method&#x3D;”SCRAM-SHA-1” Authentication Data&#x3D;client-first-data</em></li><li><em>服务器到客户端：AUTH rc&#x3D;0x18 Authentication Method&#x3D;”SCRAM-SHA-1” Authentication Data&#x3D;server-first-data</em></li><li><em>客户端到服务器：AUTH rc&#x3D;0x18 Authentication Method&#x3D;”SCRAM-SHA-1” Authentication Data&#x3D;client-final-data</em></li><li><em>服务器到客户端：CONNACK rc&#x3D;0 Authentication Method&#x3D;”SCRAM-SHA-1” Authentication Data&#x3D;server-final-data</em><br>Non-normative example showing a SCRAM challenge</li></ul><p><em>Kerberos挑战的非规范性示例</em> </p><ul><li><em>客户端到服务器：CONNECT Authentication Method&#x3D;”GS2-KRB5</em></li><li><em>服务器到客户端：AUTH rc&#x3D;0x18 Authentication Method&#x3D;”GS2-KRB5</em></li><li><em>客户端到服务器：AUTH rc&#x3D;0x18 Authentication Method&#x3D;”GS2-KRB5” Authentication Data&#x3D;initial context token</em></li><li><em>服务器到客户端：AUTH rc&#x3D;0x18 Authentication Method&#x3D;”GS2-KRB5” Authentication Data&#x3D;reply context token</em></li><li><em>客户端到服务器：AUTH rc&#x3D;0x18 Authentication Method&#x3D;”GS2-KRB5</em></li><li><em>服务器到客户端：CONNACK rc&#x3D;0 Authentication Method&#x3D;”GS2-KRB5” Authentication Data&#x3D;outcome of authentication</em></li></ul><h3 id="4-12-1-重新认证"><a href="#4-12-1-重新认证" class="headerlink" title="4.12.1 重新认证"></a>4.12.1 重新认证</h3><p><span class="vcMarked">如果客户端在 CONNECT 包中提供了认证方法，则可以在收到 CONNACK 后随时启动重新认证。通过发送原因码为 0x19（重新认证）的 AUTH 包来实现。客户端<strong>必须</strong>将认证方法设置为与最初用于认证网络连接的认证方法相同的值</span> <span class="vcReferred">[MQTT-4.12.1-1]</span>。如果认证方法要求客户端先发送数据，则此 AUTH 数据包通过认证数据属性携带第一份数据。</p><p>服务器通过发送原因码为 0x00（成功）的 AUTH 包来响应此重新认证请求，表示重新认证已完成，或原因码为 0x18（继续认证）来表示需要更多认证数据。客户端可以通过发送原因码为 0x18（继续认证）的 AUTH 数据包来响应并提供额外的认证数据。此流程像初始认证一样继续进行，直到重新认证完成或重新认证失败。</p><p><span class="vcMarked">如果重新认证失败，客户端或服务器<strong>应该</strong>带有合适原因码的 DISCONNECT 包，且<strong>必须</strong>断开网络连接，参考 <a href="#4-13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">4.13</a> 中的描述</span> <span class="vcReferred">[MQTT-4.12.1-2]</span>。</p><p>在重新认证过程中，客户端和服务器之间的其他数据包流可以继续使用之前的认证方式。</p><p><em>非规范性评论</em></p><p><em>服务器可能会通过拒绝重新认证来限制客户端在重新认证中可以尝试的更改范围。例如，如果服务器不允许更改用户名，它可以拒绝任何更改用户名的重新认证尝试。</em></p><h2 id="4-13-错误处理"><a href="#4-13-错误处理" class="headerlink" title="4.13 错误处理"></a>4.13 错误处理</h2><h3 id="4-13-1-格式错误的包和协议错误"><a href="#4-13-1-格式错误的包和协议错误" class="headerlink" title="4.13.1 格式错误的包和协议错误"></a>4.13.1 格式错误的包和协议错误</h3><p>格式错误的包和协议错误的定义包含在 <a href="#1-2-%E6%9C%AF%E8%AF%AD%E8%A1%A8">1.2</a> 术语表中，一些，但不是全部的此类错误在整个规范中都有著名。客户端或服务器检查收到 MQTT 包的严格程度是下列各项的折中：</p><ul><li>客户端或服务器的实现规模。</li><li>实现所支持的功能。</li><li>接收方信任发送方发送正确 MQTT 包的程度。</li><li>接收方信任网络正确传递 MQTT 包的程度。</li><li>继续处理错误包带来的后果。</li></ul><p>如果发送方符合此规范，他将不会发送格式错误的包或造成协议错误。然而，如果客户端在收到 CONNACK 前发送 MQTT 包，可能会导致协议错误因为他可能对服务器的能力做了错误的假设。参考 <a href="#3-1-4-CONNECT%E5%8A%A8%E4%BD%9C">3.1.4</a> CONNECT动作。</p><p>用于格式错误的包和协议错误的原因码包括：</p><ul><li>0x81 格式错误的包</li><li>0x82 协议错误</li><li>0x93 超出接收最大值</li><li>0x95 包过大</li><li>0x9A 不支持保留消息</li><li>0x9B 不支持的 QoS</li><li>0x9E 不支持共享订阅</li><li>0xA1 不支持订阅ID</li><li>0xA2 不支持通配符订阅</li></ul><p>当客户端检测到格式错误的包或协议错误，且给出了规范中的原因码后，他<strong>应该</strong>关闭网络连接。当错误发生在 AUTH 包中时，他<strong>可以</strong>发先发送包含原因码的<strong>DISCONNECT</strong>包，再关闭网络连接。当错误发生在任何其他种类的包时，他<strong>应该</strong>发送带有原因码的 DISCONNECT 包，再关闭网络连接。可以使用原因码 0x81（格式错误的包）或 0x82（协议错误）或是 <a href="#3-14-2-1-%E6%96%AD%E5%BC%80%E5%8E%9F%E5%9B%A0%E7%A0%81">3.14.2.1</a> 中定义的更详细的断开原因。</p><p><span class="vcMarked">当服务器检测到格式错误的包或协议错误，且给出了规范中的原因码后，他<strong>必须</strong>断开网络连接</span> <span class="vcReferred">[MQTT-4.13.1-1]</span>。如果错误发生在 CONNECT 包中，服务器<strong>可以</strong>发送带有原因码的 CONNACK 包，再关闭网络连接。当错误发生在任何其他种类的包时，他<strong>应该</strong>发送带有原因码的 DISCONNECT 包再关闭网络连接。可以使用原因码 0x81（格式错误的包）或 0x82（协议错误）或是 <a href="#3-2-2-2-%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E7%A0%81">3.2.2.2</a> 中定义的连接原因码或是 <a href="#3-14-2-1-%E6%96%AD%E5%BC%80%E5%8E%9F%E5%9B%A0%E7%A0%81">3.14.2.1</a> 中定义的更详细的断开原因码。对其他会话没有影响。</p><p>如果服务器和客户端都没有对 MQTT 包进行检查，可能导致错误无法被测出，从而可能造成对数据的伤害。</p><h3 id="4-13-2-其他错误"><a href="#4-13-2-其他错误" class="headerlink" title="4.13.2 其他错误"></a>4.13.2 其他错误</h3><p>除了格式错误的包和协议错误外，发送方无法提前预见其他错误，因为接收方可能存在一些限制条件，而这些限制条件未通知给发送方。录入，接收方的客户端或服务器可能会遇到瞬态错误，如内存不足，从到导致某个 MQTT 包处理失败。</p><p>带有 0x80 或更高原因码的确认包 PUBACK、PUBREC、PUBREL、PUBCOMP、SUBACK、UNSUBACK 表示由包ID标识的已接收包存在错误。此错误不会影响其他会话或同一会话中的其他包。</p><p><span class="vcMarked">CONNACK 和 DISCONNECT 包允许使用原因码为 0x80 或更高来指示网络连接将被关闭。如果指定了 0x80 或更高的原因码，则无论是否发送了 CONNACK 或 DISCONNECT 包，都<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-4.13.2-1]</span>。发送这些原因码中的任何一个不会对任何其他会话产生影响。</p><p>如果 MQTT 包包含多个错误，接收方可以按任意顺序验证包，并对发现的任何错误采取适当的措施。</p><p>参考 <a href="#5-4-9-%E5%A4%84%E7%90%86%E7%A6%81%E6%AD%A2%E7%9A%84Unicode%E7%A0%81%E6%AE%B5">5.4.9</a> 了解关于处理禁止的 Unicode 码段的信息。</p><h1 id="5-安全性（非规范性）"><a href="#5-安全性（非规范性）" class="headerlink" title="5 安全性（非规范性）"></a>5 安全性（非规范性）</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>MQTT 是一种消息传输的传输协议规范，允许其实现选择网络、隐私、身份验证和授权技术。由于所选的具体安全技术将根据具体情况而定，因此实现者有责任在其设计中包含适当的功能。</p><p>MQTT 实现很可能需要紧跟不断变化的安全形势。</p><p>本章提供了一些通用的实现指导，为了不限制可做的选择，本章是非规范性的。但这不影响本章的重要性。</p><p>强烈建议提供了 TLS <a href="#1.4-RFC5246">RFC5246</a> 实现的服务器应使用 TCP 端口 8883（IANA 服务名：secure-mqtt）。</p><p>存在多种解决方案提供商需要考虑的威胁。例如：</p><ul><li>设备可能被入侵</li><li>静态数据可能被访问</li><li>协议行为可能存在副作用（例如 “定时攻击”）</li><li>拒绝服务（DoS）攻击</li><li>通信可能会被拦截、篡改、重定向或泄露</li><li>注入伪造的 MQTT 包</li></ul><p>MQTT 解决方案通常部署在具有潜在威胁的通信环境中。在这种情况下，实施方案通常需要提供以下机制：</p><ul><li>用户和设备的身份验证</li><li>访问服务器资源的授权</li><li>MQTT包和应用程序数据的完整性</li><li>MQTT包和应用程序数据的隐私</li></ul><p>除了技术安全问题之外，还可能存在地理（例如，美国-欧盟隐私盾框架 <a href="#1.4-USEUPRIVSH">USEUPRIVSH</a>）、行业特定（例如，支付卡行业数据安全标准 <a href="#1.4-PCIDSS">PCIDSS</a>）和监管方面的考虑（例如，萨班斯-奥克斯利法案 <a href="#1.4-SARBANES">SARBANES</a>）。</p><h2 id="5-2-MQTT解决方案：安全和认证"><a href="#5-2-MQTT解决方案：安全和认证" class="headerlink" title="5.2 MQTT解决方案：安全和认证"></a>5.2 MQTT解决方案：安全和认证</h2><p>实现 MQTT 解决方案时，可能需要符合特定的行业安全标准，例如美国国家标准与技术研究院网络安全框架 (NIST Cyber Security Framework) <a href="#1.4-NISTCSF">NISTCSF</a>、支付卡行业数据安全标准 (PCI-DSS) <a href="#1.4-PCIDSS">PCIDSS</a>、联邦信息处理标准 140-2 (FIPS-140-2) <a href="#1.4-FIPS1402">FIPS1402</a> 和美国国家安全局套件 B (NSA Suite B) <a href="#1.4-NSAB">NSAB</a>。</p><p>关于在 NISTCSF 中使用 MQTT 的指南，可以在 MQTT 补充出版物《MQTT 和 NIST 关键基础设施网络安全改进框架》<a href="#1.4-MQTTV311">MQTTNIST</a> 中找到。使用经过行业验证、独立验证和认证的技术将有助于满足合规性要求。</p><h2 id="5-3-轻量级密码学和受限设备"><a href="#5-3-轻量级密码学和受限设备" class="headerlink" title="5.3 轻量级密码学和受限设备"></a>5.3 轻量级密码学和受限设备</h2><p>高级加密标准 <a href="#1.4-AES">AES</a> 是目前最广泛采用的加密算法。许多处理器都支持硬件加速 AES，但嵌入式处理器通常不支持。<a href="#1.4-CHACHA20">CHACHA20</a> 加密算法在软件中加密和解密的速度要快得多，但没有 AES 那么广泛使用。</p><p><a href="#1.4-ISO29192">ISO29192</a> 针对性能受限的 “低端” 设备，推荐了一些专门调整过的密码原语。</p><h2 id="5-4-实施说明"><a href="#5-4-实施说明" class="headerlink" title="5.4 实施说明"></a>5.4 实施说明</h2><p>MQTT 实施和使用时需要考虑多个安全方面。以下部分并不应该被视为 “检查清单”。</p><p>实现可能希望实现以下部分或全部内容：</p><h3 id="5-4-1-服务器对客户端进行身份验证"><a href="#5-4-1-服务器对客户端进行身份验证" class="headerlink" title="5.4.1 服务器对客户端进行身份验证"></a>5.4.1 服务器对客户端进行身份验证</h3><p>CONNECT 包包含用户名和密码字段。实现可以选择如何利用这些字段的内容。实现可以提供自己的认证机制，使用类似 LDAP <a href="#1.4-RFC4511">RFC4511</a> 或 OAuth <a href="#1.4-RFC6749">RFC6749</a> token 之类的外部认证系统，或借用操作系统的认证机制。</p><p>MQTT v5.0 提供了增强认证机制，参考 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a> 中的描述。使用此机制需要客户端和服务器同时支持。</p><p>以明文传递认证数据，混淆此类数据元素或是不需要身份验证数据的实现应该意识到这可能会引起中间人攻击和数据重放攻击。<a href="#5-4-5-%E5%BA%94%E7%94%A8%E6%B6%88%E6%81%AF%E5%92%8CMQTT%E5%8C%85%E7%9A%84%E9%9A%90%E7%A7%81">5.4.5</a> 介绍了确保数据隐私的方法。</p><p>客户端和服务器之间的虚拟专用网络 (VPN) 可以确保数据仅从授权客户端接收。</p><p>当使用 TLS <a href="#1.4-RFC5246">RFC5246</a> 时，服务器可以使用客户端发送的 TLS 证书对客户端进行认证。</p><p>实现可能允许使用客户端发送到服务器的应用消息进行身份认证。</p><h3 id="5-4-2-服务器对客户端进行授权"><a href="#5-4-2-服务器对客户端进行授权" class="headerlink" title="5.4.2 服务器对客户端进行授权"></a>5.4.2 服务器对客户端进行授权</h3><p>如果客户端已成功通过身份验证，服务器实现应在接受其连接之前检查其是否已获得授权。</p><p>授权可能基于客户端提供的信息，例如用户名、客户端的主机名&#x2F;IP 地址或身份验证机制的结果。</p><p>特别是，实现应检查客户端是否有权使用客户端ID，因为这可以访问 MQTT 会话状态（<a href="#4-1-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81">4.1</a> 中描述）。此授权检查是为了防止一个客户端意外或恶意地使用已被其他客户端使用的客户端ID的情况。</p><p>实现应该提供在 CONNECT 之后发生的访问控制，以限制客户端发布到特定主题或使用特定主题过滤器订阅的能力。实现应考虑限制对具有广泛范围的主题过滤器的访问，例如 # 主题过滤器。</p><h3 id="5-4-3-客户端对服务器进行身份验证"><a href="#5-4-3-客户端对服务器进行身份验证" class="headerlink" title="5.4.3 客户端对服务器进行身份验证"></a>5.4.3 客户端对服务器进行身份验证</h3><p>MQTT 协议不是信任对称的。在使用基本身份验证的情况下，没有客户端对服务器进行身份验证的机制。某些增强认证确实允许进行相互身份验证。</p><p>在使用 TLS <a href="#1.4-RFC5246">RFC5246</a> 的情况下，客户端可以使用服务器发送的 TLS 证书来对服务器进行身份验证。</p><p>从单个 IP 地址为多个主机名提供 MQTT 服务的实现应注意 <a href="#1.4-RFC6066">RFC6066</a> 第 3 节中定义的 TLS 服务器名称指示扩展 (Server Name Indication，SNI)。 这允许客户端告诉服务器它试图连接的服务器的主机名。</p><p>一些 MQTT 实现允许通过服务器发送给客户端的应用消息进行身份验证。MQTT v5.0 引入了增强身份验证机制（详细见 <a href="#4-12-%E5%A2%9E%E5%BC%BA%E8%AE%A4%E8%AF%81">4.12</a>），该机制可以用于服务器对客户端进行身份验证。但前提是客户端和服务器都支持此机制。</p><p>客户端与服务器之间使用 VPN 可以增強客户端连接到预期的服务器的可信度。</p><h3 id="5-4-4-应用消息和MQTT包的完整性"><a href="#5-4-4-应用消息和MQTT包的完整性" class="headerlink" title="5.4.4 应用消息和MQTT包的完整性"></a>5.4.4 应用消息和MQTT包的完整性</h3><p>应用程序可以独立地在其应用消息中包含哈希值。这可以在网络传输过程中和静止状态下提供发布数据包内容的完整性。</p><p>TLS <a href="#1.4-RFC5246">RFC5246</a> 提供了哈希算法来验证通过网络发送的数据的完整性。</p><p>使用 VPN 连接客户端和服务器可以提供 VPN 覆盖的网络部分的数据完整性。</p><h3 id="5-4-5-应用消息和MQTT包的隐私"><a href="#5-4-5-应用消息和MQTT包的隐私" class="headerlink" title="5.4.5 应用消息和MQTT包的隐私"></a>5.4.5 应用消息和MQTT包的隐私</h3><p>TLS <a href="#1.4-RFC5246">RFC5246</a> 可以对通过网络发送的数据进行加密。一些有效的 TLS 密码套件包含不加密数据的 NULL 加密算法。为确保隐私，客户端和服务器应避免使用这些密码套件。</p><p>应用程序可以独立加密其应用消息的内容。这可以为应用消息在网络传输过程中和静止状态下提供隐私保护。但这并不能为应用消息的其他属性（例如主题名称）提供隐私保护。</p><p>客户端和服务器实现可以为静止数据（例如作为会话的一部分存储的应用程序消息）提供加密存储。</p><p>使用 VPN 连接客户端和服务器可以提供 VPN 覆盖的网络部分的数据隐私。</p><h3 id="5-4-6-消息传输的不可否认性"><a href="#5-4-6-消息传输的不可否认性" class="headerlink" title="5.4.6 消息传输的不可否认性"></a>5.4.6 消息传输的不可否认性</h3><p>应用程序设计者可能需要考虑适当的策略来实现端到端的不可否认性。</p><h3 id="5-4-7-检测客户端和服务器是否被入侵"><a href="#5-4-7-检测客户端和服务器是否被入侵" class="headerlink" title="5.4.7 检测客户端和服务器是否被入侵"></a>5.4.7 检测客户端和服务器是否被入侵</h3><p>使用 TLS <a href="#1.4-RFC5246">RFC5246</a> 的客户端和服务器实现应提供功能，以确保在建立 TLS 连接时提供的任何 TLS 证书与连接的客户端或被连接的服务器的主机名相关联。</p><p>使用 TLS 的客户端和服务器实现可以选择提供检查证书吊销列表 (CRL <a href="#1.4-RFC5280">RFC5280</a>) 和在线证书状态协议 (OSCP <a href="#1.4-RFC6960">RFC6960</a>) 的功能，以防止使用已吊销的证书。</p><p>物理部署可能将防篡改硬件与应用消息中特定数据的传输相结合。例如，仪表可能嵌入 GPS 以确保它不会在未经授权的位置使用。[IEEE8021AR](#1.4-IEEE 802.1AR) 是使用加密绑定标识符实现设备身份验证机制的标准。</p><h3 id="5-4-8-检测异常行为"><a href="#5-4-8-检测异常行为" class="headerlink" title="5.4.8 检测异常行为"></a>5.4.8 检测异常行为</h3><p>服务器实现可以监控客户端行为以检测潜在的安全事件。例如：</p><ul><li>重复连接尝试</li><li>重复身份验证尝试</li><li>异常终止连接</li><li>主题扫描（尝试发送或订阅许多主题）</li><li>发送无法投递的消息（没有订阅者订阅该主题）</li><li>连接但不发送数据的客户端</li></ul><p>服务器实现可能会关闭违反其安全规则的客户端的网络连接。</p><p>服务器实现检测到可疑行为可能会基于诸如 IP 地址或客户端标识符之类的标识符实施动态阻止列表。</p><p>部署可以使用网络级控制（如果可用）基于 IP 地址或其他信息实施速率限制或阻止。</p><h3 id="5-4-9-处理禁止的Unicode码段"><a href="#5-4-9-处理禁止的Unicode码段" class="headerlink" title="5.4.9 处理禁止的Unicode码段"></a>5.4.9 处理禁止的Unicode码段</h3><p><a href="#1-5-4-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.4</a> 描述了禁止的 Unicode 码段，这些码段不应包含在 UTF-8 编码的字符串中。客户端或服务器实现可以选择是否验证这些码段未在 <code>UTF-8字符串</code>（例如主题名称或属性）中使用。</p><p>如果服务器不验证 <code>UTF-8字符串</code> 中的码段，但订阅的客户端会验证，则第二个客户端可能能够通过发布包含禁止的 Unicode 码段的主题名称或使用属性来导致订阅客户端关闭网络连接。本节建议采取一些步骤来防止此问题。</p><p>当客户端验证载荷是否与载荷格式标志匹配而服务器不验证时，可能会发生类似的问题。对此的考虑和补救措施类似于处理禁止的 Unicode 码段的措施。</p><h4 id="5-4-9-1-关于使用禁止的Unicode码段的考虑"><a href="#5-4-9-1-关于使用禁止的Unicode码段的考虑" class="headerlink" title="5.4.9.1 关于使用禁止的Unicode码段的考虑"></a>5.4.9.1 关于使用禁止的Unicode码段的考虑</h4><p>通常，实现会选择验证 <code>UTF-8字符串</code>，检查是否未使用禁止的Unicode码段。这样可以避免实现面对以下难题，例如需要使用对这些码段铭感的库，或是避免了应用程序需要处理这些码段。</p><p>验证是否未使用这些码段可以消除一些安全风险。一些可能的安全漏洞是利用日志文件中的控制字符来掩盖日志中的条目或混淆处理日志文件的工具。Unicode Noncharacters 通常用作特殊标记，允许它们进入 <code>UTF-8字符串</code>可能会导致此类漏洞利用。</p><h4 id="5-4-9-2-发布者和订阅者之间的交互"><a href="#5-4-9-2-发布者和订阅者之间的交互" class="headerlink" title="5.4.9.2 发布者和订阅者之间的交互"></a>5.4.9.2 发布者和订阅者之间的交互</h4><p>发布应用程序消息的发布者通常期望服务器将消息转发给订阅者，并且这些订阅者能够处理消息。</p><p>以下是一些发布客户端可能导致订阅客户端关闭网络连接的条件：</p><ul><li>发布客户端使用包含禁止的Unicode码段的主题名称发布应用程序消息。</li><li>发布客户端库允许在主题名称中使用禁止的Unicode码段，而不是拒绝他。</li><li>发布客户端被授权发送发布。</li><li>订阅客户端被授权使用匹配主题名称的主题过滤器。请注意，禁止的Unicode码段可能出现在主题名称的一部分，该部分与主题过滤器中的通配符字符匹配。</li><li>服务器将消息转发给匹配的订阅者，而不是断开发布者的连接。</li><li>在这种情况下，订阅客户端可能：<ul><li>关闭网络连接，因为它不允许使用禁止的Unicode码段，可能在这样做之前发送 DISCONNECT 消息。对于 QoS 1 和 QoS 2 消息，这可能导致服务器再次发送消息，导致客户端再次关闭网络连接。</li><li>通过在 PUBACK (QoS 1) 或 PUBREC (QoS 2) 中发送大于或等于 0x80 的原因码来拒绝应用程序消息。</li><li>接受应用程序消息，但无法处理它，因为它包含禁止的Unicode码段。</li><li>成功处理应用程序消息。</li></ul></li></ul><p>客户端关闭网络连接的可能性可能直到发布者使用一个禁止的Unicode码段点才会被注意到。</p><h4 id="5-4-9-3-补救措施"><a href="#5-4-9-3-补救措施" class="headerlink" title="5.4.9.3 补救措施"></a>5.4.9.3 补救措施</h4><p>如果存在将禁止的Unicode码段包含在主题名称或传递给客户端的其他属性中的可能性，解决方案所有者可以采用以下建议之一：</p><ol><li>将服务器实现更改为拒绝禁止的Unicode码段的 <code>UTF-8字符串</code> 的实现，服务器可以通过发送大于或等于 0x80 的原因代码或关闭网络连接来拒绝这些消息。</li><li>将订阅者使用的客户端库更改为可以容忍禁止的Unicode码段的库。客户端可以处理或丢弃包含禁止的Unicode码段的 <code>UTF-8字符串</code> 的消息，只要它继续遵循协议即可。</li></ol><h3 id="5-4-10-其他安全注意事项"><a href="#5-4-10-其他安全注意事项" class="headerlink" title="5.4.10 其他安全注意事项"></a>5.4.10 其他安全注意事项</h3><p>证书安全:</p><p>如果客户端或服务器 TLS 证书丢失或被认为可能泄露，则应将其吊销（使用 CRL <a href="#1.4-RFC5280">RFC5280</a> 和&#x2F;或 OSCP <a href="#1.4-RFC6960">RFC6960</a>）。</p><p>丢失或被认为泄露的客户端或服务器身份验证凭证（例如用户名和密码）应予以撤销和&#x2F;或重新颁发。</p><p>长连接安全:</p><ul><li>使用 TLS <a href="#1.4-RFC5246">RFC5246</a> 的客户端和服务器实现应允许会话重新协商以建立新的加密参数（替换会话密钥、更改密码套件、更改身份验证凭证）。</li><li>服务器可能会关闭客户端的网络连接，并要求他们使用新凭证重新验证身份。</li><li>服务器可能要求其客户端使用 <a href="#4-12-1-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%81">4.12.1</a> 节中描述的机制定期重新验证身份。</li></ul><p>受限设备和受限网络上的客户端可以使用 TLS <a href="#1.4-RFC5246">RFC5246</a> 会话恢复，以降低重新连接 TLS <a href="#1.4-RFC5246">RFC5246</a> 会话的成本。</p><p>连接到服务器的客户端与连接到同一服务器并具有在相同主题上发布数据的权限的其他客户端具有传递信任关系。</p><h3 id="5-4-11-使用SOCKS代理"><a href="#5-4-11-使用SOCKS代理" class="headerlink" title="5.4.11 使用SOCKS代理"></a>5.4.11 使用SOCKS代理</h3><p>客户端实现应该注意，某些环境需要使用 SOCKSv5 <a href="#1.4-RFC1928">RFC1928</a> 代理进行外部网络连接。一些 MQTT 实现可以通过使用 SOCKS，利用替代的安全隧道（例如 SSH）进行连接。如果实现选择使用 SOCKS，他们应该支持匿名和用户名&#x2F;密码认证的 SOCKS 代理。后一种情况下，实现应该注意 SOCKS 认证可能以明文进行，因此应避免使用与连接 MQTT 服务器相同的凭证。</p><h3 id="5-4-12-安全配置"><a href="#5-4-12-安全配置" class="headerlink" title="5.4.12 安全配置"></a>5.4.12 安全配置</h3><p>实现者和解决方案设计人员可以将安全性视为一组可应用于 MQTT 协议的配置。下面展示了分层安全体系结构的一个示例。</p><h4 id="5-4-12-1-透明通信配置"><a href="#5-4-12-1-透明通信配置" class="headerlink" title="5.4.12.1 透明通信配置"></a>5.4.12.1 透明通信配置</h4><p>这种配置没有额外的安全机制，MQTT 协议直接运行在开放网络上。</p><h4 id="5-4-12-2-安全网络通信配置"><a href="#5-4-12-2-安全网络通信配置" class="headerlink" title="5.4.12.2 安全网络通信配置"></a>5.4.12.2 安全网络通信配置</h4><p>这种配置使用具有安全控制措施的物理或虚拟网络，例如 VPN 或物理安全网络。</p><h4 id="5-4-12-3-安全传输配置"><a href="#5-4-12-3-安全传输配置" class="headerlink" title="5.4.12.3 安全传输配置"></a>5.4.12.3 安全传输配置</h4><p>当使用安全传输配置时，MQTT 协议运行在一个物理网络或是虚拟网络中，使用 TLS <a href="#1.4-RFC5246">RFC5246</a> 加密 MQTT 协议传输，提供身份验证、完整性保护和隐私保护。</p><p>TLS <a href="#1.4-RFC5246">RFC5246</a> 客户端身份验证可以作为用户名和密码字段提供的 MQTT 客户端身份验证的补充或替代使用。</p><h4 id="5-4-12-4-行业特定的安全配置"><a href="#5-4-12-4-行业特定的安全配置" class="headerlink" title="5.4.12.4 行业特定的安全配置"></a>5.4.12.4 行业特定的安全配置</h4><p>预计 MQTT 协议将被设计到行业特定的应用配置中，每个配置都定义了一个威胁模型和用于解决这些威胁的具体安全机制。特定安全机制的建议通常会参考现有工作，包括：</p><p><a href="#1.4-NISTCSF">NISTCSF</a> NIST 网络安全框架<br><a href="#1.4-NIST7628">NIST7628</a> NISTIR 7628 智能电网网络安全指南<br><a href="#1.4-FIPS1402">FIPS1402</a> 安全模块的安全要求 (FIPS PUB 140-2)<br><a href="#1.4-PCIDSS">PCIDSS</a> PCI-DSS 支付卡行业数据安全标准<br><a href="#1.4-NSAB">NSAB</a> 美国国家安全局 Suite B 加密</p><h1 id="6-使用WebSocket作为传输层"><a href="#6-使用WebSocket作为传输层" class="headerlink" title="6 使用WebSocket作为传输层"></a>6 使用WebSocket作为传输层</h1><p>如果 MQTT 通过 WebSocket <a href="#1.3-RFC6455">RFC6455</a> 连接进行传输，则适用以下条件：</p><ul><li><span class="vcMarked">MQTT 包<strong>必须</strong>在 WebSocket 二进制数据帧中发送。 如果收到任何其他类型的数据帧，接收方<strong>必须</strong>关闭网络连接</span> <span class="vcReferred">[MQTT-6.0.0-1]</span>。</li><li><span class="vcMarked">单个 WebSocket 数据帧可以包含多个或部分 MQTT 包。 接收方不得假定 MQTT 包与 WebSocket 帧边界对齐</span> <span class="vcReferred">[MQTT-6.0.0-2]</span>。</li><li><span class="vcMarked">客户端<strong>必须</strong>在其提供的 WebSocket 子协议列表中包含“mqtt”</span> <span class="vcReferred">[MQTT-6.0.0-3]</span>。</li><li><span class="vcMarked">服务器选择并返回的 WebSocket 子协议名称<strong>必须</strong>为“mqtt”</span> <span class="vcReferred">[MQTT-6.0.0-4]</span>。</li><li>用于连接客户端和服务器的 WebSocket URI 对 MQTT 协议没有影响。</li></ul><h2 id="6-1-IANA注意事项"><a href="#6-1-IANA注意事项" class="headerlink" title="6.1  IANA注意事项"></a>6.1  IANA注意事项</h2><p>本规范要求 IANA 修改 “WebSocket 子协议名称” 注册表下 WebSocket MQTT 子协议的注册，并使用以下数据：</p><p>图 6.6‑1 - IANA WebSocket Identifier</p><table>  <tbody>    <tr><td>Subprotocol Identifier</td><td>mqtt</td><tr>    <tr><td>Subprotocol Common Name</td><td>mqtt</td><tr>    <tr><td>Subprotocol Definition</td><td>http://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html</td><tr>  </tbody><table><h1 id="7-一致性"><a href="#7-一致性" class="headerlink" title="7 一致性"></a>7 一致性</h1><p>MQTT 规范定义了 MQTT 客户端实现和 MQTT 服务器实现的一致性。 MQTT 实现既可以作为 MQTT 客户端，也可以作为 MQTT 服务器。</p><h2 id="7-1-一致性条款"><a href="#7-1-一致性条款" class="headerlink" title="7.1 一致性条款"></a>7.1 一致性条款</h2><h3 id="7-1-1-MQTT服务器一致性条款"><a href="#7-1-1-MQTT服务器一致性条款" class="headerlink" title="7.1.1 MQTT服务器一致性条款"></a>7.1.1 MQTT服务器一致性条款</h3><p>服务器的定义请参考术语表中的 <a href="#1.2-server">服务器</a>。</p><p>一个 MQTT 服务器仅在满足以下所有陈述时才符合本规范：</p><ol><li>服务器发送的所有 MQTT 包的格式必须与 <a href="#2-MQTT%E5%8C%85%E6%A0%BC%E5%BC%8F">第 2 章</a> 和 <a href="#3-MQTT%E5%8C%85">第 3 章</a> 描述的格式相匹配。</li><li>它遵循第 <a href="#4-7-%E4%B8%BB%E9%A2%98%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98%E8%BF%87%E6%BB%A4%E5%99%A8">4.7 节</a> 描述的主题匹配规则和第 <a href="#4-8-%E8%AE%A2%E9%98%85">4.8 节</a> 描述的订阅规则。</li><li>它满足以下章节中已标识的<strong>必须</strong>级别要求，但仅适用于客户端的除外：</li></ol><ul><li><a href="#1-%E4%BB%8B%E7%BB%8D">第一章 - 简介</a></li><li><a href="#2-MQTT%E5%8C%85%E6%A0%BC%E5%BC%8F">第二章 - MQTT包格式</a></li><li><a href="#3-MQTT%E5%8C%85">第三章 - MQTT包</a></li><li><a href="#4-%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA">第四章 - 操作行为</a></li><li><a href="#6-%E4%BD%BF%E7%94%A8WebSocket%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82">第六章 - 使用WebSocket作为传输层</a></li><li>不需要使用规范之外定义的任何扩展即可与任何其他符合标准的实现进行互操作。</li></ul><h3 id="7-1-2-MQTT客户端一致性条款"><a href="#7-1-2-MQTT客户端一致性条款" class="headerlink" title="7.1.2 MQTT客户端一致性条款"></a>7.1.2 MQTT客户端一致性条款</h3><p>客户端的定义请参考术语表中的 <a href="#1.2-client">客户端</a>。</p><p>MQTT 客户端仅在满足以下所有陈述时才符合本规范：</p><ol><li>客户端发送的所有 MQTT 包的格式必须与<a href="#2-MQTT%E5%8C%85%E6%A0%BC%E5%BC%8F">第 2 章</a> 和 <a href="#3-MQTT%E5%8C%85">第 3 章</a>描述的格式相匹配。</li><li>客户端必须满足以下章节中已标识的<strong>必须</strong>级别要求，但仅适用于服务器的除外：</li></ol><ul><li><a href="#1-%E4%BB%8B%E7%BB%8D">第一章 - 简介</a></li><li><a href="#2-MQTT%E5%8C%85%E6%A0%BC%E5%BC%8F">第二章 - MQTT包格式</a></li><li><a href="#3-MQTT%E5%8C%85">第三章 - MQTT包</a></li><li><a href="#4-%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA">第四章 - 操作行为</a></li><li><a href="#6-%E4%BD%BF%E7%94%A8WebSocket%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82">第六章 - 使用WebSocket作为传输层</a></li></ul><ol start="3"><li>不需要使用规范之外定义的任何扩展即可与任何其他符合标准的实现进行互操作。</li></ol><h1 id="附录-A-致谢"><a href="#附录-A-致谢" class="headerlink" title="附录 A. 致谢"></a>附录 A. 致谢</h1><p>MQTT 技术委员会 (TC) 特别感谢 MQTT 协议的最初发明者 Andy Stanford-Clark 博士和 Arlen Nipper，以及他们对标准化过程的持续支持。</p><p>技术委员会感谢 Brian Raymor (前微软员工)，他在 5.0 版本标准的大部分开发过程中担任 MQTT 技术委员会的联合主席。</p><p>以下个人是 OASIS 技术委员会在创建本标准期间的成员，他们的贡献得到了热烈的认可：</p><p>参与者：</p><ul><li>Senthil Nathan Balasubramaniam (Infiswift)</li><li>Dr. Andrew Banks, 编辑 (IBM)</li><li>Ken Borgendale, 编辑 (IBM)</li><li>Ed Briggs, 编辑 (微软)</li><li>Raphael Cohn (个人)</li><li>Richard Coppen, 主席 (IBM)</li><li>William Cox (个人)</li><li>Ian Craggs , 秘书 (IBM)</li><li>Konstantin Dotchkoff (微软)</li><li>Derek Fu (IBM)</li><li>Rahul Gupta, 编辑 (IBM)</li><li>Stefan Hagen (个人)</li><li>David Horton (Solace Systems)</li><li>Alex Kritikos (Software AG, Inc.)</li><li>Jonathan Levell (IBM)</li><li>Shawn McAllister (Solace Systems)</li><li>William McLane (TIBCO Software Inc.)</li><li>Peter Niblett (IBM)</li><li>Dominik Obermaier (dc-square GmbH)</li><li>Nicholas O’Leary (IBM)</li><li>Brian Raymor (微软)</li><li>Andrew Schofield (IBM)</li><li>Tobias Sommer (Cumulocity)</li><li>Joe Speed (IBM)</li><li>Dr Andy Stanford-Clark (IBM)</li><li>Allan Stockdill-Mander (IBM)</li><li>Stehan Vaillant (Cumulocity)</li></ul><p>有关对 MQTT 早期版本做出贡献的人员列表，请参考 MQTT v3.1.1 规范 <a href="#1.4-MQTTV311">MQTTV311</a> 的附录 A。</p><h1 id="附录-B-强制性规范性声明（非规范性）"><a href="#附录-B-强制性规范性声明（非规范性）" class="headerlink" title="附录 B. 强制性规范性声明（非规范性）"></a>附录 B. 强制性规范性声明（非规范性）</h1><p>本附录是非规范性的，是作为本文档主体中编号的一致性声明的方便摘要而提供的。有关一致性要求的明确列表，请参阅<a href="#7-%E4%B8%80%E8%87%B4%E6%80%A7">第 7 章</a>。</p><table><thead><tr><th>规范性声明编号</th><th>规范性声明</th></tr></thead><tbody><tr><td>[MQTT-1.5.4-1]</td><td>在 UTF-8 编码字符串中的字符<strong>必须</strong>为 [Unicode] 和 [RFC3629] 中所定义的，格式正确的字符编码。<strong>必须不</strong>使用U+D800 至 U+DFFF之间的编码</td></tr><tr><td>[MQTT-1.5.4-2]</td><td>UTF-8 编码字符串<strong>必须</strong>不包含空字符 U+0000</td></tr><tr><td>[MQTT-1.5.4-3]</td><td>无论 UTF-8 编码序列 0xEF 0xBB 0xBF 出现在字符串的何处，他永远被解释为 U+FEFF (0宽无换行空格) 而且<strong>必须</strong>不能被数据包的接收者跳过或剥离</td></tr><tr><td>[MQTT-1.5.5-1]</td><td>变长整数编码时<strong>必须</strong>使用能够表示数字值的最小长度来进行编码</td></tr><tr><td>[MQTT-1.5.7-1]</td><td>UTF-8字符串对中的两个字符串都<strong>必须</strong>遵守 UTF-8 字符串的需求</td></tr><tr><td>[MQTT-2.1.3-1]</td><td>当一个比特位被标记为 “保留” 时，他的意义被保留到未来使用而他的值<strong>必须</strong>按照下表设置</td></tr><tr><td>[MQTT-2.2.1-2]</td><td>当 PUBLISH 包的 QoS 值为 0 时，<strong>必须不</strong>包含 包ID 字段</td></tr><tr><td>[MQTT-2.2.1-3]</td><td>每当客户端发送新的 SUBSCRIBE 包，UNSUBSCRIBE 包 或 QoS &gt; 0 的 PUBLISH 包，<strong>必须</strong>携带一个非零且当前未被使用的包ID</td></tr><tr><td>[MQTT-2.2.1-4]</td><td>每当服务器发送新的 QoS &gt; 0 的 PUBLISH 包，<strong>必须</strong>携带一个非零且当前未被使用的包ID</td></tr><tr><td>[MQTT-2.2.1-5]</td><td>PUBACK，PUBREC，PUBREL 或 PUBCOMP 包<strong>必须</strong>携带和 PUBLISH 相同的包ID</td></tr><tr><td>[MQTT-2.2.1-6]</td><td>SUBACK 和 UNSUBACK <strong>必须</strong>携带和其对应的 SUBSCRIBE 和 UNSUBSCRIBE 包相同的包ID</td></tr><tr><td>[MQTT-2.2.2-1]</td><td>如果没有属性，<strong>必须</strong>通过一个 0 值的属性长度来明确表示</td></tr><tr><td>[MQTT-3.1.0-1]</td><td>当客户端和服务器的网络连接建立后，客户端向服务器发送的第一个数据包<strong>必须</strong>是 CONNECT 包</td></tr><tr><td>[MQTT-3.1.0-2]</td><td>服务器<strong>必须</strong>将客户端发送的第二个 CONNECT 包视为协议错误并关闭网络连接</td></tr><tr><td>[MQTT-3.1.2-1]</td><td>协议名称<strong>必须</strong>是 <code>UTF-8字符串</code>表示的 “MQTT”。如果服务器不想接收此连接，同时又想告知客户端服务器是一个 MQTT 服务器，<strong>可以</strong>发送一个带有 0x84（协议版本不支持）原因码的 CONNACK，随后服务器<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.1.2-2]</td><td>如果客户端使用的协议版本不为 5 而且服务器不想接受此 CONNECT 包，服务器<strong>可以</strong>发送一个带有 0x84（协议版本不支持）原因码的 CONNACK，随后服务器<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.1.2-3]</td><td>服务器<strong>必须</strong>验证 CONNECT 包中的保留位的值是 0</td></tr><tr><td>[MQTT-3.1.2-4]</td><td>如果接收到全新开始值置为 1 的 CONNECT 包，客户端和服务器<strong>必须</strong>丢弃任何已经存在的会话并开始一个新的会话</td></tr><tr><td>[MQTT-3.1.2-5]</td><td>如果服务器接收到的 CONNECT 包中的全新开始被置为 0 并且服务器中已经存在和客户端ID关联的会话，服务器<strong>必须</strong>基于已经存在的会话状态恢复客户端的连接</td></tr><tr><td>[MQTT-3.1.2-6]</td><td>如果服务器接收到的 CONNECT 包中的全新开始被置为 0 并且服务器中没有和客户端ID关联的会话，服务器<strong>必须</strong>创建一个新的会话</td></tr><tr><td>[MQTT-3.1.2-7]</td><td>如果遗嘱标识被置为 1，则表示遗嘱消息<strong>必须</strong>被存储在服务器中，并且关联到此会话</td></tr><tr><td>[MQTT-3.1.2-8]</td><td>遗嘱消息<strong>必须</strong>在网络连接断开后的遗嘱延迟间隔时间过期后或会话结束时发布，除非由于服务器接收到一个带有 0x00（普通断开）原因码的 DISCONNECT 包从而删除了遗嘱消息，或是在遗嘱延迟间隔时间过期前接收了一个带有相同客户端ID的连接</td></tr><tr><td>[MQTT-3.1.2-9]</td><td>当遗嘱标识被置为 1 时，服务器需采用连接标志中的遗嘱 QoS 和遗嘱保留消息字段，载荷中<strong>必须</strong>包括遗嘱属性集、遗嘱主题和遗嘱载荷字段</td></tr><tr><td>[MQTT-3.1.2-10]</td><td>当服务器发布遗嘱后或服务器从客户端收到了原因码为 0x00（普通断开）的 DISCONNECT 包后，服务器<strong>必须</strong>从会话状态中删除遗嘱消息</td></tr><tr><td>[MQTT-3.1.2-11]</td><td>当遗嘱标识被置为 0 时，遗嘱 QoS <strong>必须</strong>被置为 0（0x00）</td></tr><tr><td>[MQTT-3.1.2-12]</td><td>当遗嘱标识被置为 1 时，遗嘱QoS的值可以是 0（0x00），1（0x01）或 2（0x02）</td></tr><tr><td>[MQTT-3.1.2-13]</td><td>当遗嘱标识被置为 0 时，遗嘱保留消息的值<strong>必须</strong>被置为 0</td></tr><tr><td>[MQTT-3.1.2-14]</td><td>当遗嘱标识被置为 1 且遗嘱保留消息被置为 0 时，服务器<strong>必须</strong>将遗嘱消息作为一个非保留消息发布</td></tr><tr><td>[MQTT-3.1.2-15]</td><td>当遗嘱标识被置为 1 且遗嘱保留消息被置为 1 时，服务器<strong>必须</strong>将遗嘱消息作为一个保留消息发布</td></tr><tr><td>[MQTT-3.1.2-16]</td><td>当用户名标识被置为 0 时，载荷中<strong>必须不</strong>存在用户名</td></tr><tr><td>[MQTT-3.1.2-17]</td><td>当用户名标识被置为 1 时，载荷中<strong>必须</strong>存在用户名</td></tr><tr><td>[MQTT-3.1.2-18]</td><td>当密码标识被置为 0 时，载荷中<strong>必须不</strong>存在密码</td></tr><tr><td>[MQTT-3.1.2-19]</td><td>当密码标识被置为 1 时，载荷中<strong>必须</strong>存在密码</td></tr><tr><td>[MQTT-3.1.2-20]</td><td>如果保活时间不为 0 且没有任何其他需要发送的数据包，客户端<strong>必须</strong>发送 PINGREQ 包</td></tr><tr><td>[MQTT-3.1.2-21]</td><td>如果服务器在 CONNACK 中提供了服务器保活时间，则客户端<strong>必须</strong>采用服务器保活时间的值来替代自己发送的保活时间的值</td></tr><tr><td>[MQTT-3.1.2-22]</td><td>如果保活时间为非零值且服务器在 1.5 倍的保活时间内没有收到来自客户端的任何 MQTT 包，服务器<strong>必须</strong>断开到客户端的网络连接并视为网络连接故障</td></tr><tr><td>[MQTT-3.1.2-23]</td><td>当会话过期间隔的值大于 0 时，客户端和服务器都<strong>必须</strong>在网络连接断开后存储会话状态</td></tr><tr><td>[MQTT-3.1.2-24]</td><td>服务器<strong>必须不</strong>向客户端发送超过最大包尺寸的数据包</td></tr><tr><td>[MQTT-3.1.2-25]</td><td>当一个包因超过最大包尺寸而无法发送，服务器<strong>必须</strong>将其丢弃，并视为发送成功</td></tr><tr><td>[MQTT-3.1.2-26]</td><td>服务器<strong>必须不</strong>发送一个主题别名的值大于客户端设置的主题别名最大值的 PUBLISH 包</td></tr><tr><td>[MQTT-3.1.2-27]</td><td>如果主题别名最大值未设置或值为 0，服务器<strong>必须不</strong>向客户端发送主题别名</td></tr><tr><td>[MQTT-3.1.2-28]</td><td>此值为 0 表示服务器<strong>必须不</strong>在 CONNACK 中回复响应信息</td></tr><tr><td>[MQTT-3.1.2-29]</td><td>如果请求问题信息的值为 0，服务器可以在 CONNACK 或 DISCONNECT 包中携带原因字符串或用户属性，但<strong>必须不</strong>在除 PUBLISH，CONNACK，DISCONNECT 之外的包中携带原因字符串或用户属性</td></tr><tr><td>[MQTT-3.1.2-30]</td><td>如果客户端再 CONNECK 包中设置了认证方式，那么在其收到 CONNACK 包之前，客户端<strong>必须不</strong>发送除了 AUTH 和 DISCONNECT 包之外的任何类型的包</td></tr><tr><td>[MQTT-3.1.3-1]</td><td>CONNECT 中的载荷包含了一个或多个 长度 + 内容 格式的字段，这些字段的存在与否由可变头中的标志位决定。这些字段的顺序是固定的，如果存在的话，<strong>必须</strong>按照 客户端ID，遗嘱属性集，遗嘱主题，遗嘱载荷，用户名，密码 这样的顺序出现</td></tr><tr><td>[MQTT-3.1.3-2]</td><td>客户端ID<strong>必须</strong>被客户端和服务器用于关联客户端和服务器之间的会话状态</td></tr><tr><td>[MQTT-3.1.3-3]</td><td>客户端ID<strong>必须</strong>作为 CONNECT 包载荷中的第一个字段出现</td></tr><tr><td>[MQTT-3.1.3-4]</td><td>客户端ID<strong>必须</strong>被编码为一个 <code>UTF-8字符串</code></td></tr><tr><td>[MQTT-3.1.3-5]</td><td>服务器<strong>必须</strong>允许客户端ID是长度为 1 到 23 个字节之间的 <code>UTF-8字符串</code>，且仅包含下列字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”</td></tr><tr><td>[MQTT-3.1.3-6]</td><td>服务器<strong>可以</strong>允许客户端传递长度为 0 的客户端ID，当此情况发生时，服务器<strong>必须</strong>将此情况作为一个特殊情况对待，并为客户端分配一个唯一的客户端ID</td></tr><tr><td>[MQTT-3.1.3-7]</td><td>服务器之后<strong>必须</strong>正常处理此 CONNECT 包，就如同客户端本身携带了这个唯一的客户端ID一样，而且<strong>必须</strong>在 CONNACK 包中返回这个分配的客户端ID</td></tr><tr><td>[MQTT-3.1.3-8]</td><td>如果服务器拒绝了客户端ID，服务器<strong>可以</strong>使用一个带有原因码 0x85（客户端ID不可用）的 CONNACK 包作为对客户端 CONNECT 包的响应，如同 [4.13] 中描述的那样，之后服务器<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.1.3-9]</td><td>如果在遗嘱延迟间隔结束前，该会话被新的网络连接延续，服务器<strong>必须不</strong>发送遗嘱</td></tr><tr><td>[MQTT-3.1.3-10]</td><td>服务器<strong>必须</strong>在发布遗嘱消息时维持用户属性的顺序</td></tr><tr><td>[MQTT-3.1.3-11]</td><td>遗嘱主题<strong>必须</strong>是一个 <code>UTF-8字符串</code></td></tr><tr><td>[MQTT-3.1.3-12]</td><td>用户名<strong>必须</strong>是一个 <code>UTF-8字符串</code></td></tr><tr><td>[MQTT-3.1.4-1]</td><td>服务器<strong>必须</strong>验证 CONNECT 包的格式符合 [3.1] 中的描述，如不符合则关闭网络连接</td></tr><tr><td>[MQTT-3.1.4-2]</td><td>服务器<strong>可以</strong>检查 CONNECT 包中的内容是否满足更进一步的限制要求，并且<strong>应该</strong>进行认证和授权检查。如果其中任何检查失败，服务器<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.1.4-3]</td><td>如果客户端ID代表了一个已经连接到服务器的客户端，服务器参考 [4.13] 发送一个带有原因码 0x8E（会话被接管）的 DISCONNECT 包到当前已有连接的客户端，且<strong>必须</strong>关闭当前已有连接客户端的网络连接</td></tr><tr><td>[MQTT-3.1.4-4]</td><td>服务器<strong>必须</strong>参考 [3.1.2.4] 中的描述处理全新开始标识</td></tr><tr><td>[MQTT-3.1.4-5]</td><td>服务器<strong>必须</strong>使用带有原因码为 0x00（成功）的 CONNACK 回复 CONNECT 包</td></tr><tr><td>[MQTT-3.1.4-6]</td><td>如果服务器拒绝了 CONNECT，服务器<strong>必须不</strong>处理客户端在 CONNECT 包之后发送的任何除了 AUTH 以外的包</td></tr><tr><td>[MQTT-3.2.0-1]</td><td>服务器<strong>必须</strong>在发送除 AUTH 外的其他任何MQTT包之前使用带有响应码 0x00（成功）的 CONNACK 包回复客户端</td></tr><tr><td>[MQTT-3.2.0-2]</td><td>服务器<strong>必须不</strong>在一次网络连接中发送超过一个 CONNACK 包</td></tr><tr><td>[MQTT-3.2.2-1]</td><td>Byte 1 是 “连接回复标识”。Bits 7-1 是保留字段，<strong>必须</strong>被置为 0</td></tr><tr><td>[MQTT-3.2.2-2]</td><td>如果服务器接收连接的全新开始标识被置为 1，服务器<strong>必须</strong>在带有 0x00（成功）的原因码的 CONNACK 包中将会话展示置为 0</td></tr><tr><td>[MQTT-3.2.2-3]</td><td>如果服务器接收到的连接中全新开始位被置为 0，且服务器持有对此客户端ID的会话状态，服务器<strong>必须</strong>在 CONNACK 包中将会话展示标识置为 1，其他情况下，服务器都<strong>必须</strong>在 CONNACK 包中将会话展示标识置为 0。这两种情况下服务器都<strong>必须</strong>在 CONNACK 中使用原因码 0x00（成功）</td></tr><tr><td>[MQTT-3.2.2-4]</td><td>如果客户端不持有会话状态，且接收到的会话展示值为 1，客户端<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.2.2-5]</td><td>如果客户端持有会话状态且收到的会话展示值为 0，如果客户端继续使用此网络连接，客户端<strong>必须</strong>丢弃会话状态</td></tr><tr><td>[MQTT-3.2.2-6]</td><td>如果服务器使用非 0 原因码的 CONNACK 包，服务器<strong>必须</strong>将会话展示的值置为 0</td></tr><tr><td>[MQTT-3.2.2-7]</td><td>如果服务器发送的 CONNACK 包带有一个值为 128 或更高的原因码，服务器<strong>必须</strong>随后关闭网络连接</td></tr><tr><td>[MQTT-3.2.2-8]</td><td>服务器发送的 CONNACK <strong>必须</strong>使用下述之一的原因码</td></tr><tr><td>[MQTT-3.2.2-9]</td><td>如果服务器不支持 QoS 1 或 QoS 2 的 PUBLISH，服务器<strong>必须</strong>发送一个带有其可以支持的最大QoS的 CONNACK 包</td></tr><tr><td>[MQTT-3.2.2-10]</td><td>一个不支持 QoS 1 或 QoS 2 PUBLISH 的服务器<strong>必须</strong>依然接收包含 QoS 0、1 或 2 的 SUBSCRIBE 包</td></tr><tr><td>[MQTT-3.2.2-11]</td><td>如果客户端从服务器接收了最大QoS，客户端<strong>必须不</strong>发送QoS等级超过最大QoS的 PUBLISH 包</td></tr><tr><td>[MQTT-3.2.2-12]</td><td>如果服务器收到包含超过其能力的遗嘱QoS的 CONNECT 数据包，服务器<strong>必须</strong>拒绝连接。服务器<strong>应该</strong>回复带有原因码 0x9B（不支持的 QoS）的 CONNACK 包，参考 [4.13] 错误处理，且随后<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.2.2-13]</td><td>如果服务器接收到的 CONNECT 包中包含遗嘱消息，且遗嘱保留消息的值为 1，同时服务器不支持保留消息，服务器<strong>必须</strong>拒绝此连接请求。服务器<strong>应该</strong>发送带有原因码 0x9A（不支持保留消息）的 CONNACK 且随后<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.2.2-14]</td><td>一个收到了服务器发送的保留消息可用值为 0 的客户端，<strong>必须不</strong>发送带有保留消息标识为 1 的 PUBLISH 包</td></tr><tr><td>[MQTT-3.2.2-15]</td><td>客户端<strong>必须不</strong>向服务器发送超过最大包尺寸的数据包</td></tr><tr><td>[MQTT-3.2.2-16]</td><td>如果客户端使用长度为 0 的客户端ID连接，服务器<strong>必须</strong>使用带有分配的客户端ID的 CONNACK 回复。分配的客户端ID<strong>必须</strong>是一个当前所有会话都没有使用的全新ID</td></tr><tr><td>[MQTT-3.2.2-17]</td><td>客户端<strong>必须不</strong>能发送一个主题别名的值大于服务器设置的主题别名最大值的 PUBLISH 包</td></tr><tr><td>[MQTT-3.2.2-18]</td><td>如果主题别名最大值未设置或值为 0，客户端<strong>必须不</strong>向服务器发送主题别名</td></tr><tr><td>[MQTT-3.2.2-19]</td><td>如果因为添加原因字符串会导致 CONNACK 的包尺寸超过了客户端限制的最大包尺寸，服务器<strong>必须不</strong>发送此属性</td></tr><tr><td>[MQTT-3.2.2-20]</td><td>如果添加该属性会导致 CONNACK 的包尺寸大于客户端设置的最大包尺寸，服务器<strong>必须不</strong>添加此属性</td></tr><tr><td>[MQTT-3.2.2-21]</td><td>如果服务器在 CONNACK 中发送了服务器保活时间，客户端<strong>必须</strong>使用此值代替其在 CONNECT 中发送的保活时间</td></tr><tr><td>[MQTT-3.2.2-22]</td><td>如果服务器没有设置服务器保活时间，服务器<strong>必须</strong>使用客户端在 CONNECT 包中设置的保活时间</td></tr><tr><td>[MQTT-3.3.1-1]</td><td>当客户端或服务器尝试重传 PUBLISH 包时，他们<strong>必须</strong>把重复标志置为 1</td></tr><tr><td>[MQTT-3.3.1-2]</td><td>对于 QoS 0 的消息，重复标识<strong>必须</strong>被置为 0</td></tr><tr><td>[MQTT-3.3.1-3]</td><td>转发的 PUBLISH 包的重复标识独立于接收的 PUBLISH 包，此值仅被本次转发包是否为重传独立决定</td></tr><tr><td>[MQTT-3.3.1-4]</td><td>PUBLISH 包<strong>必须不</strong>能将 QoS 的两个 bit 都设置为 1</td></tr><tr><td>[MQTT-3.3.1-5]</td><td>当客户端向服务器发送的 PUBLISH 包中的保留消息被置为 1 时，服务器<strong>必须</strong>在此主题下保存此应用消息，替换任何已经存在的消息</td></tr><tr><td>[MQTT-3.3.1-6]</td><td>如果载荷为空，服务器照常处理，只不过该同名主题下现有的保留消息<strong>必须</strong>被移除，未来的订阅者也不会再收到保留消息</td></tr><tr><td>[MQTT-3.3.1-7]</td><td>带有空载荷的保留消息<strong>必须不</strong>被服务器作为保留消息存储</td></tr><tr><td>[MQTT-3.3.1-8]</td><td>如果客户端发送到服务器的 PUBLISH 包中的保留消息值为 0，服务器<strong>必须不</strong>将该消息作为保留消息存储且<strong>必须不</strong>删除或替换已经存在的保留消息</td></tr><tr><td>[MQTT-3.3.1-9]</td><td>如果保留消息处理值为 0，服务器<strong>必须</strong>将匹配订阅主题过滤器的保留消息发送给客户端</td></tr><tr><td>[MQTT-3.3.1-10]</td><td>如果保留消息处理值为 1，当该订阅之前不存在时，服务器<strong>必须</strong>将匹配订阅主题过滤器的保留消息发送给客户端，反之当该订阅之前存在时，服务器<strong>必须不</strong>发送保留消息</td></tr><tr><td>[MQTT-3.3.1-11]</td><td>如果保留消息处理值为 2，服务器<strong>必须不</strong>发送保留消息</td></tr><tr><td>[MQTT-3.3.1-12]</td><td>如果保留消息引用发布的值为 0，服务器<strong>必须</strong>在转发应用消息时将保留消息值置为 0，无论其收到的 PUBLISH 包中的保留消息值如何设置</td></tr><tr><td>[MQTT-3.3.1-13]</td><td>如果保留消息引用发布的值为 1，服务器<strong>必须</strong>使用和收到的 PUBLISH 包中保留消息值相同的保留消息值</td></tr><tr><td>[MQTT-3.3.2-1]</td><td>主题名称<strong>必须</strong>作为 PUBLISH 包可变头的第一个字段。他<strong>必须</strong>采用 <code>UTF-8字符串</code> 编码</td></tr><tr><td>[MQTT-3.3.2-2]</td><td>PUBLISH 包中的主题名称<strong>必须不</strong>包含通配符</td></tr><tr><td>[MQTT-3.3.2-3]</td><td>服务器发往客户端的 PUBLISH 包中的主题名称必须匹配订阅者的主题过滤器</td></tr><tr><td>[MQTT-3.3.2-4]</td><td>服务器<strong>必须</strong>将载荷格式标识原封不动的发送给所有应用消息的接收者</td></tr><tr><td>[MQTT-3.3.2-5]</td><td>当该字段存在时，此四字节的值表示以秒为单位的应用消息生命时间。如果消息过期间隔已经超时，且服务器尚未设法开始向前传递到匹配的订阅者，服务器<strong>必须</strong>删除面向该订阅者的该消息的副本</td></tr><tr><td>[MQTT-3.3.2-6]</td><td>客户端发送给服务器的 PUBLISH 包中的消息过期间隔<strong>必须</strong>被设置为服务器接收的消息过期间隔的值减去消息在服务器中等待的时间</td></tr><tr><td>[MQTT-3.3.2-7]</td><td>接收者<strong>必须不</strong>能将主题别名从一个网络连接转发到另一个网络连接</td></tr><tr><td>[MQTT-3.3.2-8]</td><td>发送者<strong>必须不</strong>能发送一个包含主题别名值为 0 的 PUBLISH 包</td></tr><tr><td>[MQTT-3.3.2-9]</td><td>客户端<strong>必须不</strong>发送包含主题别名值超过服务器 CONNACK 中设置的主题别名最大值的 PUBLISH 包</td></tr><tr><td>[MQTT-3.3.2-10]</td><td>客户端<strong>必须</strong>接收所有大于 0 且小于或等于其 CONNECT 包中设置的主题别名最大值的主题别名</td></tr><tr><td>[MQTT-3.3.2-11]</td><td>服务器<strong>必须不</strong>发送包含主题别名值超过客户端 CONNECT 包中设置的主题别名最大值的 PUBLISH 包</td></tr><tr><td>[MQTT-3.3.2-12]</td><td>服务器<strong>必须</strong>接收所有大于 0 且小于等于其 CONNACK 包中设置的主题别名最大值的主题别名</td></tr><tr><td>[MQTT-3.3.2-13]</td><td>响应主题<strong>必须</strong>使用 <code>UTF-8字符串</code> 格式</td></tr><tr><td>[MQTT-3.3.2-14]</td><td>响应主题<strong>必须不</strong>包含通配符</td></tr><tr><td>[MQTT-3.3.2-15]</td><td>服务器<strong>必须</strong>向所有接收该应用消息的订阅者原封不动的转发响应主题</td></tr><tr><td>[MQTT-3.3.2-16]</td><td>服务器<strong>必须</strong>将关联数据原封不动的转发给接收应用消息的订阅者</td></tr><tr><td>[MQTT-3.3.2-17]</td><td>服务器<strong>必须</strong>将 PUBLISH 包中的所有用户属性原封不动的转发给客户端</td></tr><tr><td>[MQTT-3.3.2-18]</td><td>服务器<strong>必须</strong>在转发应用消息时维护用户属性的顺序</td></tr><tr><td>[MQTT-3.3.2-19]</td><td>内容类型<strong>必须</strong>是 <code>UTF-8字符串</code> 格式</td></tr><tr><td>[MQTT-3.3.2-20]</td><td>服务器<strong>必须</strong>将内容格式原封不动的转发给所有接收应用消息的订阅者</td></tr><tr><td>[MQTT-3.3.4-1]</td><td>PUBLISH 包的接收者<strong>必须</strong>使用 PUBLISH 包中 QoS 对应的方式响应此包</td></tr><tr><td>[MQTT-3.3.4-2]</td><td>在这种情况下服务器<strong>必须</strong>使用这些重叠订阅中最高的 QoS 等级来发布此数据</td></tr><tr><td>[MQTT-3.3.4-3]</td><td>如果客户端在重叠订阅时设置了订阅ID，服务器<strong>必须</strong>在为该订阅发布消息时将订阅ID放入消息中</td></tr><tr><td>[MQTT-3.3.4-4]</td><td>如果服务器发送该消息的单一副本，服务器<strong>必须</strong>将所有包含订阅ID的订阅动作的订阅ID放入 PUBLISH 包中，他们的顺序不重要</td></tr><tr><td>[MQTT-3.3.4-5]</td><td>如果服务器发送该消息的多个副本，服务器<strong>必须</strong>在每个副本中放入对应订阅动作的订阅ID</td></tr><tr><td>[MQTT-3.3.4-6]</td><td>从客户端发往服务器的 PUBLISH 包<strong>必须不</strong>携带订阅ID</td></tr><tr><td>[MQTT-3.3.4-7]</td><td>当客户端没有接收到足够的 PUBACK、PUBCOMP 或带有大于等于 128 原因码的 PUBREC 时，客户端<strong>必须不</strong>发送QoS 1 或 QoS 2 的 PUBLISH 包导致其需接收的返回数量超过接收最大值</td></tr><tr><td>[MQTT-3.3.4-8]</td><td>客户端不能延迟任何包的发送，除了因未收到接受回复而达到接收最大值因此未能发送的 PUBLISH 包</td></tr><tr><td>[MQTT-3.3.4-9]</td><td>当服务器没有接收到足够的 PUBACK、PUBCOMP 或带有大于等于 128 原因码的 PUBREC 时，服务器<strong>必须不</strong>发送QoS 1 或 QoS 2 的 PUBLISH 包导致其需接收的返回数量超过接收最大值</td></tr><tr><td>[MQTT-3.3.4-10]</td><td>服务器不能延迟任何包的发送，除了因未收到接受回复而达到接收最大值因此未能发送的 PUBLISH 包</td></tr><tr><td>[MQTT-3.4.2-1]</td><td>客户端或服务器发送的 PUBACK 包<strong>必须</strong>采用上述之一的 PUBACK 原因码</td></tr><tr><td>[MQTT-3.4.2-2]</td><td>如果添加此字段会导致 PUBACK 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.4.2-3]</td><td>如果添加此字段会导致 PUBACK 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.5.2-1]</td><td>客户端或服务器发送的 PUBREC 包<strong>必须</strong>采用上述之一的 PUBREC 原因码</td></tr><tr><td>[MQTT-3.5.2-2]</td><td>如果添加此字段会导致 PUBREC 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.5.2-3]</td><td>如果添加此字段会导致 PUBREC 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.6.1-1]</td><td>PUBREL 包固定头中的 Bit 3、2、1、0 为保留字段，其值必须被分别设置为 0、0、1、0。服务器<strong>必须</strong>将其他值视为格式错误的包并关闭网络连接</td></tr><tr><td>[MQTT-3.6.2-1]</td><td>客户端或服务器发送的 PUBREL 包<strong>必须</strong>采用上述之一的 PUBREL 原因码</td></tr><tr><td>[MQTT-3.6.2-2]</td><td>如果添加此字段会导致 PUBREL 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.6.2-3]</td><td>如果添加此字段会导致 PUBREL 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.7.2-1]</td><td>客户端或服务器发送的 PUBCOMP 包<strong>必须</strong>采用上述之一的 PUBCOMP 原因码</td></tr><tr><td>[MQTT-3.7.2-2]</td><td>如果添加此字段会导致 PUBCOMP 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.7.2-3]</td><td>如果添加此字段会导致 PUBCOMP 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.8.1-1]</td><td>SUBSCRIBE 包固定头中的 Bit 3、2、1、0 为保留字段，其值必须被分别设置为 0、0、1、0。服务器<strong>必须</strong>将其他值视为格式错误的包并关闭网络连接</td></tr><tr><td>[MQTT-3.8.3-1]</td><td>主题过滤器<strong>必须</strong>是一个 <code>UTF-8字符串</code></td></tr><tr><td>[MQTT-3.8.3-2]</td><td>载荷<strong>必须</strong>至少包含一个主题过滤器和订阅选项对</td></tr><tr><td>[MQTT-3.8.3-3]</td><td>订阅选项中的 Bit 2 表示非本地选项。如果其值为 1，服务器<strong>必须不</strong>将应用消息转发给与发布者客户端ID相同的订阅者</td></tr><tr><td>[MQTT-3.8.3-4]</td><td>在共享订阅中非本地选项值为 1 视为协议错误</td></tr><tr><td>[MQTT-3.8.3-5]</td><td>服务器<strong>必须</strong>将载荷中保留字段值非 0 的 SUBSCRIBE 包视为格式错误的包</td></tr><tr><td>[MQTT-3.8.4-1]</td><td>当服务器从客户端收到 SUBSCRIBE 包，服务器<strong>必须</strong>使用 SUBACK 响应</td></tr><tr><td>[MQTT-3.8.4-2]</td><td>SUBACK 中的包ID<strong>必须</strong>和其对应的 SUBSCRIBE 包中的包ID一致</td></tr><tr><td>[MQTT-3.8.4-3]</td><td>如果服务器接收到一个 SUBSCRIBE 包，其中包含的主题过滤器和现在会话中的一个订阅完全相同，服务器<strong>必须</strong>使用新订阅取代现有的订阅</td></tr><tr><td>[MQTT-3.8.4-4]</td><td>如果他的保留消息处理选项值为 0，且主题过滤器中现在有匹配的保留消息，服务器<strong>必须</strong>重新发送，但是服务器<strong>必须不</strong>能因为订阅的替换导致应用消息的丢失</td></tr><tr><td>[MQTT-3.8.4-5]</td><td>如果一个服务器接受的 SUBSCRIBE 包包含有多个订阅主题，服务器<strong>必须</strong>像接收了多个独立的 SUBSCRIBE 包一个逐个处理，唯一的不同是服务器将所有订阅请求的响应放入一个 SUBACK 包中回复</td></tr><tr><td>[MQTT-3.8.4-6]</td><td>服务器发往客户端的 SUBACK <strong>必须</strong>为每一个 主题过滤器&#x2F;订阅选项 对提供一个原因码</td></tr><tr><td>[MQTT-3.8.4-7]</td><td>这个原因码<strong>必须</strong>提供服务器为此次订阅分配的最大QoS或是指明本次订阅失败</td></tr><tr><td>[MQTT-3.8.4-8]</td><td>发送给订阅者的应用消息中的QoS<strong>必须</strong>是原始 PUBLISH 包中的QoS和服务器分配的最大QoS两者中的较小值</td></tr><tr><td>[MQTT-3.9.2-1]</td><td>如果添加此字段会导致 SUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.9.2-2]</td><td>如果添加此字段会导致 SUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.9.3-1]</td><td>SUBACK 中原因码的顺序<strong>必须</strong>与 SUBSCRIBE 中主题过滤器的顺序匹配</td></tr><tr><td>[MQTT-3.9.3-2]</td><td>服务器发送的 SUBACK 包<strong>必须</strong>对每个收到的主题过滤器使用上表列出的原因码进行回复</td></tr><tr><td>[MQTT-3.10.1-1]</td><td>UNSUBSCRIBE 包固定头中的 Bit 3、2、1、0 为保留字段，其值必须被分别设置为 0、0、1、0。服务器<strong>必须</strong>将其他值视为格式错误的包并关闭网络连接</td></tr><tr><td>[MQTT-3.10.3-1]</td><td>UNSUBSCRIBE 中的主题过滤器<strong>必须</strong>是 <code>UTF-8字符串</code></td></tr><tr><td>[MQTT-3.10.3-2]</td><td>UNSUBSCRIBE 包的载荷中<strong>必须</strong>至少包含一个主题过滤器</td></tr><tr><td>[MQTT-3.10.4-1]</td><td>服务器<strong>必须</strong>逐字符的核对 UNSUBSCRIBE 包中提供的主题过滤器（无论其是否包含通配符）是否与其持有的当前客户端的订阅相同。如果任何过滤器被精确匹配，那么其拥有的订阅<strong>必须</strong>被删除</td></tr><tr><td>[MQTT-3.10.4-2]</td><td>服务器<strong>必须</strong>停止向该主题过滤器添加新的发往客户端的消息</td></tr><tr><td>[MQTT-3.10.4-3]</td><td>服务器<strong>必须</strong>完成匹配该主题过滤器的，且已经开始发往客户端的 QoS 1 和 QoS 2 消息的交付</td></tr><tr><td>[MQTT-3.10.4-4]</td><td>服务器<strong>必须</strong>使用 UNSUBACK 包响应 UNSUBSCRIBE 请求</td></tr><tr><td>[MQTT-3.10.4-5]</td><td>UNSUBACK 包<strong>必须</strong>和 UNSUBSCRIBE 包有相同的包ID。即使没有主题订阅被删除，服务器也<strong>必须</strong>使用 UNSUBACK 回复</td></tr><tr><td>[MQTT-3.10.4-6]</td><td>如果服务器收到的 UNSUBSCIRIBE 包包含有多个主题过滤器，服务器<strong>必须</strong>按序处理就如同他按序逐个收到了 UNSUBSCRIBE 包，唯一不同是服务器仅需要使用一个 UNSUBACK 回复</td></tr><tr><td>[MQTT-3.11.2-1]</td><td>如果添加此字段会导致 UNSUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.11.2-2]</td><td>如果添加此字段会导致 UNSUBACK 的尺寸大于客户端的最大包尺寸，服务器<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.11.3-1]</td><td>UNSUBACK 包中的原因码顺序<strong>必须</strong>和 UNSUBSCRIBE 包中的主题过滤器顺序一致</td></tr><tr><td>[MQTT-3.11.3-2]</td><td>服务器发送的 UNSUBACK 包<strong>必须</strong>对每个收到的主题过滤器使用下表之一的原因码</td></tr><tr><td>[MQTT-3.12.4-1]</td><td>服务器<strong>必须</strong>发送 PINGRESP 包用来响应 PINGREQ 包</td></tr><tr><td>[MQTT-3.14.0-1]</td><td>服务器<strong>必须不</strong>发送 DISCONNECT 包，除非在其发送了一个原因码小于 0x80 的 CONNACK 之后</td></tr><tr><td>[MQTT-3.14.1-1]</td><td>客户端或服务器必须确认保留字段值为 0。如果非 0，客户端或服务器发送一个带有原因码 0x81（格式错误的包）的 DISCONNECT 包，参考 [4.13] 中的描述</td></tr><tr><td>[MQTT-3.14.2-1]</td><td>客户端或服务器发送的 DISCONNECT 包<strong>必须</strong>使用上表之一的断开原因码</td></tr><tr><td>[MQTT-3.14.2-2]</td><td>服务器发送的 DISCONNECT 包中<strong>必须不</strong>包括会话过期间隔</td></tr><tr><td>[MQTT-3.14.2-3]</td><td>如果添加此字段会导致 DISCONNECT 的尺寸大于接收者的最大包尺寸，发送者<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.14.2-4]</td><td>如果添加此字段会导致 DISCONNECT 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.14.4-1]</td><td>发送 DISCONNECT 后，发送方<strong>必须不</strong>在此网络连接中再发送任何 MQTT 包</td></tr><tr><td>[MQTT-3.14.4-2]</td><td>发送 DISCONNECT 后，发送方<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-3.14.4-3]</td><td>当接收到带有原因码 0x00（成功） 的 DISCONNECT 包后，服务器<strong>必须</strong>不发送改连接的遗嘱消息，并丢弃</td></tr><tr><td>[MQTT-3.15.1-1]</td><td>AUTH 包固定头中的 Bit 3、2、1、0 的内容保留且值必须为 0。客户端或服务器<strong>必须</strong>将任何其他值视为格式错误的包并断开网络连接</td></tr><tr><td>[MQTT-3.15.2-1]</td><td>AUTH 包的发送者<strong>必须</strong>使用下表之一的认证原因码</td></tr><tr><td>[MQTT-3.15.2-2]</td><td>如果添加此字段会导致 AUTH 的尺寸大于接收者的最大包尺寸，发送者<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-3.15.2-3]</td><td>如果添加此字段会导致 AUTH 的尺寸大于接收方的最大包尺寸，发送方<strong>必须不</strong>添加此字段</td></tr><tr><td>[MQTT-4.1.0-1]</td><td>客户端和服务器<strong>必须不</strong>在网络连接打开时丢弃会话状态</td></tr><tr><td>[MQTT-4.2.0-1]</td><td>客户端或服务器<strong>必须</strong>支持使用一种或多种底层传输协议，这些协议提供从客户端到服务器以及服务器到客户端的有序、无损的字节流。</td></tr><tr><td>[MQTT-4.1.0-2]</td><td>服务器<strong>必须</strong>在网络连接关闭且会话过期间隔到期后丢弃会话状态</td></tr><tr><td>[MQTT-4.3.1-1]</td><td>在 QoS 0 交付协议中，发送方<strong>必须</strong>发送 QoS 0 且重复标志值为 0 的 PUBLISH 包</td></tr><tr><td>[MQTT-4.3.2-1]</td><td>在 QoS 1 交付协议中，发送方<strong>必须</strong>在每次发布新消息时选择一个未被使用的包ID</td></tr><tr><td>[MQTT-4.3.2-2]</td><td>在 QoS 1 交付协议中，发送方<strong>必须</strong>发送包含此包ID，且重复标志值为 0 的 PUBLISH 包</td></tr><tr><td>[MQTT-4.3.2-3]</td><td>在 QoS 1 交付协议中，发送方<strong>必须</strong>将此 PUBLISH 包视为 “未回复的” 直到从接收方收到了正确的 PUBACK</td></tr><tr><td>[MQTT-4.3.2-4]</td><td>在 QoS 1 交付协议中，接收方<strong>必须</strong>使用包含 PUBLISH 包中包ID的 PUBACK 包进行响应，拥有收到的消息的所有权</td></tr><tr><td>[MQTT-4.3.2-5]</td><td>在 QoS 1 交付协议中，接收方在发送 PUBACK 包后，接收方<strong>必须</strong>将到来的带有相同包ID的 PUBLISH 包视为新的应用消息，无论其重复标志如何设置</td></tr><tr><td>[MQTT-4.3.3-1]</td><td>在 QoS 2 交付协议中，发送方<strong>必须</strong>在发布新消息时分配一个未使用的包ID</td></tr><tr><td>[MQTT-4.3.3-2]</td><td>在 QoS 2 交付协议中，发送方<strong>必须</strong>发送 QoS 2，重复标志值为 0，携带此包ID的 PUBLISH 包</td></tr><tr><td>[MQTT-4.3.3-3]</td><td>在 QoS 2 交付协议中，发送方<strong>必须</strong>在收到接收方发来的对应的 PUBREC 之前将此 PUBLISH 包视为 “未回复的”</td></tr><tr><td>[MQTT-4.3.3-4]</td><td>在 QoS 2 交付协议中，发送方<strong>必须</strong>在收到接收方发来的原因码小于 0x80 的 PUBREC 后，发送 PUBREL 包。此 PUBREL 包<strong>必须</strong>包含和原始 PUBLISH 包相同的包ID</td></tr><tr><td>[MQTT-4.3.3-5]</td><td>在 QoS 2 交付协议中，发送方<strong>必须</strong>在收到接收方发来的对应 PUBCOMP 之前将此 PUBREL 包视为 “未回复的”</td></tr><tr><td>[MQTT-4.3.3-6]</td><td>在 QoS 2 交付协议中，发送方<strong>必须不</strong>在发送 PUBREL 之后重发 PUBLISH 包</td></tr><tr><td>[MQTT-4.3.3-7]</td><td>在 QoS 2 交付协议中，发送方<strong>必须不</strong>在发送 PUBLISH 包之后使此应用消息过期</td></tr><tr><td>[MQTT-4.3.3-8]</td><td>在 QoS 2 交付协议中，接收方<strong>必须</strong>使用和收到 PUBLISH 包相同的包ID的 PUBREC 包响应，拥有收到的消息的所有权</td></tr><tr><td>[MQTT-4.3.3-9]</td><td>在 QoS 2 交付协议中，接收方如果已经使用带有 0x80 或更大值的原因码的 PUBREC 包回复，接收方<strong>必须</strong>将后续带有相同包ID的 PUBLISH 包视为新应用消息</td></tr><tr><td>[MQTT-4.3.3-10]</td><td>在 QoS 2 交付协议中，接收方直到收到对应的 PUBREL 包为止，接收方<strong>必须</strong>使用 PUBREC 回复后续任何带有相同包ID的 PUBLISH 包。在此情形下<strong>必须不</strong>把重复的包转发给更进一步的消息使用者</td></tr><tr><td>[MQTT-4.3.3-11]</td><td>在 QoS 2 交付协议中，接收方<strong>必须</strong>使用和收到 PUBREL 包相同的包ID的 PUBCOMP 包响应 PUBREL 包</td></tr><tr><td>[MQTT-4.3.3-12]</td><td>在 QoS 2 交付协议中，接收方发送 PUBCOMP 包之后，接收方<strong>必须</strong>将后续带有相同包ID的 PUBLISH 包视为新应用消息发送 PUBCOMP 包之后，接收方<strong>必须</strong>将后续带有相同包ID的 PUBLISH 包视为新应用消息</td></tr><tr><td>[MQTT-4.3.3-13]</td><td>在 QoS 2 交付协议中，接收方即使消息已经过期，也<strong>必须</strong>继续 QoS 2 的响应动作</td></tr><tr><td>[MQTT-4.4.0-1]</td><td>当客户端使用全新开始值为 0 重连且存在会话时，客户端和服务器都<strong>必须</strong>使用原始的包ID重传所有未确认的 PUBLISH 包（其 QoS &gt; 0）和 PUBREL 包。这是客户端或服务器<strong>需要</strong>重传消息的唯一场景。客户端和服务器<strong>必须不</strong>在其他任何时间重传消息</td></tr><tr><td>[MQTT-4.4.0-2]</td><td>如果接收到的 PUBACK 或 PUBREC 包含 0x80 或更大的原因代码，则相应的 PUBLISH 数据包将被视为已确认，且<strong>必须不</strong>被重传</td></tr><tr><td>[MQTT-4.5.0-1]</td><td>当服务器得到输入应用消息的所有权时，他<strong>必须</strong>把消息放入所有匹配订阅的客户端的会话状态</td></tr><tr><td>[MQTT-4.5.0-2]</td><td>无论何种情况，客户端<strong>必须</strong>按照匹配的 QoS 规则确认其收到包，无论客户端对包中的消息内容选择处理还是丢弃</td></tr><tr><td>[MQTT-4.6.0-1]</td><td>当客户端重传 PUBLISH 包时，其必须按照原始 PUBLISH 包的顺序发送（包括 QoS 1 和 QoS 2 消息）</td></tr><tr><td>[MQTT-4.6.0-2]</td><td>客户端<strong>必须</strong>按照接收 PUBLSIH 包的顺序发送 PUBACK 包（QoS 1 消息）</td></tr><tr><td>[MQTT-4.6.0-3]</td><td>客户端<strong>必须</strong>按照接收 PUBLSIH 包的顺序发送 PUBREC 包（QoS 2 消息）</td></tr><tr><td>[MQTT-4.6.0-4]</td><td>客户端<strong>必须</strong>按照接收 PUBREC 包的顺序发送 PUBREL 包（QoS 2 消息）</td></tr><tr><td>[MQTT-4.6.0-5]</td><td>当服务器处理发布到有序主题的消息时，服务器<strong>必须</strong>保证其对消费者发送的 PUBLISH 包（对于相同主题和相同 QoS）的顺序和服务器从客户端接收这些包时相同</td></tr><tr><td>[MQTT-4.6.0-6]</td><td>默认情况下，服务器在转发非共享订阅上的消息时<strong>必须</strong>将每个主题视为有序主题。</td></tr><tr><td>[MQTT-4.7.0-1]</td><td>通配符可以在主题过滤器中使用，但<strong>必须不</strong>在主题名称中使用</td></tr><tr><td>[MQTT-4.7.1-1]</td><td>多级通配符<strong>必须</strong>单独使用或在主题级别分隔符后使用。在任意情况下他都<strong>必须</strong>是主题过滤器中的最后一个字符</td></tr><tr><td>[MQTT-4.7.1-2]</td><td>当他被使用时，他<strong>必须</strong>占据过滤器中一个完整的级别</td></tr><tr><td>[MQTT-4.7.2-1]</td><td>服务器<strong>必须不</strong>将以通配符（# 或 +）开始的主题过滤器与以 $ 开头的主题名匹配</td></tr><tr><td>[MQTT-4.7.3-1]</td><td>所有的主题名称和主题过滤器<strong>必须</strong>至少包含一个字符</td></tr><tr><td>[MQTT-4.7.3-2]</td><td>主题名称和主题过滤器中必须不能包括 null 字符（Unicode U+0000）</td></tr><tr><td>[MQTT-4.7.3-3]</td><td>主题名称和主题过滤器是 <code>UTF-8字符串</code>；<strong>必须不</strong>超过 65535 字节</td></tr><tr><td>[MQTT-4.7.3-4]</td><td>当进行订阅匹配时，服务器<strong>必须不</strong>对主题名称或主题过滤器执行任何标准化处理，或对无法识别的字符进行任何修改或替换</td></tr><tr><td>[MQTT-4.8.2-1]</td><td>共享订阅的主题过滤器<strong>必须</strong>以 $share&#x2F; 开始且<strong>必须</strong>包括至少一字符的共享名称</td></tr><tr><td>[MQTT-4.8.2-2]</td><td>共享名称<strong>必须不</strong>包含字符 ‘&#x2F;‘、’+’、’#’，但<strong>必须</strong>在其后跟随 ‘&#x2F;‘ 字符。此 ‘&#x2F;‘ 字符后<strong>必须</strong>跟随主题过滤器</td></tr><tr><td>[MQTT-4.8.2-3]</td><td>服务器<strong>必须</strong>遵守客户端订阅时授予的 QoS 等级</td></tr><tr><td>[MQTT-4.8.2-4]</td><td>服务器<strong>必须</strong>在客户端重新连接时完成该消息的交付</td></tr><tr><td>[MQTT-4.8.2-5]</td><td>如果该客户端的会话在其重连成功前终止了，服务器<strong>必须不</strong>将此应用消息发送给其他的订阅客户端</td></tr><tr><td>[MQTT-4.8.2-6]</td><td>如果客户端使用带有 0x80 或更大原因码的 PUBACK 或 PUBREC 响应来自服务器的 PUBLISH 包，服务器<strong>必须</strong>丢弃应用消息，并且不再尝试将消息发给其他订阅者</td></tr><tr><td>[MQTT-4.9.0-1]</td><td>客户端或服务器<strong>必须</strong>将其发送配额初始化为不超过接收最大值的非零值</td></tr><tr><td>[MQTT-4.9.0-2]</td><td>每当客户端或服务器发送 QoS &gt; 0 的 PUBLISH 包，降低配额。如果发送配额值达到 0，客户端或服务器<strong>必须不</strong>再发送任何 QoS &gt; 0 的 PUBLISH 包</td></tr><tr><td>[MQTT-4.9.0-3]</td><td>即使配额值为 0，客户端和服务器<strong>必须</strong>继续处理和响应其他类型的 MQTT 包</td></tr><tr><td>[MQTT-4.12.0-1]</td><td>如果服务器不支持客户端提供的认证方式，服务器<strong>可以</strong>发送带有原因码 0x8C（认证方式错误）或原因码 0x87（未经授权）的 CONNACK 包，并<strong>必须</strong>关闭网络连接，参考 [4.13] 中的描述</td></tr><tr><td>[MQTT-4.12.0-2]</td><td>如果服务器需要额外信息来完成认证，他可以向客户端发送一个 AUTH 数据包。此数据包<strong>必须</strong>包含原因码 0x18（继续认证）</td></tr><tr><td>[MQTT-4.12.0-3]</td><td>客户端通过发送另一个 AUTH 包来响应来自服务器的 AUTH 包。此包必须包含原因码 0x18（继续认证）</td></tr><tr><td>[MQTT-4.12.0-4]</td><td>服务器可以在认证过程的任何点拒绝认证。他<strong>可以</strong>根据 [4.13] 的描述发送一个原因码为 0x80 或以上的 CONNACK 数据包，并<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-4.12.0-5]</td><td>如果初始 CONNECT 包包含认证方法，则所有 AUTH 包和任何成功的 CONNACK 包都必须包含和 CONNECT 包中相同值的 认证方法</td></tr><tr><td>[MQTT-4.12.0-6]</td><td>如果客户端没有在 CONNECT 包中包含认证方法，则服务器<strong>必须不</strong>发送 AUTH 包，也<strong>必须不</strong>在 CONNACK 包中包含认证方法</td></tr><tr><td>[MQTT-4.12.0-7]</td><td>如果客户端没有在 CONNECT 包中包含认证方法，则客户端<strong>必须不</strong>向服务器发送 AUTH 包</td></tr><tr><td>[MQTT-4.12.1-1]</td><td>如果客户端在 CONNECT 包中提供了认证方法，则可以在收到 CONNACK 后随时启动重新认证。通过发送原因码为 0x19（重新认证）的 AUTH 包来实现。客户端<strong>必须</strong>将认证方法设置为与最初用于认证网络连接的认证方法相同的值</td></tr><tr><td>[MQTT-4.12.1-2]</td><td>如果重新认证失败，客户端或服务器<strong>应该</strong>带有合适原因码的 DISCONNECT 包，且<strong>必须</strong>断开网络连接，参考 [4.13] 中的描述</td></tr><tr><td>[MQTT-4.13.1-1]</td><td>当服务器检测到格式错误的包或协议错误，且给出了规范中的原因码后，他<strong>必须</strong>断开网络连接</td></tr><tr><td>[MQTT-4.13.2-1]</td><td>CONNACK 和 DISCONNECT 包允许使用原因码为 0x80 或更高来指示网络连接将被关闭。如果指定了 0x80 或更高的原因码，则无论是否发送了 CONNACK 或 DISCONNECT 包，都<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-6.0.0-1]</td><td>MQTT 包<strong>必须</strong>在 WebSocket 二进制数据帧中发送。 如果收到任何其他类型的数据帧，接收方<strong>必须</strong>关闭网络连接</td></tr><tr><td>[MQTT-6.0.0-2]</td><td>单个 WebSocket 数据帧可以包含多个或部分 MQTT 包。 接收方不得假定 MQTT 包与 WebSocket 帧边界对齐</td></tr><tr><td>[MQTT-6.0.0-3]</td><td>客户端<strong>必须</strong>在其提供的 WebSocket 子协议列表中包含“mqtt”</td></tr><tr><td>[MQTT-6.0.0-4]</td><td>服务器选择并返回的 WebSocket 子协议名称<strong>必须</strong>为“mqtt”</td></tr></tbody></table><h1 id="附录-C-MQTT-v5-0-新特性汇总（非规范性）"><a href="#附录-C-MQTT-v5-0-新特性汇总（非规范性）" class="headerlink" title="附录 C. MQTT v5.0 新特性汇总（非规范性）"></a>附录 C. MQTT v5.0 新特性汇总（非规范性）</h1><p>下列新特性被引入了 MQTT v5.0</p><ul><li><p>会话过期机制<br>将 Clean Session 拆分为全新开始会话和会话过期间隔，全新开始会话指示是否应在不使用现有会话的情况下启动会话，会话过期间隔指示断开连接后保留会话的时间长短。会话过期间隔可以在断开连接时修改。将全新开始会话设置为 1 且将会话过期间隔设置为 0 等同于在 MQTT v3.1.1 中将 Clean Session 设置为 1。</p></li><li><p>消息过期<br>允许发布消息时设置过期时间。</p></li><li><p>所有 ACK 的原因码<br>将所有响应包都改为带有原因码的包。包括 CONNACK，PUBACK，PUBREL，PUBCOMP，SUBACK，UNSUBACK，DISCONNECT 和 AUTH。这使得调用者可以判断请求的函数是否成功。</p></li><li><p>所有 ACK 的原因字符串<br>将所有响应包都改为带有原因码的包，同时也允许带原因字符串。这被设计用于问题定位，且不应被接收者解析。</p></li><li><p>服务器断开<br>允许服务器发送 DISCONNECT 包以指示断开的原因。</p></li><li><p>载荷格式和内容类型<br>允许在发布消息时指定有效负载格式（二进制、文本）和 MIME 样式内容类型，这些被转发到消息的接收者。</p></li><li><p>请求&#x2F;响应<br>在 MQTT 中形式化请求&#x2F;响应模式，并提供响应主题和关联数据属性，以允许将响应消息路由回请求的发布者。另外，添加客户端从服务器获取有关如何构建响应主题的配置信息的功能。</p></li><li><p>共享订阅<br>添加共享订阅支持，实现消费者对订阅的负载均衡。</p></li><li><p>订阅ID<br>允许在 SUBSCRIBE 上指定数字订阅标识符，并在传递消息时在消息上返回该标识符。 这允许客户端确定哪个或哪些订阅导致消息被传递。</p></li><li><p>主题别名<br>通过允许主题名称映射为整数来减少 MQTT 数据包开销的大小。客户端和服务器独立指定它们允许的主题别名数量。</p></li><li><p>流量控制<br>允许客户端和服务器独立指定它们允许的未完成可靠消息的数量（QoS&gt;0）。发送方通过暂停发送使未处理消息总量低于此配额。这用于限制可靠消息的速率，并限制“正在处理”的消息数量。</p></li><li><p>用户属性<br>将用户属性添加到大多数包中。PUBLISH 上的用户属性包含在消息中，并由客户端应用程序定义。PUBLISH 和遗嘱属性集上的用户属性由服务器转发给消息的接收者。 CONNECT、SUBSCRIBE 和 UNSUBSCRIBE 数据包上的用户属性由服务器实现定义。 CONNACK、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBACK、UNSUBACK 和 AUTH 数据包上的用户属性由发送方定义，并且对于发送方实现而言是唯一的。MQTT 未定义用户属性的含义。</p></li><li><p>最大包尺寸<br>允许客户端和服务器各自独立选择能支持的最大包尺寸。会话的对端发送超过尺寸的包是一种错误。</p></li><li><p>可选的服务器特性<br>定义一组服务器不允许的功能，且提供了一种机制让服务器向客户端指定这些功能。可以使用这种方式选择的功能包括：最大QoS，保留消息可用，通配符订阅可用，订阅ID可用，共享订阅。当服务器宣称这些特性不可用后服务器使用这些功能是一种错误。</p></li></ul><p>在早期版本的 MQTT 中，服务器通过声明客户端无权限来避免这些未实现的功能。此功能允许这种可选行为被声明，并在客户端仍使用这些功能时添加对应的原因码。</p><ul><li><p>增强认证<br>提供了一种启用挑战&#x2F;响应式身份验证（包括双向认证）的机制。如果客户端和服务器都支持，则允许使用 SASL 风格的身份验证，并且客户端可以在连接中重新进行身份验证。</p></li><li><p>订阅选项<br>提供订阅选项，主要用于消息桥接应用程序。包括不发送源于自身的消息（非本地）（noLocal），如何处理保留消息（保留消息处理）。</p></li><li><p>遗嘱延迟<br>添加了指定连接结束和发送遗嘱消息之间延迟的功能。此功能旨在当会话的连接重新建立时不发送遗嘱消息。这允许短暂中断连接而无需通知其他人。</p></li><li><p>服务端保活<br>允许服务器指定希望客户端用作保活的值。这使服务器可以设置允许的最大保活时间，并确保客户端遵守该时间。</p></li><li><p>分配客户端ID<br>如果客户端ID是服务器分配的，返回分配的ID，这也解除了服务器分配的 ClientID 只能与 Clean Session&#x3D;1 连接一起使用的限制。</p></li><li><p>服务器引用<br>允许服务器在 CONNACK 或 DISCONNECT 上指定要使用的备用服务器，可以用作重定向或进行服务配置。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go轻量级事件库：gookit-event</title>
    <link href="/go%E8%BD%BB%E9%87%8F%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%BA%93%EF%BC%9Agookit-event.html"/>
    <url>/go%E8%BD%BB%E9%87%8F%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%BA%93%EF%BC%9Agookit-event.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目链接 <a href="https://github.com/gookit/event">gookit&#x2F;event</a></p></blockquote><span id="more"></span><p>项目介绍：</p><blockquote><p>Go实现的轻量级的事件管理、调度程序库, 支持设置监听器的优先级, 支持使用通配符来进行一组事件的监听</p><ul><li>支持自定义创建预定义的事件对象</li><li>支持对一个事件添加多个监听器</li><li>支持设置事件监听器的优先级，优先级越高越先触发</li><li>支持通过通配符 * 来进行一组事件的匹配监听.</li><li>ModeSimple - 注册 app.* 事件的监听，触发 app.run app.end 时，都将同时会触发 app.* 监听器</li><li>ModePath - NEW * 只匹配一段非 . 的字符,可以进行更精细的监听; ** 匹配任意多个字符,只能用于开头或结尾</li><li>支持直接使用通配符 * 来监听全部事件的触发</li><li>支持触发事件时投递到 chan, 异步进行消费处理. 触发: Async(), FireAsync()</li><li>完善的单元测试，单元覆盖率 &gt; 95%</li></ul></blockquote><p>我非常喜欢这种类型的项目，小巧、专注、恰到好处的feature。</p><p>当前这个项目可能没有经过足够的检验，可能存在一些bug，但是没有关系，他的代码足够简单，即便他产生了问题也可以轻松修复。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>库</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 特别篇：重构与事件循环</title>
    <link href="/translate-sol-bonus.html"/>
    <url>/translate-sol-bonus.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker-bonus/">Sol - An MQTT broker from scratch. Refactoring &amp; eventloop</a></p></blockquote><span id="more"></span><p><em><strong>更新日期: 2020-02-07</strong></em></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的六个部分中，我们探索了一些常见的 CS 主题，例如网络编程、数据结构，这段短暂的旅程的终点是得到了一个充满了BUG但是勉强可用的MQTT broker。</p><p>由于好奇心，我想测试一下我们的项目离真正的生产项目有多么接近，而且我想对项目进行一些重构，减少一些临时的代码，让项目的结构更加合理，同时关注项目的可移植性。</p><p>我不会把所有的重构过程都写到博客中，因为那会非常无聊，我只会突出一些最重要的部分，剩下的部分你可以直接把 <code>master</code> 分支合并到 <code>tutorial</code> 来查看，或者直接克隆 <code>master</code> 分支。</p><p>首先我按照有限度列出了需要优化的要点：</p><ul><li>低层的 I&#x2F;O 处理器，用以正确处理数据流读写</li><li>对 EPOLL 进行抽象，因为他是 Linux 独有功能，提供一些备选方案</li><li>管理加密消息，实现可用明文消息或加密消息的透明接口</li><li>正确处理客户端会话，实现类似 <code>&#39;+&#39;</code> 通配符之类的其他 MQTT 功能</li></ul><p><em>备注：虽然我们自己做的哈希表运行的不错，但我还是决定选择使用久经沙场的 <code>UTHASH</code> 库。由于他只有一个头文件，集成进我们的项目也非常容易。他的项目文档在<a href="https://troydhanson.github.io/uthash/">这里</a>。</em></p><h1 id="TCP分片问题"><a href="#TCP分片问题" class="headerlink" title="TCP分片问题"></a>TCP分片问题</h1><p>第一个也是最需要被检查的问题是网络通信，在本地进行负载测试时，我发现当负载量较大时程序开始丢包，或者说，内核缓冲区被淹没并开始对数据流进行分片。TCP 作为一个流协议，在处理数据中进行分片是无可厚非的，没有在一开始时就考虑这个问题显然是我比较幼稚，或者说因为我着急写一个可以运行的程序，忽略了底层细节。无论如何，这让程序产生了一些问题，例如解析错误的数据包，或者分片部分被当作数据包的第一个字节，识别成了各种不同的指令等等。</p><p>因此，最重要的修复之一是 <strong>server.c</strong> 模块中的 <code>recv_packet</code> 函数，特别是为每个客户端添加了类似状态机的行为，使其可以正确执行非阻塞读写，而不会阻塞线程。</p><p>我还将应用程序的核心部分，特别是 MQTT 抽象（例如客户端会话和主题）移到了 <code>sol_internal.h</code> 中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>sol_internal.h</span></div><code class="language-c"><span class="token comment">// 客户端行为可以被视为拥有四个状态的状态机：</span><span class="token comment">// - WAITING_HEADER 基础状态, 等待到来的第一字节数据头</span><span class="token comment">// - WAITING_LENGTH 第二个状态, 收到了头部但还没有收取全部的 remaing data</span><span class="token comment">// - WAITING_DATA 第三个状态, 基于 remaing data 判断还有多少剩余数据</span><span class="token comment">// - SENDING_DATA 最后一个状态, 已经收取了全部的数据包, 接下来判断是否需要返回数据包</span><span class="token keyword">enum</span> <span class="token class-name">client_status</span> <span class="token punctuation">&#123;</span>    WAITING_HEADER<span class="token punctuation">,</span>    WAITING_LENGTH<span class="token punctuation">,</span>    WAITING_DATA<span class="token punctuation">,</span>    SENDING_DATA<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 客户端链接的包装类, 客户端可以是订阅者或发布者, 可以拥有会话</span><span class="token comment">// 现在不再需要为每个客户端申请内存, 我在程序启动时初始化了一个客户端池, 当然, 读写 buffer 是使用时再申请的</span><span class="token comment">// 这是一个可以被哈希的结构, 参考 https://troydhanson.github.io/uthash/userguide.html</span><span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span>ctx<span class="token punctuation">;</span> <span class="token comment">// 事件循环上下文指针</span>    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>     <span class="token comment">// 持有处理的上一个消息的返回码</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span> <span class="token comment">// 当前状态</span>    <span class="token keyword">int</span> rpos<span class="token punctuation">;</span>   <span class="token comment">// 表示去除 Fixed Header, 数据包实际开始的位置</span>                <span class="token comment">// 因为收包时需要解析 Fixed Header 中变长的 Remaing Length, 不想在解包时再次解析</span>                <span class="token comment">// 就通过此字段记录</span>    <span class="token class-name">size_t</span> read<span class="token punctuation">;</span>  <span class="token comment">// 已经读取的字节数</span>    <span class="token class-name">size_t</span> toread<span class="token punctuation">;</span><span class="token comment">// 完成此数据包总共需要读取的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>rbuf<span class="token punctuation">;</span> <span class="token comment">// 读取 buffer</span>    <span class="token class-name">size_t</span> wrote<span class="token punctuation">;</span> <span class="token comment">// 已经写入的字节数</span>    <span class="token class-name">size_t</span> towrite<span class="token punctuation">;</span> <span class="token comment">// 还需写入的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>wbuf<span class="token punctuation">;</span>  <span class="token comment">// 写入 buffer</span>    <span class="token keyword">char</span> client_id<span class="token punctuation">[</span>MQTT_CLIENT_ID_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// MQTT 规范中的客户端 ID</span>    <span class="token keyword">struct</span> <span class="token class-name">connection</span> conn<span class="token punctuation">;</span> <span class="token comment">// 网络连接封装, 通过抽象接口支持普通连接或TLS连接</span>    <span class="token keyword">struct</span> <span class="token class-name">client_session</span> <span class="token operator">*</span>session<span class="token punctuation">;</span> <span class="token comment">// 客户端会话</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> last_seen<span class="token punctuation">;</span>  <span class="token comment">// 客户端上次活动的时间戳</span>    bool online<span class="token punctuation">;</span>  <span class="token comment">// 在线标识</span>    bool connected<span class="token punctuation">;</span> <span class="token comment">// 是否已经处理 CONNECT 包的标识</span>    bool has_lwt<span class="token punctuation">;</span> <span class="token comment">// 表示 CONNECT 包是否包含遗嘱 LWT（Last Will and Testament）</span>    bool clean_session<span class="token punctuation">;</span> <span class="token comment">// 表示是否设置了 clean_session 标识</span>    UT_hash_handle hh<span class="token punctuation">;</span> <span class="token comment">// UTHASH handle 处理器, 使用 UTHASH 的条件</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 每个客户端都持有一个会话, 用来缓存该客户端订阅的主题、失联时错过的消息(只有当 clean_session 为 false)、还有服务器已经发往客户端但没收到回复的消息(inflight messages)(这些消息都带有 message ID)</span><span class="token comment">// 基于MQTT协议, 最大的 mid (message ID) 数量为 65535, 所以 i_acks, i_msgs 和 in_i_acks 被初始化为这个尺寸</span><span class="token comment">// 这是一个可被哈希的结构体, APP可以追踪他完整的生命周期</span><span class="token keyword">struct</span> <span class="token class-name">client_session</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> next_free_mid<span class="token punctuation">;</span>                    <span class="token comment">// 下一个可用的 mid (message ID)</span>    List <span class="token operator">*</span>subscriptions<span class="token punctuation">;</span>                  <span class="token comment">// 客户端订阅的所有主题, 使用主题结构体存储</span>    List <span class="token operator">*</span>outgoing_msgs<span class="token punctuation">;</span>                  <span class="token comment">// 断开链接期间发往客户端的消息, 使用 mqtt_packet 指针存储</span>    bool has_inflight<span class="token punctuation">;</span>                    <span class="token comment">// 表示是否有 inflight 消息的标识</span>    bool clean_session<span class="token punctuation">;</span>                   <span class="token comment">// clean_session 标识</span>    <span class="token keyword">char</span> session_id<span class="token punctuation">[</span>MQTT_CLIENT_ID_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// session 中引用的 client_id</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_packet</span> lwt_msg<span class="token punctuation">;</span>           <span class="token comment">// 遗嘱消息, 由 CONNECT 设置, 可为空</span>    <span class="token keyword">struct</span> <span class="token class-name">inflight_msg</span> <span class="token operator">*</span>i_acks<span class="token punctuation">;</span>          <span class="token comment">// 需要被清理的离线ACK</span>    <span class="token keyword">struct</span> <span class="token class-name">inflight_msg</span> <span class="token operator">*</span>i_msgs<span class="token punctuation">;</span>          <span class="token comment">// 由于发送超时, 需要被重传的离线消息</span>    <span class="token keyword">struct</span> <span class="token class-name">inflight_msg</span> <span class="token operator">*</span>in_i_acks<span class="token punctuation">;</span>       <span class="token comment">// 需要被客户端清理的离线输入ACK</span>    UT_hash_handle hh<span class="token punctuation">;</span>                    <span class="token comment">// UTHASH handle 处理器, 使用 UTHASH 的条件</span>    <span class="token keyword">struct</span> <span class="token class-name">ref</span> refcount<span class="token punctuation">;</span>                  <span class="token comment">// 被引用计数, 用来共享此结构体</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>因此，客户端结构现在更加健壮，它存储每个数据包读写的状态，以便在内核空间出现 <code>EAGAIN</code> 错误时恢复。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>server.c</span></div><code class="language-c"><span class="token comment">// 客户端接收数据包</span><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">recv_packet</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ssize_t</span> nread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> opcode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> pktlen <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>    <span class="token comment">// 基础状态, 读头部</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>status <span class="token operator">==</span> WAITING_HEADER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 读取最初的2byte, 第一个byte应包含消息类型码</span>        nread <span class="token operator">=</span> <span class="token function">recv_data</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>rbuf <span class="token operator">+</span> c<span class="token operator">-></span>read<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">-</span> c<span class="token operator">-></span>read<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 异常视为断链</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EAGAIN <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EWOULDBLOCK <span class="token operator">&amp;&amp;</span> nread <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token punctuation">;</span>        <span class="token comment">// 不管是否全部读取完成, 记录已经读取的数量</span>        c<span class="token operator">-></span>read <span class="token operator">+=</span> nread<span class="token punctuation">;</span>        <span class="token comment">// 没有完全读取, 返回 EAGAIN</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">&amp;&amp;</span> c<span class="token operator">-></span>read <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>ERREAGAIN<span class="token punctuation">;</span>        <span class="token comment">// 完成进入下一阶段</span>        c<span class="token operator">-></span>status <span class="token operator">=</span> WAITING_LENGTH<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 头部已经读完, 已经了解消息类型, 接下来我们读取第2-4byte, 从第一个字节之后的三个字节可能会用来存储包长度</span>    <span class="token comment">// 当然, 除了 PINGRESP/PINGREQ 或 DISCONNECT, 他们没有 remaining length</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>status <span class="token operator">==</span> WAITING_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>read <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            opcode <span class="token operator">=</span> <span class="token operator">*</span>c<span class="token operator">-></span>rbuf <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">;</span>            <span class="token comment">// 数据包类型错误</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>DISCONNECT <span class="token operator">&lt;</span> opcode <span class="token operator">||</span> CONNECT <span class="token operator">></span> opcode<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token operator">-</span>ERRPACKETERR<span class="token punctuation">;</span>            <span class="token comment">// 数据包类型是 PINGRESP/PINGREQ 或 DISCONNECT, 无需后续处理(没有 remaining length)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>opcode <span class="token operator">></span> UNSUBSCRIBE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                c<span class="token operator">-></span>rpos <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                c<span class="token operator">-></span>toread <span class="token operator">=</span> c<span class="token operator">-></span>read<span class="token punctuation">;</span>                <span class="token keyword">goto</span> exit<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 总共读取至 4 byte</span>        <span class="token comment">// 译者觉得这里应该到 5</span>        nread <span class="token operator">=</span> <span class="token function">recv_data</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>rbuf <span class="token operator">+</span> c<span class="token operator">-></span>read<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">-</span> c<span class="token operator">-></span>read<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EAGAIN <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EWOULDBLOCK <span class="token operator">&amp;&amp;</span> nread <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token punctuation">;</span>        c<span class="token operator">-></span>read <span class="token operator">+=</span> nread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">&amp;&amp;</span> c<span class="token operator">-></span>read <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>ERREAGAIN<span class="token punctuation">;</span>        <span class="token comment">// 通过 remaining length 获得剩余部分的长度</span>        pktlen <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span>c<span class="token operator">-></span>rbuf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 超长异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pktlen <span class="token operator">></span> conf<span class="token operator">-></span>max_request_size<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>ERRMAXREQSIZE<span class="token punctuation">;</span>        <span class="token comment">// rpos 定位到头部和变长长度之后</span>        c<span class="token operator">-></span>rpos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 数据包总大小</span>        c<span class="token operator">-></span>toread <span class="token operator">=</span> pktlen <span class="token operator">+</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// pos = bytes used to store length</span>        <span class="token comment">// ACK 包无需继续读取</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pktlen <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">)</span>            <span class="token keyword">goto</span> exit<span class="token punctuation">;</span>        c<span class="token operator">-></span>status <span class="token operator">=</span> WAITING_DATA<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 读取完整的数据包字节</span>    nread <span class="token operator">=</span> <span class="token function">recv_data</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>rbuf <span class="token operator">+</span> c<span class="token operator">-></span>read<span class="token punctuation">,</span> c<span class="token operator">-></span>toread <span class="token operator">-</span> c<span class="token operator">-></span>read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EAGAIN <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EWOULDBLOCK <span class="token operator">&amp;&amp;</span> nread <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token punctuation">;</span>    c<span class="token operator">-></span>read <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">&amp;&amp;</span> c<span class="token operator">-></span>read <span class="token operator">&lt;</span> c<span class="token operator">-></span>toread<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERREAGAIN<span class="token punctuation">;</span>exit<span class="token operator">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 在接收链接或回复消息后使用此函数获取后续客户端输入的数据</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 我们必须接收一个完整的数据包</span>    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">recv_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 链接断开或收到了错误的数据包</span>    <span class="token comment">// TODO：设置一个处理 ERRMAXREQSIZE 的函数, 显示的提醒客户端故障</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>    <span class="token comment">// 表示阻塞, 需要继续读取</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>read <span class="token operator">&lt;</span> c<span class="token operator">-></span>toread<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERREAGAIN<span class="token punctuation">;</span>    <span class="token comment">// 记录</span>    info<span class="token punctuation">.</span>bytes_recv <span class="token operator">+=</span> c<span class="token operator">-></span>read<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 断开链接或故障</span>err<span class="token operator">:</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过网络连接向客户端发送数据流, 持续发送直到所有数据发送完成, 通过 towrite 字段跟踪</span><span class="token comment">// 当阻塞时返回 EAGAIN</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">write_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ssize_t</span> wrote <span class="token operator">=</span> <span class="token function">send_data</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>conn<span class="token punctuation">,</span> c<span class="token operator">-></span>wbuf<span class="token operator">+</span>c<span class="token operator">-></span>wrote<span class="token punctuation">,</span> c<span class="token operator">-></span>towrite<span class="token operator">-</span>c<span class="token operator">-></span>wrote<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EAGAIN <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EWOULDBLOCK <span class="token operator">&amp;&amp;</span> wrote <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token punctuation">;</span>    c<span class="token operator">-></span>wrote <span class="token operator">+=</span> wrote <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> wrote <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>wrote <span class="token operator">&lt;</span> c<span class="token operator">-></span>towrite <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EAGAIN<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERREAGAIN<span class="token punctuation">;</span>    <span class="token comment">// 发送成功 更新状态</span>    info<span class="token punctuation">.</span>bytes_sent <span class="token operator">+=</span> c<span class="token operator">-></span>towrite<span class="token punctuation">;</span>    <span class="token comment">// 重置记录数据</span>    c<span class="token operator">-></span>towrite <span class="token operator">=</span> c<span class="token operator">-></span>wrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="加密通讯"><a href="#加密通讯" class="headerlink" title="加密通讯"></a>加密通讯</h1><p>需要注意的是，<code>recv_packet</code> 和 <code>write_data</code> 是两个在 <strong>network.h</strong> 模块中定义的函数：</p><ul><li><code>ssize_t send_data(struct connection *, const unsigned char *, size_t)</code></li><li><code>ssize_t recv_data(struct connection *, unsigned char *, size_t)</code></li></ul><p>他们都需要使用 <code>struct connection</code> 作为第一个参数，后面两个参数就是常规的读&#x2F;写 buffer 和读&#x2F;写字节数。</p><p>这个连接结构直接针对了前言中需改进列表内的第三条（明文消息和加密消息的抽象），他是客户端链接的抽象实现，并且提供了管理通信所需的4个基本回调函数：</p><ul><li>accept</li><li>send</li><li>recv</li><li>close</li></ul><p>这个改进允许我们基于选择的类型创建每条链接，不论是普通链接还是TLS链接都使用相同的函数收发数据。</p><p>结构定义如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>network.h</span></div><code class="language-c"><span class="token comment">// 链接抽象结构，向外提供统一接口，根据传输层加密与否设置正确的回调函数</span><span class="token comment">// 四个主要的回调函数表示了可以在链接上进行的四种操作：</span><span class="token comment">// - accept</span><span class="token comment">// - read</span><span class="token comment">// - write</span><span class="token comment">// - close</span><span class="token comment">// 同时维护了 ip:port 信息</span><span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    SSL <span class="token operator">*</span>ssl<span class="token punctuation">;</span>    SSL_CTX <span class="token operator">*</span>ctx<span class="token punctuation">;</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>INET_ADDRSTRLEN <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>accept<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>send<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>recv<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>close<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>结构体中存储了 <code>SSL *</code> 和 <code>SSL_CTX *</code>，当我们使用普通链接时他们会为 <code>NULL</code>。</p><h1 id="编解码与辅助函数"><a href="#编解码与辅助函数" class="headerlink" title="编解码与辅助函数"></a>编解码与辅助函数</h1><p>另一个有益的提升是修正了之前错误的编码和解码函数（感谢<a href="https://beej.us/guide/bgnet/html/single/bgnet.html#serialization">beej networking guide</a>，这个教程真的很优秀）并且添加了一些工具函数用来处理整形和bytes的解码。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>pack.c</span></div><code class="language-c"><span class="token comment">// 整数解码</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">unpack_integer</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">char</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> val <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token char">'b'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'B'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'h'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token function">unpacki16</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'H'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token function">unpacku16</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'i'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token function">unpacki32</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'I'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token function">unpacku32</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'q'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token function">unpacki64</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">8</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'Q'</span><span class="token operator">:</span>            val <span class="token operator">=</span> <span class="token function">unpacku64</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>buf <span class="token operator">+=</span> <span class="token number">8</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    dest<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token operator">*</span>buf <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> dest<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="微型的事件循环：ev"><a href="#微型的事件循环：ev" class="headerlink" title="微型的事件循环：ev"></a>微型的事件循环：ev</h1><p>在单线程环境中抽象主机提供的多路复用API并不是一件困难的事，本质上就是提供一个数据结构，用来持有一组自定义事件。头文件里描述的很清楚，最重要的部分是我们对事件类型的枚举（<code>enum ev_type</code>），自定义事件（<code>struct ev</code>）和持有自定义事件的数组（<code>events_monitored</code>）。这些构成了我们的事件封装（<code>ev_ctx</code>）。</p><p><code>ev_ctx</code> 中使用不透明的 <code>void *</code> 指针可以让我们引用系统提供的任何底层 API，无论是 <code>EPOLL</code>、<code>SELECT</code> 还是 <code>KQUEUE</code>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>ev.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EV_OK</span>  <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EV_ERR</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">// 事件类型, 支持或运算</span><span class="token keyword">enum</span> <span class="token class-name">ev_type</span> <span class="token punctuation">&#123;</span>    EV_NONE       <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>    EV_READ       <span class="token operator">=</span> <span class="token number">0x01</span><span class="token punctuation">,</span>    EV_WRITE      <span class="token operator">=</span> <span class="token number">0x02</span><span class="token punctuation">,</span>    EV_DISCONNECT <span class="token operator">=</span> <span class="token number">0x04</span><span class="token punctuation">,</span>    EV_EVENTFD    <span class="token operator">=</span> <span class="token number">0x08</span><span class="token punctuation">,</span>    EV_TIMERFD    <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">,</span>    EV_CLOSEFD    <span class="token operator">=</span> <span class="token number">0x20</span>    <span class="token comment">// 停止循环, 关闭服务</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span><span class="token punctuation">;</span><span class="token comment">// 自定义事件, 存储与事件上下文的数组中</span><span class="token comment">// 携带有客户端信息, 被触发时执行对应的回调函数</span><span class="token keyword">struct</span> <span class="token class-name">ev</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">int</span> mask<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>rdata<span class="token punctuation">;</span> <span class="token comment">// 读取回调函数参数的不透明指针</span>    <span class="token keyword">void</span> <span class="token operator">*</span>wdata<span class="token punctuation">;</span> <span class="token comment">// 写入回调函数参数的不透明指针</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>rcallback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取回调函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>wcallback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写入回调函数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 事件循环上下文结构, 持有被监视的事件对象和指向后端事件引擎的指针</span><span class="token comment">// 当前我们仍然使用 epoll, 因为现在的线程模型与 select 默认的电平触发机制不是很适配</span><span class="token comment">// 对于单线程场景, 抽象select很容易</span><span class="token comment">// 现在由于 epoll 边缘触发 + 单次触发 机制，我们可以轻松的在多线程场景使用我们的事件循环</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> events_nr<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxfd<span class="token punctuation">;</span>                          <span class="token comment">// 最大监听fd数, events_monitored 的长度不得小于此数</span>    <span class="token keyword">int</span> stop<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxevents<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> fired_events<span class="token punctuation">;</span>    <span class="token comment">// 被触发事件数</span>    <span class="token keyword">struct</span> <span class="token class-name">ev</span> <span class="token operator">*</span>events_monitored<span class="token punctuation">;</span>        <span class="token comment">// 监控事件列表</span>    <span class="token keyword">void</span> <span class="token operator">*</span>api<span class="token punctuation">;</span>                          <span class="token comment">// 指向基于平台的事件引擎的指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ev_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ev_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 轮询 ev_ctx 中的事件, 无限阻塞或超时, 当有事件需要处理时返回</span><span class="token keyword">int</span> <span class="token function">ev_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">time_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用 ev_poll 再阻塞中轮询事件, 每轮中执行事件中对应的回调函数</span><span class="token keyword">int</span> <span class="token function">ev_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 触发停止事件</span><span class="token keyword">void</span> <span class="token function">ev_stop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 向循环队列尾部添加 fd, 和 ev_fire_event 相同只是没有回调函数</span><span class="token comment">// 可以用来添加 socket 监听之类的简单描述符</span><span class="token keyword">int</span> <span class="token function">ev_watch_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在循环中删除 fd, 虽然 close 调用足以从事件引擎中删除 fd, 但是还是用此调用封装来确保所有相关事件都被清理并设置为 EV_NONE</span><span class="token keyword">int</span> <span class="token function">ev_del_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注册一个新事件, 在功能上他和 ev_fire_event 相同但是此函数用于注册一个还未加入事件监听的fd</span><span class="token comment">// 此函数可以被集成到 ev_fire_event 中, 但是我还是倾向于保持语义分离</span><span class="token keyword">int</span> <span class="token function">ev_register_event</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span>                      <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注册一个周期性事件</span><span class="token keyword">int</span> <span class="token function">ev_register_cron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span>                     <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                     <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span>                     <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 为下一个循环周期的 FD 注册一个新事件</span><span class="token comment">// 和 ev_watch_fd相同, 但可以携带回调函数和参数</span><span class="token keyword">int</span> <span class="token function">ev_fire_event</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span>                  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在服务器初始化时，<code>ev_ctx</code> 会被注册一些基本的周期性事件和服务端口的 <code>on_accpet</code> 事件。之后我们的程序就由事件循环不停驱动，比如当客户端链接建立后，我们会对输入的数据进行监听，触发 <code>read_callback</code>，收到完整的数据包并处理后，决定是否要发送回复。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">                           MAIN THREAD                            [EV_CTX]  ACCEPT_CALLBACK         READ_CALLBACK         WRITE_CALLBACK-------------------    ------------------    --------------------         |                     |                       |      ACCEPT                   |                       |         | ------------------> |                       |         |               READ AND DECODE               |         |                     |                       |         |                     |                       |         |                  PROCESS                    |         |                     |                       |         |                     |                       |         |                     | --------------------> |         |                     |                     WRITE      ACCEPT                   |                       |         | ------------------> | &lt;-------------------- |         |                     |                       |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是一个连接客户端的生命周期，我们有一个 <code>accept</code> 回调函数，他将接入的链接放入事件循环中，并且开启读取监听：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>server.c</span></div><code class="language-c"><span class="token comment">// 处理输入的链接, 创建一个客户端对象并关联到fd</span><span class="token comment">// 设置为 EV_READ 事件并绑定 read_callback 用以处理输入的数据流</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">accept_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span>ctx<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> serverfd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接收一个新的连接, 将ip地址和fd配置给作为参数传入的conn结构</span>        <span class="token keyword">struct</span> <span class="token class-name">connection</span> conn<span class="token punctuation">;</span>        <span class="token function">connection_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conn<span class="token punctuation">,</span> conf<span class="token operator">-></span>tls <span class="token operator">?</span> server<span class="token punctuation">.</span>ssl_ctx <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">accept_connection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conn<span class="token punctuation">,</span> serverfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">close_connection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 创建一个客户端结构, 用来持有conn和ev_ctx</span>        <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">memorypool_alloc</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>conn <span class="token operator">=</span> conn<span class="token punctuation">;</span>        <span class="token function">client_init</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-></span>ctx <span class="token operator">=</span> ctx<span class="token punctuation">;</span>        <span class="token comment">// 客户端添加到读取循环中</span>        <span class="token function">ev_register_event</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> EV_READ<span class="token punctuation">,</span> read_callback<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 记录</span>        info<span class="token punctuation">.</span>nclients<span class="token operator">++</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span>nconnections<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">log_info</span><span class="token punctuation">(</span><span class="token string">"[%p] Connection from %s"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> conn<span class="token punctuation">.</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 读取数据包的回调, 每当客户端发来数据时由事件循环触发此函数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span>ctx<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 客户端传入自身作为回调参数</span>    <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token comment">// 状态机校验, 也意味着只要是 WAITING_* 状态都需要继续读取数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>status <span class="token operator">==</span> SENDING_DATA<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 从客户端获取数据, 按照协议可了解数据是否已经读取完全</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">read_data</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>            <span class="token comment">// 记录活跃时间</span>            c<span class="token operator">-></span>last_seen <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 置为 SENDING 状态, 后续根据处理器的处理决定是否要发送数据</span>            c<span class="token operator">-></span>status <span class="token operator">=</span> SENDING_DATA<span class="token punctuation">;</span>            <span class="token comment">// 后续解码 + 处理器处理</span>            <span class="token function">process_message</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token operator">:</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERRPACKETERR<span class="token operator">:</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERRMAXREQSIZE<span class="token operator">:</span>            <span class="token comment">// 客户端断开或数据错误</span>            <span class="token comment">// 断开连接、清理资源</span>            <span class="token function">log_error</span><span class="token punctuation">(</span><span class="token string">"Closing connection with %s (%s): %s"</span><span class="token punctuation">,</span>                      c<span class="token operator">-></span>client_id<span class="token punctuation">,</span> c<span class="token operator">-></span>conn<span class="token punctuation">.</span>ip<span class="token punctuation">,</span> <span class="token function">solerr</span><span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果有遗嘱则发布遗嘱</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>has_lwt <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> <span class="token operator">*</span>tname <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> c<span class="token operator">-></span>session<span class="token operator">-></span>lwt_msg<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>                <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">topic_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server<span class="token punctuation">,</span> tname<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>session<span class="token operator">-></span>lwt_msg<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 清理资源</span>            <span class="token function">ev_del_fd</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> c<span class="token operator">-></span>conn<span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 从主题中删除订阅</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>session <span class="token operator">&amp;&amp;</span> <span class="token function">list_size</span><span class="token punctuation">(</span>c<span class="token operator">-></span>session<span class="token operator">-></span>subscriptions<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token operator">*</span>subs <span class="token operator">=</span> c<span class="token operator">-></span>session<span class="token operator">-></span>subscriptions<span class="token punctuation">;</span>                <span class="token function">list_foreach</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> subs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">log_debug</span><span class="token punctuation">(</span><span class="token string">"Deleting %s from topic %s"</span><span class="token punctuation">,</span>                              c<span class="token operator">-></span>client_id<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token punctuation">)</span> item<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">topic_del_subscriber</span><span class="token punctuation">(</span>item<span class="token operator">-></span>data<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">client_deactivate</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            info<span class="token punctuation">.</span>nclients<span class="token operator">--</span><span class="token punctuation">;</span>            info<span class="token punctuation">.</span>nconnections<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERREAGAIN<span class="token operator">:</span>            <span class="token function">ev_fire_event</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> c<span class="token operator">-></span>conn<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> EV_READ<span class="token punctuation">,</span> read_callback<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 此函数仅当客户端已经发送符合MQTT协议长度的完整字节流后才被调用</span><span class="token comment">// 此函数使用事件循环基于收到的数据包类型做出反应, 在传入处理器前进行校验。</span><span class="token comment">// 此函数根据处理器的输出结果, 在事件队列中加入回复事件, 或重置客户端继续监听输入事件</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process_message</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span>ctx<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// io.data 是 mqtt_packet 类型</span>    <span class="token keyword">struct</span> <span class="token class-name">io_event</span> io <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>client <span class="token operator">=</span> c <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 将收到的数据解码为mqtt包</span>    <span class="token function">mqtt_unpack</span><span class="token punctuation">(</span>c<span class="token operator">-></span>rbuf <span class="token operator">+</span> c<span class="token operator">-></span>rpos<span class="token punctuation">,</span> <span class="token operator">&amp;</span>io<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token operator">*</span>c<span class="token operator">-></span>rbuf<span class="token punctuation">,</span> c<span class="token operator">-></span>read <span class="token operator">-</span> c<span class="token operator">-></span>rpos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 重置读取标识</span>    c<span class="token operator">-></span>toread <span class="token operator">=</span> c<span class="token operator">-></span>read <span class="token operator">=</span> c<span class="token operator">-></span>rpos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 使用对应的处理器处理</span>    c<span class="token operator">-></span>rc <span class="token operator">=</span> <span class="token function">handle_command</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>data<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token operator">&amp;</span>io<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token operator">-></span>rc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 回复处理</span>        <span class="token keyword">case</span> REPLY<span class="token operator">:</span>        <span class="token keyword">case</span> MQTT_NOT_AUTHORIZED<span class="token operator">:</span>        <span class="token keyword">case</span> MQTT_BAD_USERNAME_OR_PASSWORD<span class="token operator">:</span>            <span class="token comment">// 向客户端发送数据</span>            <span class="token function">enqueue_event_write</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 释放资源</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>data<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type <span class="token operator">!=</span> PUBLISH<span class="token punctuation">)</span>                <span class="token function">mqtt_packet_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">// 断链处理</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token operator">:</span>            <span class="token function">ev_del_fd</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> c<span class="token operator">-></span>conn<span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">client_deactivate</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>            info<span class="token punctuation">.</span>nclients<span class="token operator">--</span><span class="token punctuation">;</span>            info<span class="token punctuation">.</span>nconnections<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERRNOMEM<span class="token operator">:</span>            <span class="token function">log_error</span><span class="token punctuation">(</span><span class="token function">solerr</span><span class="token punctuation">(</span>c<span class="token operator">-></span>rc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            c<span class="token operator">-></span>status <span class="token operator">=</span> WAITING_HEADER<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>data<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type <span class="token operator">!=</span> PUBLISH<span class="token punctuation">)</span>                <span class="token function">mqtt_packet_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 写入事件触发的回调函数, 阻塞可重发, 发完后重置状态机, 并加入读取事件监听</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">write_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span>ctx<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>client <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token comment">// 发送数据</span>    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">write_data</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token comment">// OK</span>            <span class="token comment">// 开启读取监听</span>            client<span class="token operator">-></span>status <span class="token operator">=</span> WAITING_HEADER<span class="token punctuation">;</span>            <span class="token function">ev_fire_event</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> client<span class="token operator">-></span>conn<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> EV_READ<span class="token punctuation">,</span> read_callback<span class="token punctuation">,</span> client<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">// 阻塞重发</span>        <span class="token keyword">case</span> <span class="token operator">-</span>ERREAGAIN<span class="token operator">:</span>            <span class="token function">enqueue_event_write</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">log_info</span><span class="token punctuation">(</span><span class="token string">"Closing connection with %s (%s): %s %i"</span><span class="token punctuation">,</span>                     client<span class="token operator">-></span>client_id<span class="token punctuation">,</span> client<span class="token operator">-></span>conn<span class="token punctuation">.</span>ip<span class="token punctuation">,</span>                     <span class="token function">solerr</span><span class="token punctuation">(</span>client<span class="token operator">-></span>rc<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ev_del_fd</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> client<span class="token operator">-></span>conn<span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">client_deactivate</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Update stats</span>            info<span class="token punctuation">.</span>nclients<span class="token operator">--</span><span class="token punctuation">;</span>            info<span class="token punctuation">.</span>nconnections<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然，启动的服务器必须进行阻塞调用以启动事件循环，我们也需要一个停止机制。得益于 ev_stop API，添加一个额外的事件例程来在我们想要停止运行的循环时调用变得非常简单。</p><p>现在我们的服务器会使用一个阻塞的循环来提供服务，但是我们也需要一个停止机制。感谢 <code>ev_stop</code> 接口，他这让我们可以简单的停止循环。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>server.c</span></div><code class="language-c"><span class="token comment">// 循环停止事件的回调函数, 由 EV_CLOSEFD 触发</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stop_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> <span class="token operator">*</span>ctx<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>    <span class="token function">ev_stop</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 事件循环启动函数, 是对 epoll 或者其他多路复用机制的抽象</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eventloop_start</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sfd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">ev_ctx</span> ctx<span class="token punctuation">;</span>    <span class="token function">ev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">,</span> EVENTLOOP_MAX_EVENTS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 注册停止事件</span>    <span class="token function">ev_register_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">,</span> conf<span class="token operator">-></span>run<span class="token punctuation">,</span> EV_CLOSEFD<span class="token operator">|</span>EV_READ<span class="token punctuation">,</span> stop_handler<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用网络服务端口注册 accept_callback</span>    <span class="token function">ev_register_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">,</span> sfd<span class="token punctuation">,</span> EV_READ<span class="token punctuation">,</span> accept_callback<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 注册周期性事件</span>    <span class="token function">ev_register_cron</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">,</span> publish_stats<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> conf<span class="token operator">-></span>stats_pub_interval<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ev_register_cron</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">,</span> inflight_msg_check<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9e8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 开始循环, 阻塞线程</span>    <span class="token function">ev_run</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ev_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 添加一个写入事件监听, 用来向客户端发送数据</span><span class="token keyword">void</span> <span class="token function">enqueue_event_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ev_fire_event</span><span class="token punctuation">(</span>c<span class="token operator">-></span>ctx<span class="token punctuation">,</span> c<span class="token operator">-></span>conn<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> EV_WRITE<span class="token punctuation">,</span> write_callback<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最终，我们的 <code>start_server</code> 函数，作为程序的入口，他会监听一个端口，并打开事件循环来提供服务。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>server.c</span></div><code class="language-c"><span class="token comment">// 服务入口, 传入地址和端口开始工作</span><span class="token keyword">int</span> <span class="token function">start_server</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Sol 全局对象初始化</span>    <span class="token function">trie_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>topics<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>authentications <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>pool <span class="token operator">=</span> <span class="token function">memorypool_new</span><span class="token punctuation">(</span>BASE_CLIENTS_NUM<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">client</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>clients_map <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>sessions <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>wildcards <span class="token operator">=</span> <span class="token function">list_new</span><span class="token punctuation">(</span>wildcard_destructor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>conf<span class="token operator">-></span>allow_anonymous <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token function">config_read_passwd_file</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>password_file<span class="token punctuation">,</span> <span class="token operator">&amp;</span>server<span class="token punctuation">.</span>authentications<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 服务器状态主题</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SYS_TOPICS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">topic_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server<span class="token punctuation">,</span> <span class="token function">topic_new</span><span class="token punctuation">(</span><span class="token function">xstrdup</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 监听网络端口</span>    <span class="token keyword">int</span> sfd <span class="token operator">=</span> <span class="token function">make_listen</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> port<span class="token punctuation">,</span> conf<span class="token operator">-></span>socket_family<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化SSL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>conf<span class="token operator">-></span>tls <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">openssl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>ssl_ctx <span class="token operator">=</span> <span class="token function">create_ssl_context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">load_certificates</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>ssl_ctx<span class="token punctuation">,</span> conf<span class="token operator">-></span>cafile<span class="token punctuation">,</span> conf<span class="token operator">-></span>certfile<span class="token punctuation">,</span> conf<span class="token operator">-></span>keyfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">log_info</span><span class="token punctuation">(</span><span class="token string">"Server start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>start_time <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 开启事件循环</span>    <span class="token function">eventloop_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>sfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">AUTH_DESTROY</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>authentications<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_destroy</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>wildcards<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放SSL资源</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>conf<span class="token operator">-></span>tls <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SSL_CTX_free</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>ssl_ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">openssl_cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">log_info</span><span class="token punctuation">(</span><span class="token string">"Sol v%s exiting"</span><span class="token punctuation">,</span> VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正如你看到的，这里有一个用于创建客户端池的 <code>memorypool_new</code>，我们预先分配了一定数量的客户端，并且在断开链接时回收他们。只要我们的客户端内容是懒加载的，特别是他们的读写buffer（可能是 MB 级别）是懒加载的，那么我们这个客户端池就相当划算。</p><p>当然，这只是整个过程的一小部分，但最终我做出了一个相当不错的原型。下一步将是进行一些压力测试，看看它与 Mosquitto 或 Mosca 这些久经考验且无可争议的优秀软件相比如何。我们仍然缺少许多功能，例如用于存储会话的持久层，但先贼发布&#x2F;订阅部分应该是可测试的。希望这个教程可以作为更整洁和精心设计的项目的起点。再见！</p>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 第六部分：处理器</title>
    <link href="/translate-sol-6.html"/>
    <url>/translate-sol-6.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker-p6/">Sol - An MQTT broker from scratch. Part 6 - Handlers</a></p></blockquote><span id="more"></span><p>这一部分我们会重点关注 <strong>处理器（handler）</strong> 的实现，每种处理器用来处理一种对应的MQTT包。就像我们在第四部分中已经描述的，我们把处理器放在一个固定长度的数组里，每个处理器的索引恰好是包的MQTT类型。</p><h1 id="业务封装"><a href="#业务封装" class="headerlink" title="业务封装"></a>业务封装</h1><p>在我们开始主要工作之前，我们先补充一些前几章缺失的业务代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/core.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"trie.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hashtable.h"</span></span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    List <span class="token operator">*</span>subscribers<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// sol的主体结构, 服务器运行时会产生一个全局实例</span><span class="token comment">// 包括了所有连接的客户端、闭包和主题树</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token punctuation">&#123;</span>    HashTable <span class="token operator">*</span>clients<span class="token punctuation">;</span>    HashTable <span class="token operator">*</span>closures<span class="token punctuation">;</span>    Trie topics<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 在客户端中使用的session, 保存该客户端订阅的所有主题</span><span class="token keyword">struct</span> <span class="token class-name">session</span> <span class="token punctuation">&#123;</span>    List <span class="token operator">*</span>subscriptions<span class="token punctuation">;</span>    <span class="token comment">// TODO add pending confirmed messages</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 客户端包装</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>client_id<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">session</span> session<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 将客户端包装成订阅者, 之后由主题保存订阅者列表</span><span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> qos<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>client<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 主题创建、订阅发布的一系列方法</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token function">topic_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">topic_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">topic_add_subscriber</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">topic_del_subscriber</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">,</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sol_topic_put</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sol_topic_del</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过主题名称获得主题</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token function">sol_topic_get</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这部分主要实现了客户端和服务端交互的各种抽象：</p><ul><li>客户端（client）结构体，用来表示已经建立连接的客户端</li><li>主题（topic）结构体</li><li>订阅者（subscriber）结构体</li><li>会话结（session）构体，表示客户端持有的会话，仅当 <code>clean session</code> 选项为 <code>false</code> 时生效</li><li>sol结构体，全局运行实例，用来持有上述的所有内容</li><li>一些方便的辅助函数</li></ul><p>这里是上述定义的实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/core.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"core.h"</span></span><span class="token comment">// 传入两个订阅者, 比较其客户端id</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compare_cid</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>c1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span><span class="token punctuation">)</span> c1<span class="token punctuation">)</span><span class="token operator">-></span>client<span class="token operator">-></span>client_id<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span><span class="token punctuation">)</span> c2<span class="token punctuation">)</span><span class="token operator">-></span>client<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建一个topic对象</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token function">topic_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">topic_init</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">topic_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    t<span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    t<span class="token operator">-></span>subscribers <span class="token operator">=</span> <span class="token function">list_create</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向主题对象内添加一个订阅者</span><span class="token keyword">void</span> <span class="token function">topic_add_subscriber</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>client<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> qos<span class="token punctuation">,</span> bool cleansession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span>sub <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>sub<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sub<span class="token operator">-></span>client <span class="token operator">=</span> client<span class="token punctuation">;</span>    sub<span class="token operator">-></span>qos <span class="token operator">=</span> qos<span class="token punctuation">;</span>    t<span class="token operator">-></span>subscribers <span class="token operator">=</span> <span class="token function">list_push</span><span class="token punctuation">(</span>t<span class="token operator">-></span>subscribers<span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果cleansession置为false，必须将此订阅加入会话</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cleansession<span class="token punctuation">)</span>        client<span class="token operator">-></span>session<span class="token punctuation">.</span>subscriptions <span class="token operator">=</span> <span class="token function">list_push</span><span class="token punctuation">(</span>client<span class="token operator">-></span>session<span class="token punctuation">.</span>subscriptions<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 主题取消客户端订阅</span><span class="token keyword">void</span> <span class="token function">topic_del_subscriber</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>client<span class="token punctuation">,</span> bool cleansession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">list_remove_node</span><span class="token punctuation">(</span>t<span class="token operator">-></span>subscribers<span class="token punctuation">,</span> client<span class="token punctuation">,</span> compare_cid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// TODO remomve in case of cleansession == false</span><span class="token punctuation">&#125;</span><span class="token comment">// 向sol设置主题</span><span class="token keyword">void</span> <span class="token function">sol_topic_put</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token operator">*</span>sol<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">trie_insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token operator">-></span>topics<span class="token punctuation">,</span> t<span class="token operator">-></span>name<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向sol删除主题</span><span class="token keyword">void</span> <span class="token function">sol_topic_del</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token operator">*</span>sol<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">trie_delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token operator">-></span>topics<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 查询获得一个主题</span><span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span><span class="token function">sol_topic_get</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol</span> <span class="token operator">*</span>sol<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>ret_topic<span class="token punctuation">;</span>    <span class="token function">trie_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token operator">-></span>topics<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>ret_topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret_topic<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="处理器实现"><a href="#处理器实现" class="headerlink" title="处理器实现"></a>处理器实现</h1><p><code>处理器（Handlers）</code> 是一系列会在 <code>on_read</code> 中被执行的回调函数，就像他们的名称暗示的一样，他们负责处理客户端输入的数据，之后他们选择性的创建或不创建一个回复数据，并且返回一个指示下一步应该如何处理的返回值。返回值可以是：</p><ul><li><code>REARM_W</code>，表示将下一个触发函数设置为 <code>on_write</code>，并提供需要发送到客户端的数据</li><li><code>REARM_R</code>，表示没有需要回复客户端的数据，可以继续将触发函数重置为 <code>on_read</code>，继续等待客户端数据</li><li><code>-REARM_W</code>，这个状态码没有被协议定义，我们在这里用来表示客户端断开链接或者故障发生</li></ul><h2 id="CONNECT-处理器"><a href="#CONNECT-处理器" class="headerlink" title="CONNECT 处理器"></a>CONNECT 处理器</h2><p>按照顺序，我们先来实现 <code>connect_handler</code>，顾名思义，他用来处理客户端完成TCP链接之后发来的第一个数据包，也就是 <code>CONNECT</code> 包。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">connect_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当一个已存在的客户端又发送了 CONNECT 包, 被视为违背协议</span>    <span class="token comment">// 因此断开链接</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hashtable_exists</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>clients<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Received double CONNECT from %s, disconnecting client"</span><span class="token punctuation">,</span>                 pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 关闭链接, 释放资源</span>        <span class="token function">close</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 哈希表删除时的回调会负责销毁 client 或者 cb</span>        <span class="token function">hashtable_del</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>clients<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">hashtable_del</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>closures<span class="token punctuation">,</span> cb<span class="token operator">-></span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 更新状态</span>        info<span class="token punctuation">.</span>nclients<span class="token operator">--</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span>nconnections<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>REARM_W<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"New client connected as %s (c%i, k%u)"</span><span class="token punctuation">,</span>             pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">,</span>             pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>clean_session<span class="token punctuation">,</span>             pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>keepalive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加新链接</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>new_client <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>new_client<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_client<span class="token operator">-></span>fd <span class="token operator">=</span> cb<span class="token operator">-></span>fd<span class="token punctuation">;</span>    <span class="token comment">// 由客户端保证cid的唯一性, 比如可以用mac地址</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">;</span>    new_client<span class="token operator">-></span>client_id <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>cid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hashtable_put</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>clients<span class="token punctuation">,</span> cid<span class="token punctuation">,</span> new_client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 clinet 绑定到闭包</span>    cb<span class="token operator">-></span>obj <span class="token operator">=</span> new_client<span class="token punctuation">;</span>    <span class="token comment">// 使用 CONNACK回复</span>    <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>response <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 高位赋值</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte <span class="token operator">=</span> CONNACK_BYTE<span class="token punctuation">;</span>    <span class="token comment">// clean_session == false 表示此链接支持保存 session</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>clean_session <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token comment">// 所以需要在会话中初始化订阅列表</span>        new_client<span class="token operator">-></span>session<span class="token punctuation">.</span>subscriptions <span class="token operator">=</span> <span class="token function">list_create</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// TODO 处理确实存在session的情况</span>    <span class="token comment">// 这里暂时是简单的返回 session 不存在</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> session_present <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> connect_flags <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token punctuation">(</span>session_present <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 0 表示接收链接</span>    <span class="token comment">// 完成组包</span>    response<span class="token operator">-></span>connack <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">mqtt_packet_connack</span><span class="token punctuation">(</span>byte<span class="token punctuation">,</span> connect_flags<span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 包编码成数据流</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> CONNACK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> p<span class="token punctuation">,</span> MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending CONNACK to %s (%u, %u)"</span><span class="token punctuation">,</span>              pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">,</span>              session_present<span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 标记之后发送</span>    <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们严格按照协议规范实现了处理器行为，除了 <strong>clean session</strong> 标识的处理，对于有会话的客户端该如何重连这件事我们暂时忽略了。如果一个客户端传入了两次 CONNECT，按照协议规范我们会断开他的链接。正常情况下我们会记录客户端，制作一个 CONNACK 数据流，并且返回 <code>REARM_W</code>，让 <code>on_write</code> 可以把我们的数据流发送回客户端。</p><h2 id="DISCONNECT-处理器"><a href="#DISCONNECT-处理器" class="headerlink" title="DISCONNECT 处理器"></a>DISCONNECT 处理器</h2><p>下一个包，<code>DISCONNECT</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">disconnect_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获得客户端</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>c <span class="token operator">=</span> cb<span class="token operator">-></span>obj<span class="token punctuation">;</span>    <span class="token comment">// 执行删除动作</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received DISCONNECT from %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hashtable_del</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>clients<span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hashtable_del</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>closures<span class="token punctuation">,</span> cb<span class="token operator">-></span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 跟新状态</span>    info<span class="token punctuation">.</span>nclients<span class="token operator">--</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>nconnections<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// TODO 在该客户端订阅的所有主题中删除对其的引用</span>    <span class="token keyword">return</span> <span class="token operator">-</span>REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们做了最简单的处理：日志记录、关闭 fd、从哈希表中删除、更新信息，然后返回一个负值。</p><h2 id="SUBSCRIBE-UNSUBSCRIBE-处理器"><a href="#SUBSCRIBE-UNSUBSCRIBE-处理器" class="headerlink" title="SUBSCRIBE UNSUBSCRIBE 处理器"></a>SUBSCRIBE UNSUBSCRIBE 处理器</h2><p><code>SUBSCRIBE</code> 的处理器则是一个更加有意思的操作，在这里我们需要用到我们的 <strong>特里树</strong>，大概流程如下：</p><ul><li>迭代传入的主题元组（包括 tpoic，QoS），对每一个主题进行如下操作：<ul><li>如果主题不存在，我们创建该主题</li><li>将客户端加入该主题的订阅者列表</li><li>如果主题以 <code>#</code> 结尾，我们需要让客户端订阅该主题以及该主题所有的下级节点，由于特里树的数据结构设计，这个操作可以轻松的递归处理</li><li>如果 <code>clean_session</code> 标识的值为 <code>false</code>，我们需要给客户端添加一个会话，这里我们还没有完全实现</li></ul></li><li>使用 <code>SUBACK</code> 回应</li></ul><p>在 <code>UNSUBSCRIBE</code> 中也没有什么意外，只要在主题中删除客户端，然后使用 <code>UNSUBACK</code> 回应即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// 用递归方式来订阅一个节点所有子节点的辅助函数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">recursive_subscription</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node <span class="token operator">||</span> <span class="token operator">!</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>child <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> child<span class="token punctuation">;</span> child <span class="token operator">=</span> child<span class="token operator">-></span>next<span class="token punctuation">)</span>        <span class="token function">recursive_subscription</span><span class="token punctuation">(</span>child<span class="token operator">-></span>data<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t <span class="token operator">=</span> node<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span>s <span class="token operator">=</span> arg<span class="token punctuation">;</span>    t<span class="token operator">-></span>subscribers <span class="token operator">=</span> <span class="token function">list_push</span><span class="token punctuation">(</span>t<span class="token operator">-></span>subscribers<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// SUBSCRIBE 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">subscribe_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>c <span class="token operator">=</span> cb<span class="token operator">-></span>obj<span class="token punctuation">;</span>    bool wildcard <span class="token operator">=</span> false<span class="token punctuation">;</span>          <span class="token comment">// 标记是否通配</span>    bool alloced <span class="token operator">=</span> false<span class="token punctuation">;</span>           <span class="token comment">// 表示有新 malloc 的string, 用完需要释放</span>    <span class="token comment">// 在 SUBACK 中使用和 SUB 同样的主题顺序回复的 QoS List</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> rcs<span class="token punctuation">[</span>pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples_len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// SUBSCRIBE 包含了主题和QoS的列表, 此处循环处理</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples_len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received SUBSCRIBE from %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获得单个元组的主题字符串和QoS</span>        <span class="token keyword">char</span> <span class="token operator">*</span>topic <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic<span class="token punctuation">;</span>        <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"\t%s (QoS %i)"</span><span class="token punctuation">,</span> topic<span class="token punctuation">,</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>qos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当使用 /# 结尾时, 标记通配</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>topic<span class="token punctuation">[</span>pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'#'</span> <span class="token operator">&amp;&amp;</span>            topic<span class="token punctuation">[</span>pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            topic <span class="token operator">=</span> <span class="token function">remove_occur</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wildcard <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>topic<span class="token punctuation">[</span>pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果不以 / 结尾, 添加 /</span>            topic <span class="token operator">=</span> <span class="token function">append_string</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            alloced <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 通过 topic 字符串找到对象</span>        <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">sol_topic_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">,</span> topic<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当没有找到对象时, 创建并添加到特里树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            t <span class="token operator">=</span> <span class="token function">topic_create</span><span class="token punctuation">(</span><span class="token function">strdup</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sol_topic_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wildcard <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span>sub <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>sub<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sub<span class="token operator">-></span>client <span class="token operator">=</span> cb<span class="token operator">-></span>obj<span class="token punctuation">;</span>            sub<span class="token operator">-></span>qos <span class="token operator">=</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>qos<span class="token punctuation">;</span>            <span class="token comment">// 让该节点和所有子节点都拥有表示此客户端的 subscriber</span>            <span class="token function">trie_prefix_map_tuple</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">.</span>topics<span class="token punctuation">,</span> topic<span class="token punctuation">,</span> recursive_subscription<span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 暂时都使用 cleansession = true</span>        <span class="token comment">// 译者觉得在通配符的情况下这里会到这 topic 对应的节点产生两个 subscriber</span>        <span class="token function">topic_add_subscriber</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> cb<span class="token operator">-></span>obj<span class="token punctuation">,</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>qos<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>alloced<span class="token punctuation">)</span>            <span class="token function">free</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>        rcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>qos<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 制作 suback</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_suback</span> <span class="token operator">*</span>suback <span class="token operator">=</span> <span class="token function">mqtt_packet_suback</span><span class="token punctuation">(</span>SUBACK_BYTE<span class="token punctuation">,</span>                                                    pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>pkt_id<span class="token punctuation">,</span>                                                    rcs<span class="token punctuation">,</span>                                                    pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复用pkt</span>    <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> SUBSCRIBE<span class="token punctuation">)</span><span class="token punctuation">;</span>    pkt<span class="token operator">-></span>suback <span class="token operator">=</span> <span class="token operator">*</span>suback<span class="token punctuation">;</span>    <span class="token comment">// 制作数据流并发出</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> SUBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> MQTT_HEADER_LEN <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples_len<span class="token punctuation">;</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> SUBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>suback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending SUBACK to %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// UNSUBSCRIBE 处理器 这里没做实际处理, 只是正确回复ACK</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">unsubscribe_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>c <span class="token operator">=</span> cb<span class="token operator">-></span>obj<span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received UNSUBSCRIBE from %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    pkt<span class="token operator">-></span>ack <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span>UNSUBACK_BYTE<span class="token punctuation">,</span> pkt<span class="token operator">-></span>unsubscribe<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending UNSUBACK to %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="PUBLISH-处理器"><a href="#PUBLISH-处理器" class="headerlink" title="PUBLISH 处理器"></a>PUBLISH 处理器</h2><p>PUBLISH 处理器会比我们前面写的几个内容多一些，但是十分好理解：</p><ul><li>如果发布的主题不存在, 则创建</li><li>基于消息的 QoS 设置，使用正确的 ACK 回复：<ul><li>QoS0：至多一次，不回复</li><li>QoS1：至少一次，使用 PUBACK 回复</li><li>QoS2：确保一次，使用 PUBREC 回复</li></ul></li><li>向该主题的订阅者转发该消息，转发的 QoS 值应该是由消息的 QoS 决定，但不能大于接收方设置的最大 QoS 值</li></ul><p><img src="/translate-sol-6/QoS2-sample.png" alt="Broker 接收一条 QoS2 的消息，并向 QoS1 的订阅者转发"></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// PUBLISH 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">publish_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>c <span class="token operator">=</span> cb<span class="token operator">-></span>obj<span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received PUBLISH from %s (d%i, q%u, r%i, m%u, %s, ... (%i bytes))"</span><span class="token punctuation">,</span>              c<span class="token operator">-></span>client_id<span class="token punctuation">,</span>              pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>dup<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos<span class="token punctuation">,</span>              pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>retain<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">,</span>              pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payloadlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 数据记录</span>    info<span class="token punctuation">.</span>messages_recv<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>topic <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>    bool alloced <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// 标记字符串空间是分配的</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> qos <span class="token operator">=</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos<span class="token punctuation">;</span>    <span class="token comment">// 保证所有的主题都是用 / 结尾</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>topic<span class="token punctuation">[</span>pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topiclen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        topic <span class="token operator">=</span> <span class="token function">append_string</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        alloced <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获得或创建基于该 kye 的 topic 对象</span>    <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">sol_topic_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">,</span> topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        t <span class="token operator">=</span> <span class="token function">topic_create</span><span class="token punctuation">(</span><span class="token function">strdup</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_topic_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>alloced <span class="token operator">==</span> true<span class="token punctuation">)</span>        <span class="token function">free</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> publen<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>pub<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> t<span class="token operator">-></span>subscribers<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        publen <span class="token operator">=</span> MQTT_HEADER_LEN <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span>            pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topiclen <span class="token operator">+</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payloadlen<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span>sub <span class="token operator">=</span> cur<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>sc <span class="token operator">=</span> sub<span class="token operator">-></span>client<span class="token punctuation">;</span>        <span class="token comment">// 将 QoS 设置为订阅者的 QoS （此处为方便设计，并未完全遵循协议）</span>        pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">=</span> sub<span class="token operator">-></span>qos<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">></span> AT_MOST_ONCE<span class="token punctuation">)</span>            publen <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remaininglen_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>publen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x200000</span><span class="token punctuation">)</span>            remaininglen_offset <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>publen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x4000</span><span class="token punctuation">)</span>            remaininglen_offset <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>publen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x80</span><span class="token punctuation">)</span>            remaininglen_offset <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        publen <span class="token operator">+=</span> remaininglen_offset<span class="token punctuation">;</span>        <span class="token comment">// 发送给该订阅者的 PUB 包</span>        pub <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBLISH<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ssize_t</span> sent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sent <span class="token operator">=</span> <span class="token function">send_bytes</span><span class="token punctuation">(</span>sc<span class="token operator">-></span>fd<span class="token punctuation">,</span> pub<span class="token punctuation">,</span> publen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">sol_error</span><span class="token punctuation">(</span><span class="token string">"Error publishing to %s: %s"</span><span class="token punctuation">,</span>                      sc<span class="token operator">-></span>client_id<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 记录信息</span>        info<span class="token punctuation">.</span>bytes_sent <span class="token operator">+=</span> sent<span class="token punctuation">;</span>        <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PUBLISH to %s (d%i, q%u, r%i, m%u, %s, ... (%i bytes))"</span><span class="token punctuation">,</span>                  sc<span class="token operator">-></span>client_id<span class="token punctuation">,</span>                  pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>dup<span class="token punctuation">,</span>                  pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos<span class="token punctuation">,</span>                  pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>retain<span class="token punctuation">,</span>                  pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">,</span>                  pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">,</span>                  pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payloadlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        info<span class="token punctuation">.</span>messages_sent<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pub<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 至少一次 使用ACK回复</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>qos <span class="token operator">==</span> AT_LEAST_ONCE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mqtt_puback <span class="token operator">*</span>puback <span class="token operator">=</span> <span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span>PUBACK_BYTE<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBLISH<span class="token punctuation">)</span><span class="token punctuation">;</span>        pkt<span class="token operator">-></span>ack <span class="token operator">=</span> <span class="token operator">*</span>puback<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>        cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PUBACK to %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>qos <span class="token operator">==</span> EXACTLY_ONCE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 确保一次 使用 PUBREC 回复</span>        <span class="token comment">// TODO 需要通过一个哈希表记录已经处于 PUBREC 状态的客户端+包id</span>        mqtt_pubrec <span class="token operator">*</span>pubrec <span class="token operator">=</span> <span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span>PUBREC_BYTE<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBLISH<span class="token punctuation">)</span><span class="token punctuation">;</span>        pkt<span class="token operator">-></span>ack <span class="token operator">=</span> <span class="token operator">*</span>pubrec<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBREC<span class="token punctuation">)</span><span class="token punctuation">;</span>        cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PUBREC to %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 至多一次 无需回复</span>    <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBLISH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> REARM_R<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="ACK-PINGREQ-处理器"><a href="#ACK-PINGREQ-处理器" class="headerlink" title="ACK PINGREQ 处理器"></a>ACK PINGREQ 处理器</h2><p>只剩下 ACK 处理器了，他们基本上都是一样的。现在我们只做基本的日志和回复，以后我们再来实现基于 QoS 的业务机制。</p><p>还有 PINGREQ 处理器，这是客户端用来确认链接状态的心跳报文，我们只需要用 PINGRESP 回复即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// PUBACK 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">puback_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received PUBACK from %s"</span><span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// TODO 基于QoS机制, 将该数据移出需重传列表</span>    <span class="token keyword">return</span> REARM_R<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// PUBREC 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pubrec_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>c <span class="token operator">=</span> cb<span class="token operator">-></span>obj<span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received PUBREC from %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 按照协议使用 RELEASE 回复 RECIVE</span>    mqtt_pubrel <span class="token operator">*</span>pubrel <span class="token operator">=</span> <span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span>PUBREL_BYTE<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    pkt<span class="token operator">-></span>ack <span class="token operator">=</span> <span class="token operator">*</span>pubrel<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBREC<span class="token punctuation">)</span><span class="token punctuation">;</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PUBREL to %s"</span><span class="token punctuation">,</span> c<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// PUBREL 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pubrel_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received PUBREL from %s"</span><span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 按照协议使用 COMPLETE 回复 RELEASE</span>    mqtt_pubcomp <span class="token operator">*</span>pubcomp <span class="token operator">=</span> <span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span>PUBCOMP_BYTE<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    pkt<span class="token operator">-></span>ack <span class="token operator">=</span> <span class="token operator">*</span>pubcomp<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PUBCOMP<span class="token punctuation">)</span><span class="token punctuation">;</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PUBCOMP to %s"</span><span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// PUBCOMP 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pubcomp_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received PUBCOMP from %s"</span><span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// TODO 基于 QoS 机制将其从待确认列表移出</span>    <span class="token keyword">return</span> REARM_R<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// PINGREQ 处理器</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pingreq_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Received PINGREQ from %s"</span><span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 按照协议使用 PINGRESP 回复</span>    pkt<span class="token operator">-></span>header <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">mqtt_packet_header</span><span class="token punctuation">(</span>PINGRESP_BYTE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span>pkt<span class="token punctuation">,</span> PINGRESP<span class="token punctuation">)</span><span class="token punctuation">;</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token function">bytestring_create</span><span class="token punctuation">(</span>MQTT_HEADER_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> MQTT_HEADER_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PINGRESP to %s"</span><span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> REARM_W<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在我们的 broker 已经具有基本的功能，很快就可以和其他的 MQTT 工具联调测试，例如使用 <code>mosquitto_sub</code> 和 <code>mosquitto_pub</code> 或 Python 中的 <code>paho-mqtt</code>。</p><h1 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>我们需要一个配置模块来设置各种参数，使用最经典的键值对的方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><div class="caption"><span>conf/sol.conf</span></div><code class="language-conf"># Sol configuration file, uncomment and edit desired configuration# Network configuration# Uncomment ip_address and ip_port to set socket family to TCP, if unix_socket# is set, UNIX family socket will be used# ip_address 127.0.0.1# ip_port 9090unix_socket &#x2F;tmp&#x2F;sol.sock# Logging configuration# Could be either DEBUG, INFO&#x2F;INFORMATION, WARNING, ERRORlog_level DEBUGlog_path &#x2F;tmp&#x2F;sol.log# Max memory to be used, after which the system starts to reclaim memory by# freeing older items storedmax_memory 2GB# Max memory that will be allocated for each requestmax_request_size 50MB# TCP backlog, size of the complete connection queuetcp_backlog 128# Interval of time between one stats publish on $SOL topics and the subsequentstats_publish_interval 10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="配置模块定义"><a href="#配置模块定义" class="headerlink" title="配置模块定义"></a>配置模块定义</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/config.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment">// 默认参数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VERSION</span>                     <span class="token string">"0.0.1"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_SOCKET_FAMILY</span>       <span class="token expression">INET</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_LOG_LEVEL</span>           <span class="token expression">DEBUG</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_LOG_PATH</span>            <span class="token string">"/tmp/sol.log"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_CONF_PATH</span>           <span class="token string">"/etc/sol/sol.conf"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_HOSTNAME</span>            <span class="token string">"127.0.0.1"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_PORT</span>                <span class="token string">"1883"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_MAX_MEMORY</span>          <span class="token string">"2GB"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_MAX_REQUEST_SIZE</span>    <span class="token string">"2MB"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_STATS_INTERVAL</span>      <span class="token string">"10s"</span></span><span class="token keyword">struct</span> <span class="token class-name">config</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* Sol version &lt;MAJOR.MINOR.PATCH> */</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>version<span class="token punctuation">;</span>    <span class="token comment">/* Eventfd to break the epoll_wait loop in case of signals */</span>    <span class="token keyword">int</span> run<span class="token punctuation">;</span>    <span class="token comment">/* Logging level, to be set by reading configuration */</span>    <span class="token keyword">int</span> loglevel<span class="token punctuation">;</span>    <span class="token comment">/* Epoll wait timeout, define even the number of times per second that the       system will check for expired keys */</span>    <span class="token keyword">int</span> epoll_timeout<span class="token punctuation">;</span>    <span class="token comment">/* Socket family (Unix domain or TCP) */</span>    <span class="token keyword">int</span> socket_family<span class="token punctuation">;</span>    <span class="token comment">/* Log file path */</span>    <span class="token keyword">char</span> logpath<span class="token punctuation">[</span><span class="token number">0xFF</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* Hostname to listen on */</span>    <span class="token keyword">char</span> hostname<span class="token punctuation">[</span><span class="token number">0xFF</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* Port to open while listening, only if socket_family is INET,     * otherwise it's ignored */</span>    <span class="token keyword">char</span> port<span class="token punctuation">[</span><span class="token number">0xFF</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* Max memory to be used, after which the system starts to reclaim back by     * freeing older items stored */</span>    <span class="token class-name">size_t</span> max_memory<span class="token punctuation">;</span>    <span class="token comment">/* Max memory request can allocate */</span>    <span class="token class-name">size_t</span> max_request_size<span class="token punctuation">;</span>    <span class="token comment">/* TCP backlog size */</span>    <span class="token keyword">int</span> tcp_backlog<span class="token punctuation">;</span>    <span class="token comment">/* Delay between every automatic publish of broker stats on topic */</span>    <span class="token class-name">size_t</span> stats_pub_interval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 全局配置对象</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">config</span> <span class="token operator">*</span>conf<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">config_set_default</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">config_print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">config_load</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">time_to_string</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">memory_to_string</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>配置项目无需过多解释，都可以通过名称了解其作用。</p><h2 id="配置模块实现"><a href="#配置模块实现" class="headerlink" title="配置模块实现"></a>配置模块实现</h2><p>配置项主要是使用工具将配置文件的字符串信息解析成配置对象的值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/config.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/eventfd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"network.h"</span></span><span class="token comment">// 全局对象</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">config</span> config<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">config</span> <span class="token operator">*</span>conf<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">llevel</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>lname<span class="token punctuation">;</span>    <span class="token keyword">int</span> loglevel<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">llevel</span> lmap<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span><span class="token string">"DEBUG"</span><span class="token punctuation">,</span> DEBUG<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"WARNING"</span><span class="token punctuation">,</span> WARNING<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"ERROR"</span><span class="token punctuation">,</span> ERROR<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"INFO"</span><span class="token punctuation">,</span> INFORMATION<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"INFORMATION"</span><span class="token punctuation">,</span> INFORMATION<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 解析带单位的内存配置</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">read_memory_with_mul</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>memory_string<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 解析数字部分</span>    <span class="token class-name">size_t</span> num <span class="token operator">=</span> <span class="token function">parse_int</span><span class="token punctuation">(</span>memory_string<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mul <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 指针指向单位</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>memory_string<span class="token punctuation">)</span><span class="token punctuation">)</span> memory_string<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 通过单位获得乘系数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span>memory_string<span class="token punctuation">,</span> <span class="token string">"kb"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mul <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span>memory_string<span class="token punctuation">,</span> <span class="token string">"mb"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mul <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span>memory_string<span class="token punctuation">,</span> <span class="token string">"gb"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mul <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num <span class="token operator">*</span> mul<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 解析带单位的时间配置(默认秒)</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">read_time_with_mul</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>time_string<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> num <span class="token operator">=</span> <span class="token function">parse_int</span><span class="token punctuation">(</span>time_string<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mul <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>time_string<span class="token punctuation">)</span><span class="token punctuation">)</span> time_string<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token operator">*</span>time_string<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token char">'m'</span><span class="token operator">:</span>            mul <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>            mul <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            mul <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> num <span class="token operator">*</span> mul<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将内存数字转为人类易读的字符串 例如  1024 => 1Kb</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">memory_to_string</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> memory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> numlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> translated_memory <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>mstring <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>memory <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        translated_memory <span class="token operator">=</span> memory<span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数字 + 'b'</span>        mstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>mstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"%db"</span><span class="token punctuation">,</span> translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>memory <span class="token operator">&lt;</span> <span class="token number">1048576</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        translated_memory <span class="token operator">=</span> memory <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// + "Kb"</span>        mstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>mstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"%dKb"</span><span class="token punctuation">,</span> translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>memory <span class="token operator">&lt;</span> <span class="token number">1073741824</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        translated_memory <span class="token operator">=</span> memory <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// + "Mb"</span>        mstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>mstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"%dMb"</span><span class="token punctuation">,</span> translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        translated_memory <span class="token operator">=</span> memory <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// + "Gb"</span>        mstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>mstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"%dGb"</span><span class="token punctuation">,</span> translated_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将时间数字转为人类易读的字符串</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">time_to_string</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> numlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> translated_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>tstring <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        translated_time <span class="token operator">=</span> time<span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        tstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"%ds"</span><span class="token punctuation">,</span> translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        translated_time <span class="token operator">=</span> time <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        tstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"%dm"</span><span class="token punctuation">,</span> translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        translated_time <span class="token operator">=</span> time <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        tstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"%dh"</span><span class="token punctuation">,</span> translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        translated_time <span class="token operator">=</span> time <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numlen <span class="token operator">=</span> <span class="token function">number_len</span><span class="token punctuation">(</span>translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        tstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">snprintf</span><span class="token punctuation">(</span>tstring<span class="token punctuation">,</span> numlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"%dd"</span><span class="token punctuation">,</span> translated_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> tstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 基于读取的 kv, 向配置对象赋值</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add_config_value</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> klen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> vlen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"log_level"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span>lmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lname<span class="token punctuation">,</span> value<span class="token punctuation">,</span> vlen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span>                config<span class="token punctuation">.</span>loglevel <span class="token operator">=</span> lmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>loglevel<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"log_path"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>logpath<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"unix_socket"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        config<span class="token punctuation">.</span>socket_family <span class="token operator">=</span> UNIX<span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>hostname<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"ip_address"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        config<span class="token punctuation">.</span>socket_family <span class="token operator">=</span> INET<span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>hostname<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"ip_port"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>port<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"max_memory"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        config<span class="token punctuation">.</span>max_memory <span class="token operator">=</span> <span class="token function">read_memory_with_mul</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"max_request_size"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        config<span class="token punctuation">.</span>max_request_size <span class="token operator">=</span> <span class="token function">read_memory_with_mul</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"tcp_backlog"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tcp_backlog <span class="token operator">=</span> <span class="token function">parse_int</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span>tcp_backlog <span class="token operator">=</span> tcp_backlog <span class="token operator">&lt;=</span> SOMAXCONN <span class="token operator">?</span> tcp_backlog <span class="token operator">:</span> SOMAXCONN<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span><span class="token string">"stats_publish_interval"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> klen<span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        config<span class="token punctuation">.</span>stats_pub_interval <span class="token operator">=</span> <span class="token function">read_time_with_mul</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 去空格</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">strip_spaces</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isspace</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>dest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>str <span class="token operator">||</span> <span class="token operator">!</span>dest<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isspace</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token operator">*</span>dest<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 读取配置</span><span class="token keyword">int</span> <span class="token function">config_load</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>configpath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>configpath<span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fh <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>configpath<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sol_warning</span><span class="token punctuation">(</span><span class="token string">"WARNING: Unable to open conf file %s"</span><span class="token punctuation">,</span> configpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_warning</span><span class="token punctuation">(</span><span class="token string">"To specify a config file run sol -c /path/to/conf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">0xff</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">[</span><span class="token number">0xff</span><span class="token punctuation">]</span><span class="token punctuation">,</span> value<span class="token punctuation">[</span><span class="token number">0xff</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> linenr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pline<span class="token punctuation">,</span> <span class="token operator">*</span>pkey<span class="token punctuation">,</span> <span class="token operator">*</span>pval<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">,</span> fh<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        linenr<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 跳过注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'#'</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 删除key前的空格</span>        pline <span class="token operator">=</span> line<span class="token punctuation">;</span>        <span class="token function">strip_spaces</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pline <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// key</span>        pkey <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pline<span class="token punctuation">,</span> pkey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 删除 key 后空格</span>        <span class="token function">strip_spaces</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 忽略错误的配置格式并提示</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sol_warning</span><span class="token punctuation">(</span><span class="token string">"WARNING: Incomplete configuration '%s' at line %d. "</span>                        <span class="token string">"Fallback to default."</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> linenr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 获得值</span>        pval <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pline<span class="token punctuation">,</span> pval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 赋值</span>        <span class="token function">add_config_value</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 设置默认参数</span><span class="token keyword">void</span> <span class="token function">config_set_default</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 全局配置对象指针</span>    conf <span class="token operator">=</span> <span class="token operator">&amp;</span>config<span class="token punctuation">;</span>    <span class="token comment">// 默认赋值</span>    config<span class="token punctuation">.</span>version <span class="token operator">=</span> VERSION<span class="token punctuation">;</span>    config<span class="token punctuation">.</span>socket_family <span class="token operator">=</span> DEFAULT_SOCKET_FAMILY<span class="token punctuation">;</span>    config<span class="token punctuation">.</span>loglevel <span class="token operator">=</span> DEFAULT_LOG_LEVEL<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>logpath<span class="token punctuation">,</span> DEFAULT_LOG_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>hostname<span class="token punctuation">,</span> DEFAULT_HOSTNAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>port<span class="token punctuation">,</span> DEFAULT_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    config<span class="token punctuation">.</span>epoll_timeout <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    config<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token function">eventfd</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> EFD_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>    config<span class="token punctuation">.</span>max_memory <span class="token operator">=</span> <span class="token function">read_memory_with_mul</span><span class="token punctuation">(</span>DEFAULT_MAX_MEMORY<span class="token punctuation">)</span><span class="token punctuation">;</span>    config<span class="token punctuation">.</span>max_request_size <span class="token operator">=</span> <span class="token function">read_memory_with_mul</span><span class="token punctuation">(</span>DEFAULT_MAX_REQUEST_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    config<span class="token punctuation">.</span>tcp_backlog <span class="token operator">=</span> SOMAXCONN<span class="token punctuation">;</span>    config<span class="token punctuation">.</span>stats_pub_interval <span class="token operator">=</span> <span class="token function">read_time_with_mul</span><span class="token punctuation">(</span>DEFAULT_STATS_INTERVAL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 配置输出</span><span class="token keyword">void</span> <span class="token function">config_print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>loglevel <span class="token operator">&lt;</span> WARNING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sfamily <span class="token operator">=</span> config<span class="token punctuation">.</span>socket_family <span class="token operator">==</span> UNIX <span class="token operator">?</span> <span class="token string">"Unix"</span> <span class="token operator">:</span> <span class="token string">"Tcp"</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>llevel <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>loglevel <span class="token operator">==</span> config<span class="token punctuation">.</span>loglevel<span class="token punctuation">)</span>                llevel <span class="token operator">=</span> lmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lname<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Sol v%s is starting"</span><span class="token punctuation">,</span> VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Network settings:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tSocket family: %s"</span><span class="token punctuation">,</span> sfamily<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>socket_family <span class="token operator">==</span> UNIX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tUnix socket: %s"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>hostname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tAddress: %s"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>hostname<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tPort: %s"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tTcp backlog: %d"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>tcp_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>human_rsize <span class="token operator">=</span> <span class="token function">memory_to_string</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>max_request_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tMax request size: %s"</span><span class="token punctuation">,</span> human_rsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Logging:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tlevel: %s"</span><span class="token punctuation">,</span> llevel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"\tlogpath: %s"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>logpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>human_memory <span class="token operator">=</span> <span class="token function">memory_to_string</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>max_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Max memory: %s"</span><span class="token punctuation">,</span> human_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> human_memory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> human_rsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h1><p>最后的最后，<code>main</code> 函数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/sol.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_POSIX_C_SOURCE</span> <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"server.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>addr <span class="token operator">=</span> DEFAULT_HOSTNAME<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>port <span class="token operator">=</span> DEFAULT_PORT<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>confpath <span class="token operator">=</span> DEFAULT_CONF_PATH<span class="token punctuation">;</span>    <span class="token keyword">int</span> debug <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> opt<span class="token punctuation">;</span>    <span class="token comment">// 使用默认值赋值</span>    <span class="token function">config_set_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 处理运行参数</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"a:c:p:m:vn:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span>                addr <span class="token operator">=</span> optarg<span class="token punctuation">;</span>                <span class="token function">strcpy</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>hostname<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'c'</span><span class="token operator">:</span>                confpath <span class="token operator">=</span> optarg<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'p'</span><span class="token operator">:</span>                port <span class="token operator">=</span> optarg<span class="token punctuation">;</span>                <span class="token function">strcpy</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>port<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token char">'v'</span><span class="token operator">:</span>                debug <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span>                        <span class="token string">"Usage: %s [-a addr] [-p port] [-c conf] [-v]\n"</span><span class="token punctuation">,</span>                        argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 通过参数设置 debug 等级</span>    conf<span class="token operator">-></span>loglevel <span class="token operator">=</span> debug <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> DEBUG <span class="token operator">:</span> WARNING<span class="token punctuation">;</span>    <span class="token comment">// 读配置</span>    <span class="token function">config_load</span><span class="token punctuation">(</span>confpath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_log_init</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>logpath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印配置</span>    <span class="token function">config_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 运行服务</span>    <span class="token function">start_server</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>hostname<span class="token punctuation">,</span> conf<span class="token operator">-></span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_log_close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="构建与运行"><a href="#构建与运行" class="headerlink" title="构建与运行"></a>构建与运行</h1><p>我们的 <code>sol</code> 项目运行的所有所需内容都完成了：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">sol/ ├── src/ │    ├── mqtt.h │    ├── mqtt.c │    ├── network.h │    ├── network.c │    ├── list.h │    ├── list.c │    ├── hashtable.h │    ├── hashtable.c │    ├── server.h │    ├── server.c │    ├── trie.h │    ├── trie.c │    ├── util.h │    ├── util.c │    ├── core.h │    ├── core.c │    ├── config.h │    ├── config.c │    ├── pack.h │    ├── pack.c │    └── sol.c ├── conf │    └── sol.conf ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>sol</code> 项目的代码量并不算大，一般这种情况下我会编写 <code>Makefile</code> 用来控制编译。但是这一次，就像上方文件结构中描述的那样，我打算使用 <code>CMakeLists.txt</code> 来控制项目的构建：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span>project<span class="token punctuation">(</span>sol<span class="token punctuation">)</span>OPTION<span class="token punctuation">(</span>DEBUG <span class="token string">"add debug flags"</span> OFF<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>DEBUG<span class="token punctuation">)</span>    message<span class="token punctuation">(</span>STATUS <span class="token string">"Configuring build for debug"</span><span class="token punctuation">)</span>    set<span class="token punctuation">(</span>CMAKE_C_FLAGS <span class="token string">"<span class="token variable">$&#123;CMAKE_C_FLAGS&#125;</span> -Wall -Wunused -Werror -std=c11 -O3 -pedantic -luuid -ggdb -fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer -pg"</span><span class="token punctuation">)</span><span class="token keyword">else</span> <span class="token punctuation">(</span>DEBUG<span class="token punctuation">)</span>    message<span class="token punctuation">(</span>STATUS <span class="token string">"Configuring build for production"</span><span class="token punctuation">)</span>    set<span class="token punctuation">(</span>CMAKE_C_FLAGS <span class="token string">"<span class="token variable">$&#123;CMAKE_C_FLAGS&#125;</span> -Wall -Wunused -Werror -Wextra -std=c11 -O3 -pedantic -luuid"</span><span class="token punctuation">)</span>endif <span class="token punctuation">(</span>DEBUG<span class="token punctuation">)</span>set<span class="token punctuation">(</span>EXECUTABLE_OUTPUT_PATH <span class="token variable">$&#123;CMAKE_SOURCE_DIR&#125;</span><span class="token punctuation">)</span>file<span class="token punctuation">(</span>GLOB SOURCES src/*.c<span class="token punctuation">)</span>set<span class="token punctuation">(</span>AUTHOR <span class="token string">"Andrea Giacomo Baldan"</span><span class="token punctuation">)</span>set<span class="token punctuation">(</span>LICENSE <span class="token string">"BSD2 license"</span><span class="token punctuation">)</span><span class="token comment"># Executable</span>add_executable<span class="token punctuation">(</span>sol <span class="token variable">$&#123;SOURCES&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>唯一值得注意的就是我添加了 <code>DEBUG</code>  参数，这会产生一个带有监测内存泄漏参数版本的 <code>Makefile</code>。</p><p>所以接下来只需要生成 <code>Makefile</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmake <span class="token parameter variable">-DDEBUG</span><span class="token operator">=</span><span class="token number">1</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后编译我们的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>编译后得到名为 <strong>sol</strong> 的可执行程序，我们可以运行他来启动我们的 broker，程序支持我们上面编写的那些参数。</p><p>我们通过 <strong>-v</strong> (verbose) 参数启动程序，这样可以看到 <strong>debug</strong> 级别的日志信息。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sol <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>好了，到此为止就是这么多内容，现在我们的代码也许有很多bug，有内存泄露问题，有很多需要修复或者重构的代码，但是软件的框架就是这样子了。第七部分很快就会编写完成，我打算用 <code>paho-mqtt</code> 进行一些测试。接下来你可以看看<a href="https://codepr.github.io/posts/sol-mqtt-broker-bonus/">特别篇</a>，在那里我们会为 <strong>sol</strong> 添加多线程支持。</p>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 第五部分：主题树</title>
    <link href="/translate-sol-5.html"/>
    <url>/translate-sol-5.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker-p5/">Sol - An MQTT broker from scratch. Part 5 - Topic abstraction</a></p></blockquote><span id="more"></span><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>在<a href="%5B../sol-mqtt-broker-p4%5D(https://codepr.github.io/posts/sol-mqtt-broker-p4/)">第四部分</a>中，我们已经实现了两个数据结构，<strong>哈希表</strong>和<strong>列表</strong>。</p><p>在MQTT协议中，有一种名为 <strong>主题(topic)</strong> 的路由方式，主题本质上是一个字符串，用来将消息匹配到符合规则的客户端中。主题使用分层模型，遵守以下规则：</p><ul><li>主题是一个UTF-8编码的字符串，最大长度为65535个字节</li><li><code>/</code> 用来区分不同的层级，就像文件系统一样</li><li><code>*</code> 是多层匹配通配符，例如使用 <strong>foo&#x2F;bar&#x2F;*</strong> 可以匹配下列主题：<ul><li>foo&#x2F;bar</li><li>foo&#x2F;bar&#x2F;baz</li><li>foo&#x2F;bar&#x2F;bat&#x2F;yop</li></ul></li><li><code>+</code> 是单层匹配通配符，例如使用 <strong>foo&#x2F;+&#x2F;baz</strong> 可以匹配下列主题：<ul><li>foo&#x2F;bar&#x2F;baz</li><li>foo&#x2F;zod&#x2F;baz</li><li>foo&#x2F;nop&#x2F;baz</li></ul></li></ul><p>主题和消息队列有一些类似的特性，但是主题更简单，更加轻量级，同时功能也更弱。</p><h1 id="特里树定义"><a href="#特里树定义" class="headerlink" title="特里树定义"></a>特里树定义</h1><p>现在，我们开始定义我们的 <strong>特里树(trie)</strong> ，这将是我们用来存储主题的数据结构。特里树是这样一种结构，他的每一个节点都带有一个字符，从根到节点的所有字符就组成一个key，数据则是关联在key对应的位置上，在最糟糕的情况下，插入和查找的复杂度为 O(m)，其中 m 是键的长度。特里树的主要优点是可以方便的进行前缀匹配。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/trie.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token comment">// 向用户提供类型 Trie</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">trie</span> Trie<span class="token punctuation">;</span><span class="token comment">// 树节点, 包括一个子节点列表 children</span><span class="token comment">// 如果是终端节点, 会在data中存储数据</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> chr<span class="token punctuation">;</span>    List <span class="token operator">*</span>children<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 特里树类型, 包括根节点和数据数量</span><span class="token keyword">struct</span> <span class="token class-name">trie</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 创建一个新的字符节点</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token function">trie_create_node</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建一个新的特里树</span><span class="token keyword">struct</span> <span class="token class-name">trie</span> <span class="token operator">*</span><span class="token function">trie_create</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 特里树初始化</span><span class="token keyword">void</span> <span class="token function">trie_init</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 当前大小</span><span class="token class-name">size_t</span> <span class="token function">trie_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> Trie <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* * 叶子代表有关联数据的节点 *           . *          / \ *         h   s: s -> value *        / \ *       e   k: hk -> value *      / *     l: hel -> value * * 上例中有三个键值对： * - s   -> value * - hk  -> value * - hel -> value */</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">trie_insert</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">trie_delete</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查找节点, 查找成功时返回 true, 否则 false</span><span class="token comment">// 第三个参数作为返回值, 提供指向查找结果的指针, 未找到时值为NULL</span>bool <span class="token function">trie_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> Trie <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放一个节点, 同时更新size</span><span class="token keyword">void</span> <span class="token function">trie_node_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">trie_release</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过一个前缀删除所有能匹配的节点</span><span class="token keyword">void</span> <span class="token function">trie_prefix_delete</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 mapfunc 处理树中的所有节点, 第四个参数是 mapfunc 可使用的参数</span><span class="token keyword">void</span> <span class="token function">trie_prefix_map_tuple</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>mapfunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="特里树性能"><a href="#特里树性能" class="headerlink" title="特里树性能"></a>特里树性能</h1><p>关于树节点的实现，其实有很多种不同的方法，最简单的一种就是在每一个节点上使用固定长度的数组，数组的大小就是完整的字母表大小，例如这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ALPHABET_SIZE</span> <span class="token expression"><span class="token number">94</span></span></span><span class="token comment">// 使用固定数组大小的树节点</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>children<span class="token punctuation">[</span>ALPHABET_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>除了可以对key进行范围查询（用以实现通配符功能）这个最大的优点外，特里树的另一个巨大优点是他基于哈希表或者说 B-Tree 的性能优势，能够在进行插入、删除和搜索时保持最坏为 O(L) 的时间复杂度（L是查询键的长度）。但这是有代价的，最明显的缺陷就是结构体自身的内存消耗。</p><p>在上面的例子中，我们的字母表长度是96，意味着从<code>空格</code> 开始一直到 <code>~</code> 结束的96个代表不同字符的 <code>NULL</code> 指针都会被存在 <code>children</code> 中。在一个64位的机器上，每个指针需要使用8个byte，也就是说一个节点至少需要 96 * 8 &#x3D; 768 个字节的空间。我们举个简单的例子：</p><ul><li>插入一个key <code>foo</code></li><li>插入一个key <code>foot</code></li></ul><p>此时我们的根节点 <code>f</code> 有一个非空指针 <code>o</code>，<code>o</code> 也有一个非空指针 <code>o</code>，这里储存着键 <code>foo</code> 对应的值。第二个 <code>o</code> 还有一个非空指针 <code>t</code>， 他将存储键 <code>foot</code> 对应的值。所以我们总共会有4个节点，这意味着我们会有 4 * 96 &#x3D; 384 个指针，然后只使用了其中的4个，显然造成了很大的空间浪费。</p><p>当然，业界早有解决这个问题的方法，即减少空间浪费又保持着良好的时间复杂度性能，比如压缩特里树（compressed trie）和自适应特里树（adaptive trie）。</p><p>我们不去深入挖掘这些概念，就我们目前情况来看，可以想到三个解决方案：</p><ul><li><p>在特里树结构体本身（非节点）添加一个动态列表，每个节点都必须拥有一个指向该列表的指针，和一个<code>char children_idx[ALPHABET_SIZE]</code>数组，数组中保存了自己的子节点在列表中的索引（这句话译者没有理解，原文：Use a single dynamic array (vector) in the Trie structure, each node must have a pointer to that vector and an array char children_idx[ALPHABET_SIZE] which store the index in the main vector for each children，如果你能理解，请告诉我，感谢）</p></li><li><p>使用基于子节点数量增长存储空间的节点，例如当子节点数量 &lt;&#x3D; 4 时，可以使用固定长度为4的数组，当子节点数量增长时将数组更换为更大的数组并且重新关联子节点。</p></li><li><p>将每个节点上的定长数组更换为 <strong>链表</strong>， 在每次插入操作后保持排序，这样每次搜索的平均性能为 O(n&#x2F;2)，等同于 O(n)。</p></li></ul><p>恰好我们在上个部分中实现了基于链表的列表，接下来就让我们使用第三种方案来实现我们的特里树。</p><h1 id="特里树实现"><a href="#特里树实现" class="headerlink" title="特里树实现"></a>特里树实现</h1><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/trie.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"trie.h"</span></span><span class="token comment">// 合并两个输入的链表为一个链表, 并从小到大排序</span><span class="token comment">// 要求输入的两个链表都是已经被从小到大排序</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">merge_tnode_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>list1<span class="token punctuation">,</span>                                          <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>list2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> dummy_head <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token operator">*</span>tail <span class="token operator">=</span> <span class="token operator">&amp;</span>dummy_head<span class="token punctuation">;</span>    <span class="token comment">// 每次都取 l1 或 l2 中较小的那个, 循环操作</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>list1 <span class="token operator">&amp;&amp;</span> list2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用char比较大小</span>        <span class="token keyword">char</span> chr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> list1<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token operator">-></span>chr<span class="token punctuation">;</span>        <span class="token keyword">char</span> chr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> list2<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token operator">-></span>chr<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token operator">*</span>min <span class="token operator">=</span> chr1 <span class="token operator">&lt;=</span> chr2 <span class="token operator">?</span> <span class="token operator">&amp;</span>list1 <span class="token operator">:</span> <span class="token operator">&amp;</span>list2<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>min<span class="token punctuation">)</span><span class="token operator">-></span>next<span class="token punctuation">;</span>        tail <span class="token operator">=</span> tail<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>min<span class="token punctuation">;</span>        <span class="token operator">*</span>min <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    tail<span class="token operator">-></span>next <span class="token operator">=</span> list1 <span class="token operator">?</span> list1 <span class="token operator">:</span> list2<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummy_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 被递归调用, 将链表按照从小到大顺序排序</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">merge_sort_tnode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>list1 <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list1 <span class="token operator">||</span> <span class="token operator">!</span>list1<span class="token operator">-></span>next<span class="token punctuation">)</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>    <span class="token comment">// 从中分开</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>list2 <span class="token operator">=</span> <span class="token function">bisect_list</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">merge_tnode_list</span><span class="token punctuation">(</span><span class="token function">merge_sort_tnode</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">merge_sort_tnode</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过给定的 val 搜索链表中的 trie_node, 最糟糕情况下的时间复杂度是 O(n)</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">linear_search</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list <span class="token operator">||</span> list<span class="token operator">-></span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> list<span class="token operator">-></span>head<span class="token punctuation">;</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> cur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token operator">-></span>chr <span class="token operator">==</span> value<span class="token punctuation">)</span>            <span class="token keyword">return</span> cur<span class="token punctuation">;</span>        <span class="token comment">// 链表内部的节点是按照 chr 排序的，因此当大于 value 时无需继续搜索</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> cur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token operator">-></span>chr <span class="token operator">></span> value<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 辅助比较函数, 传入两个 list_node, 当其中的 trie_node->chr 相等时返回0, 否则返回1</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">with_char</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>tn1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> arg1<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>tn2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> arg2<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tn1<span class="token operator">-></span>chr <span class="token operator">==</span> tn2<span class="token operator">-></span>chr<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 判断 trie_node 是否有子节点, 没有则认为 free</span><span class="token keyword">static</span> bool <span class="token function">trie_is_free_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> node<span class="token operator">-></span>children<span class="token operator">-></span>len <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> true <span class="token operator">:</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 从 node 开始, 通过传入的 prefix, 找到对应的节点</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token function">trie_node_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 结果, 最初指向 node</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>retnode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">)</span> node<span class="token punctuation">;</span>    <span class="token comment">// 遍历 prefix 向下查找</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token operator">*</span>prefix<span class="token punctuation">;</span> prefix<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// O(n)</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>child <span class="token operator">=</span> <span class="token function">linear_search</span><span class="token punctuation">(</span>retnode<span class="token operator">-></span>children<span class="token punctuation">,</span> <span class="token operator">*</span>prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 没找到</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        retnode <span class="token operator">=</span> child<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> retnode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建一个新节点</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token function">trie_create_node</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>new_node <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        new_node<span class="token operator">-></span>chr <span class="token operator">=</span> c<span class="token punctuation">;</span>        new_node<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        new_node<span class="token operator">-></span>children <span class="token operator">=</span> <span class="token function">list_create</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> new_node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建并初始化特里树, 当前 size 0</span>Trie <span class="token operator">*</span><span class="token function">trie_create</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Trie <span class="token operator">*</span>trie <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>trie<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">trie_init</span><span class="token punctuation">(</span>trie<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> trie<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">trie_init</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span>trie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    trie<span class="token operator">-></span>root <span class="token operator">=</span> <span class="token function">trie_create_node</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    trie<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">size_t</span> <span class="token function">trie_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> Trie <span class="token operator">*</span>trie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> trie<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 插入数据, 插入沿途的所有所需节点, 如果目标节点已经有数据则替换</span><span class="token comment">// return 被插入的数据</span><span class="token comment">// root 一般是根节点</span><span class="token comment">// key 插入位置目标键</span><span class="token comment">// data 要插入的数据内容</span><span class="token comment">// size 带入 size, 如新增数据则+1</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">trie_node_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>cursor <span class="token operator">=</span> root<span class="token punctuation">;</span>   <span class="token comment">// 上级节点</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>cur_node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 当前节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token comment">// 包裹当前节点的 list_node</span>    <span class="token comment">// 逐字符遍历 key</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token operator">*</span>key<span class="token punctuation">;</span> key<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 我们使用一个 O(n) 复杂度的线性搜索器来搜索匹配的节点</span>        tmp <span class="token operator">=</span> <span class="token function">linear_search</span><span class="token punctuation">(</span>cursor<span class="token operator">-></span>children<span class="token punctuation">,</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果没有匹配, 我们会添加一个节点, 然后对所有的节点进行排序</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cur_node <span class="token operator">=</span> <span class="token function">trie_create_node</span><span class="token punctuation">(</span><span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            cursor<span class="token operator">-></span>children <span class="token operator">=</span> <span class="token function">list_push</span><span class="token punctuation">(</span>cursor<span class="token operator">-></span>children<span class="token punctuation">,</span> cur_node<span class="token punctuation">)</span><span class="token punctuation">;</span>            cursor<span class="token operator">-></span>children<span class="token operator">-></span>head <span class="token operator">=</span> <span class="token function">merge_sort_tnode</span><span class="token punctuation">(</span>cursor<span class="token operator">-></span>children<span class="token operator">-></span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 匹配成功, 进入下一层匹配</span>            <span class="token comment">// 如果此时 key 已经被阅读完, 后续直接使用此节点</span>            cur_node <span class="token operator">=</span> tmp<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cursor <span class="token operator">=</span> cur_node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果新节点或此节点没有数据, 则记录size</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cursor<span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token operator">*</span>size<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>    cursor<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> data<span class="token punctuation">;</span>    <span class="token keyword">return</span> cursor<span class="token operator">-></span>data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除 key 节点对应的数据, 同时递归的向上删除每一层不需要的节点（指既没有数据也没有子节点）</span><span class="token comment">// return 节点本身是否可被删除(如果没有子节点就可以删除)</span><span class="token comment">// node 寻找的起始节点, 一般用root</span><span class="token comment">// key 匹配键</span><span class="token comment">// size 当前树的大小</span><span class="token comment">// found 返回是否删除成功</span><span class="token keyword">static</span> bool <span class="token function">trie_node_recursive_delete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span>                                       <span class="token class-name">size_t</span> <span class="token operator">*</span>size<span class="token punctuation">,</span> bool <span class="token operator">*</span>found<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment">// 字符串已经递归到达尾部的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>key <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 标记成功找到数据</span>            <span class="token operator">*</span>found <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token comment">// 释放资源（以下为作者原代码，译者觉得这里重复操作了）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                node<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token comment">// 记录size</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token operator">*</span>size<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">// 如果没有子节点, 标记需要被删除</span>            <span class="token keyword">return</span> <span class="token function">trie_is_free_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过 key 逐字符匹配节点</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token function">linear_search</span><span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">,</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token punctuation">)</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>child <span class="token operator">=</span> cur<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">trie_node_recursive_delete</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> key <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> found<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从list中删除和当前剩余key后缀相同的节点</span>            <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> t <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">list_node</span> tmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token function">list_remove</span><span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">,</span> with_char<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 把被删除的节点释放掉</span>            <span class="token function">trie_node_free</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 递归, 逐级向上删除可以被删除的节点</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>data <span class="token operator">&amp;&amp;</span> <span class="token function">trie_is_free_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 从根节点开始寻找目标节点, 提供目标节点的数据</span><span class="token comment">// return 是否查询成功</span><span class="token comment">// root 一般传入根节点</span><span class="token comment">// key 查询的键</span><span class="token comment">// ret 返回值 (使用双指针因此当无数据时 *ret 可以为NULL)</span><span class="token keyword">static</span> bool <span class="token function">trie_node_search</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>cursor <span class="token operator">=</span> <span class="token function">trie_node_find</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>ret <span class="token operator">=</span> <span class="token punctuation">(</span>cursor <span class="token operator">&amp;&amp;</span> cursor<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token operator">?</span> cursor<span class="token operator">-></span>data <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">*</span>ret <span class="token operator">?</span> false <span class="token operator">:</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 插入数据</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">trie_insert</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span>trie<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>trie <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">trie_node_insert</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>trie<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除某个节点的数据 (会递归的删除上层不需要的节点)</span>bool <span class="token function">trie_delete</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span>trie<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>trie <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool found <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">trie_node_recursive_delete</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>found<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> found<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获得数据</span>bool <span class="token function">trie_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> Trie <span class="token operator">*</span>trie<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>trie <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">trie_node_search</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用前缀删除所有匹配的内容</span><span class="token comment">// 例如 prefix = "hello"</span><span class="token comment">// 会删除这些内容： hello hellot helloworld</span><span class="token keyword">void</span> <span class="token function">trie_prefix_delete</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span>trie<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>trie <span class="token operator">&amp;&amp;</span> prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 找到前缀对应的节点</span>    <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>cursor <span class="token operator">=</span> <span class="token function">trie_node_find</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cursor<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 如果没有子节点, 就直接删除这个节点即可</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cursor<span class="token operator">-></span>children<span class="token operator">-></span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">trie_delete</span><span class="token punctuation">(</span>trie<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果有子节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> cursor<span class="token operator">-></span>children<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token comment">// 遍历</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 递归的释放所有内容</span>        <span class="token function">trie_node_free</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 并将子节点指针置空</span>        cur<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">trie_delete</span><span class="token punctuation">(</span>trie<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_clear</span><span class="token punctuation">(</span>cursor<span class="token operator">-></span>children<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用传入的函数处理每个节点, 将 node 作为首个节点逐层向下遍历, arg 允许作为函数的参数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">trie_prefix_map_func2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span>                                  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>mapfunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">trie_is_free_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mapfunc</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>child <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> child<span class="token punctuation">;</span> child <span class="token operator">=</span> child<span class="token operator">-></span>next<span class="token punctuation">)</span>        <span class="token function">trie_prefix_map_func2</span><span class="token punctuation">(</span>child<span class="token operator">-></span>data<span class="token punctuation">,</span> mapfunc<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// node 本身也会被应用</span>    <span class="token function">mapfunc</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 从前缀对应的节点开始调用 trie_prefix_map_func2</span><span class="token keyword">void</span> <span class="token function">trie_prefix_map_tuple</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span>trie<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>prefix<span class="token punctuation">,</span>                           <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>mapfunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>trie<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">trie_prefix_map_func2</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> mapfunc<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 找到key对应的节点</span>        <span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">trie_node_find</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 没有匹配到的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// 通过递归让node和所有的子节点都应用 mapfunc</span>        <span class="token function">trie_prefix_map_func2</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mapfunc<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归的, 从node开始向下全部释放并删除</span><span class="token keyword">void</span> <span class="token function">trie_node_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">trie_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 这里的递归处理删除所有子节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token operator">-></span>head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span>            <span class="token function">trie_node_free</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>data<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">list_release</span><span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token operator">-></span>children <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 译者并没有看明白这里？也许是某种编程技巧？</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token operator">*</span>size<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token operator">*</span>size<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放node本身</span>    <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放整个特里树</span><span class="token keyword">void</span> <span class="token function">trie_release</span><span class="token punctuation">(</span>Trie <span class="token operator">*</span>trie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>trie<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">trie_node_free</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>root<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>trie<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>trie<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>写到这里，我们的工具基本上够用了。现在我们的项目又多了三个模块：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">sol/ ├── src/ │    ├── mqtt.h |    ├── mqtt.c │    ├── network.h │    ├── network.c │    ├── list.h │    ├── list.c │    ├── hashtable.h │    ├── hashtable.c │    ├── trie.h │    ├── trie.c │    ├── util.h │    ├── util.c │    ├── pack.h │    └── pack.c ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 第四部分：数据结构</title>
    <link href="/translate-sol-4.html"/>
    <url>/translate-sol-4.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker-p4/">Sol - An MQTT broker from scratch. Part 4 - Data structures</a></p></blockquote><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在继续实现所有的 <code>handler</code> 之前，我们先设计和实现一些最常用的数据结构，包括 <strong>哈希表(hashtable)<strong>，</strong>列表(list)</strong> 和 **特里树(trie)**。</p><p><strong>特里树</strong> 不是我们当前就用到的东西，但是在我们后续处理 <strong>主题</strong> 时会用到他。</p><p>也许实现这些数据结构这件事情对于我们这个项目来说有点过于底层了，也确实有很多成熟的实现可以拿来用。但是我个人比较喜欢在稍微有些规模的项目中自己实现数据结构，一方面是这样方便于之后随着项目需求对这些数据结构进行改进，另一方面是，实现数据结构的过程也确实是一个非常好的学习和探索的机会。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>让我们从一个简单的哈希表开始，哈希表本质上是一个数组，他使用哈希值（下图中的Hashval % Bucketsize）作为存储我们信息的索引，并且试图尽可能的减少冲突情况（例如两个key计算出了同样的哈希值）。</p><p><img src="/translate-sol-4/hashtable.png" alt="哈希表示意"></p><p><code>Buckets</code> 是一个数组，一般情况下会是个动态扩容的数组，他通过 <code>key</code> 来关联存储的数据。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/hashtable.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token comment">// 状态码</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HASHTABLE_OK</span>   <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HASHTABLE_ERR</span>  <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HASHTABLE_OOM</span>  <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HASHTABLE_FULL</span> <span class="token expression"><span class="token number">3</span></span></span><span class="token comment">// 哈希表条目</span><span class="token comment">// key 键</span><span class="token comment">// val 存储的值</span><span class="token comment">// taken 表示此索引是否已经被占用, 如果是则使用 index + 1 的位置存储</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>    bool taken<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 哈希表结构体, 包括最大尺寸、当前尺寸以及存储的数据</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">hashtable</span> HashTable<span class="token punctuation">;</span><span class="token comment">// 创建哈希表的函数</span><span class="token comment">// 可以传入一个析构函数指针, 作为删除条目时释放资源的函数</span><span class="token comment">// 如果资源比较简单(基础类型或数据流), 可以传NULL, 可以采用默认函数释放</span>HashTable <span class="token operator">*</span><span class="token function">hashtable_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过对每个条目调用 `destructor` 来释放所有资源</span><span class="token keyword">void</span> <span class="token function">hashtable_release</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 哈希表当前大小</span><span class="token class-name">size_t</span> <span class="token function">hashtable_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> HashTable <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查看哈希表中是否已经存在此key</span><span class="token keyword">int</span> <span class="token function">hashtable_exists</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入数据, const char * 作为 key, void * 作为 value</span><span class="token keyword">int</span> <span class="token function">hashtable_put</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过 key 获取数据</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">hashtable_get</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过 key 删除数据</span><span class="token keyword">int</span> <span class="token function">hashtable_del</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 迭代所有的键值对, 使用传入的函数指针进行处理</span><span class="token keyword">int</span> <span class="token function">hashtable_map</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 迭代所有的键值对, 使用传入的函数指针进行处理, 并且可以额外传入一个参数</span><span class="token keyword">int</span> <span class="token function">hashtable_map2</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们通过 <code>typedef struct hashtable HashTable;</code> 这种方式将实际的哈希表的结构封装到的 <code>.c</code> 文件里，这样可以避免哈希表的使用者不使用我们提供的函数，而是直接访问我们的哈希表。这种方式可以被看作是c语言中的私有类。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/hashtable.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hashtable.h"</span></span><span class="token comment">// 哈希表结构</span><span class="token keyword">struct</span> <span class="token class-name">hashtable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最大容量</span>    <span class="token class-name">size_t</span> table_size<span class="token punctuation">;</span>    <span class="token comment">// 当前数据量</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 析构函数指针</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 条目数组</span>    <span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span>entries<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> INITIAL_SIZE <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_CHAIN_LENGTH <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> KNUTH_PRIME <span class="token operator">=</span> <span class="token number">2654435761</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">crc32</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过输入的key 计算其在哈希表中的序号</span><span class="token comment">// 此处仅进行数字运算, 不考虑冲突情况</span><span class="token keyword">static</span> <span class="token class-name">uint64_t</span> <span class="token function">hashtable_hash_int</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>m<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>keystr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>m <span class="token operator">&amp;&amp;</span> keystr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> key <span class="token operator">=</span> <span class="token function">crc32</span><span class="token punctuation">(</span>keystr<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> keystr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Robert Jenkins' 32 bit Mix Function */</span>    key <span class="token operator">+=</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">^=</span> <span class="token punctuation">(</span>key <span class="token operator">>></span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">+=</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">^=</span> <span class="token punctuation">(</span>key <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">+=</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">^=</span> <span class="token punctuation">(</span>key <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">+=</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    key <span class="token operator">^=</span> <span class="token punctuation">(</span>key <span class="token operator">>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Knuth's Multiplicative Method */</span>    key <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> KNUTH_PRIME<span class="token punctuation">;</span>    <span class="token keyword">return</span> key <span class="token operator">%</span> m<span class="token operator">-></span>table_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过输入的key 计算其在哈希表中的序号</span><span class="token comment">// 此处考虑了冲突情况</span><span class="token comment">// 如果哈希表已经满了, 返回 -HASHTABLE_FULL</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hashtable_hash</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>table <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用量超过总额的 1/2 视为满</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>size <span class="token operator">>=</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>table_size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_FULL<span class="token punctuation">;</span>    <span class="token comment">// 计算序号</span>    <span class="token class-name">uint64_t</span> curr <span class="token operator">=</span> <span class="token function">hashtable_hash_int</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>k<span class="token punctuation">,</span> <span class="token operator">*</span>currk<span class="token punctuation">;</span>    <span class="token comment">// 避免序号冲突的情况</span>    <span class="token comment">// 最大重复 MAX_CHAIN_LENGTH 次</span>    <span class="token comment">// 意味着视冲突情况, key 被保存在 curr ~ curr + MAX_CHAIN_LENGTH 这个范围中某一点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_CHAIN_LENGTH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 序号未被占用直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> false<span class="token punctuation">)</span>            <span class="token keyword">return</span> curr<span class="token punctuation">;</span>        k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>        currk <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> key<span class="token punctuation">;</span>        <span class="token comment">// 传入的 key 已存在的情况, 返回相同 key 的序号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> true <span class="token operator">&amp;&amp;</span> <span class="token function">STREQ</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> currk<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span>            <span class="token keyword">return</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> <span class="token punctuation">(</span>curr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_FULL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 扩容, 容量 * 2, 重新排布所有的内容</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hashtable_rehash</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> old_size<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span>curr<span class="token punctuation">;</span>    <span class="token comment">// 新数组空间</span>    <span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span>temp <span class="token operator">=</span>        <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token operator">-></span>table_size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>temp<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">;</span>    <span class="token comment">// 暂存旧数组</span>    curr <span class="token operator">=</span> table<span class="token operator">-></span>entries<span class="token punctuation">;</span>    <span class="token comment">// 指向新数组</span>    table<span class="token operator">-></span>entries <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token comment">// 记录空间扩容</span>    old_size <span class="token operator">=</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span>    table<span class="token operator">-></span>table_size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span>    table<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token comment">// 重新排布所有条目</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> old_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> false<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 也很简单, 就是直接用 put 重新放一遍</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">=</span> <span class="token function">hashtable_put</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> curr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> curr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> HASHTABLE_OK<span class="token punctuation">)</span>            <span class="token keyword">return</span> status<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放旧数组</span>    <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> HASHTABLE_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 默认的释放条目函数</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">destroy_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span>entry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">;</span>    <span class="token comment">// 释放 key</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token operator">-></span>key<span class="token punctuation">)</span>        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> entry<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放 val</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token operator">-></span>val<span class="token punctuation">)</span>        <span class="token function">free</span><span class="token punctuation">(</span>entry<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> HASHTABLE_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建一个空的哈希表</span><span class="token comment">// 新创建的哈希表被分配到堆中, 用完后必须手动释放</span>HashTable <span class="token operator">*</span><span class="token function">hashtable_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建哈希表</span>    HashTable <span class="token operator">*</span>table <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>HashTable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>table<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化条目数组</span>    table<span class="token operator">-></span>entries <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>INITIAL_SIZE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>table<span class="token operator">-></span>entries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">hashtable_release</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 选择析构函数</span>    table<span class="token operator">-></span>destructor <span class="token operator">=</span> destructor <span class="token operator">?</span> destructor <span class="token operator">:</span> destroy_entry<span class="token punctuation">;</span>    <span class="token comment">// 初始化数据</span>    table<span class="token operator">-></span>table_size <span class="token operator">=</span> INITIAL_SIZE<span class="token punctuation">;</span>    table<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> table<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 当前数据量</span><span class="token class-name">size_t</span> <span class="token function">hashtable_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> HashTable <span class="token operator">*</span>table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> table<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 是否存在 key</span><span class="token keyword">int</span> <span class="token function">hashtable_exists</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ret <span class="token operator">=</span> <span class="token function">hashtable_get</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>ret <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 添加数据, 如果 key 的哈希值重复则序号 +1</span><span class="token keyword">int</span> <span class="token function">hashtable_put</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>table <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获得可以存储的序号</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">hashtable_hash</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果满了</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span>HASHTABLE_FULL<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 尝试扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hashtable_rehash</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token function">hashtable_hash</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 放置内容</span>    table<span class="token operator">-></span>entries<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>    table<span class="token operator">-></span>entries<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token comment">// 标记使用, 如果是新增, 还需要添加计数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> false<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        table<span class="token operator">-></span>entries<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">=</span> true<span class="token punctuation">;</span>        table<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 译者觉得这里有一个问题, 当 put 使用了重复的 key 时, index会是这个 key 实际存放的索引</span>    <span class="token comment">// 之后对 key 和 val 进行了赋值, 但是如果 key 是存在的, 那么原来 entry 中的 key 和 val 没有被释放</span>    <span class="token keyword">return</span> HASHTABLE_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过key获得val</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">hashtable_get</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>table <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查 key 哈希值对应的索引</span>    <span class="token class-name">uint64_t</span> curr <span class="token operator">=</span> <span class="token function">hashtable_hash_int</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查 key 实际对应的索引</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_CHAIN_LENGTH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span>                <span class="token keyword">return</span> table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        curr <span class="token operator">=</span> <span class="token punctuation">(</span>curr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除一个条目</span><span class="token keyword">int</span> <span class="token function">hashtable_del</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>table <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 哈希值对应的索引</span>    <span class="token class-name">uint64_t</span> curr <span class="token operator">=</span> <span class="token function">hashtable_hash_int</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 找到实际 key 的索引</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_CHAIN_LENGTH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 有数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 且 key 一致</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">STREQ</span><span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 标记无数据</span>                table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">=</span> false<span class="token punctuation">;</span>                <span class="token comment">// 记录尺寸</span>                table<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token comment">// 使用析构释放</span>                table<span class="token operator">-></span><span class="token function">destructor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> HASHTABLE_OK<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        curr <span class="token operator">=</span> <span class="token punctuation">(</span>curr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 未找到数据</span>    <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过传入的func迭代哈希表中的所有内容</span><span class="token keyword">int</span> <span class="token function">hashtable_map</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 空表不处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>table <span class="token operator">||</span> table<span class="token operator">-></span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">;</span>    <span class="token comment">// 就遍历</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 处理data</span>            <span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> data <span class="token operator">=</span> table<span class="token operator">-></span>entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 要求传入函数正确时返回 HASHTABLE_OK</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> HASHTABLE_OK<span class="token punctuation">)</span>                <span class="token keyword">return</span> status<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> HASHTABLE_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 另一个迭代器, 支持一个参数</span><span class="token keyword">int</span> <span class="token function">hashtable_map2</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">,</span>                   <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                   <span class="token keyword">void</span> <span class="token operator">*</span>param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>table <span class="token operator">||</span> table<span class="token operator">-></span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>HASHTABLE_ERR<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> table<span class="token operator">-></span>table_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>taken <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 区别就是带了参数</span>            <span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> data <span class="token operator">=</span> table<span class="token operator">-></span>entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> HASHTABLE_OK<span class="token punctuation">)</span>                <span class="token keyword">return</span> status<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> HASHTABLE_OK<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用预定义的析构函数释放哈希表</span><span class="token comment">// 如果没有定义析构函数, 则使用默认函数 destroy_entry</span><span class="token keyword">void</span> <span class="token function">hashtable_release</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>table<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>table<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">hashtable_map</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> table<span class="token operator">-></span>destructor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>table <span class="token operator">||</span> <span class="token operator">!</span>table<span class="token operator">-></span>entries<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>table<span class="token operator">-></span>entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* The implementation here was originally done by Gary S. Brown. Slighltly * modified by Pete Warden, without any imposition on the reuse of the code. */</span><span class="token comment">/* ============================================================= */</span><span class="token comment">/*  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or       */</span><span class="token comment">/*  code or tables extracted from it, as desired without restriction.     */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*  First, the polynomial itself and its table of feedback terms.  The    */</span><span class="token comment">/*  polynomial is                                                         */</span><span class="token comment">/*  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0   */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*  Note that we take it "backwards" and put the highest-order term in    */</span><span class="token comment">/*  the lowest-order bit.  The X^32 term is "implied"; the LSB is the     */</span><span class="token comment">/*  X^31 term, etc.  The X^0 term (usually shown as "+1") results in      */</span><span class="token comment">/*  the MSB being 1.                                                      */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*  Note that the usual hardware shift register implementation, which     */</span><span class="token comment">/*  is what we're using (we're merely optimizing it by doing eight-bit    */</span><span class="token comment">/*  chunks at a time) shifts bits into the lowest-order term.  In our     */</span><span class="token comment">/*  implementation, that means shifting towards the right.  Why do we     */</span><span class="token comment">/*  do it this way?  Because the calculated CRC must be transmitted in    */</span><span class="token comment">/*  order from highest-order term to lowest-order term.  UARTs transmit   */</span><span class="token comment">/*  characters in order from LSB to MSB.  By storing the CRC this way,    */</span><span class="token comment">/*  we hand it to the UART in the order low-byte to high-byte; the UART   */</span><span class="token comment">/*  sends each low-bit to hight-bit; and the result is transmission bit   */</span><span class="token comment">/*  by bit from highest- to lowest-order term without requiring any bit   */</span><span class="token comment">/*  shuffling on our part.  Reception works similarly.                    */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*  The feedback terms table consists of 256, 32-bit entries.  Notes:     */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*      The table can be generated at runtime if desired; code to do so   */</span><span class="token comment">/*      is shown later.  It might not be obvious, but the feedback        */</span><span class="token comment">/*      terms simply represent the results of eight shift/xor opera-      */</span><span class="token comment">/*      tions for all combinations of data and CRC register values.       */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*      The values must be right-shifted by eight bits by the "updcrc"    */</span><span class="token comment">/*      logic; the shift must be unsigned (bring in zeroes).  On some     */</span><span class="token comment">/*      hardware you could probably optimize the shift in assembler by    */</span><span class="token comment">/*      using byte-swap instructions.                                     */</span><span class="token comment">/*      polynomial $edb88320                                              */</span><span class="token comment">/*                                                                        */</span><span class="token comment">/*  --------------------------------------------------------------------  */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> crc32_tab<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token number">0x00000000L</span><span class="token punctuation">,</span> <span class="token number">0x77073096L</span><span class="token punctuation">,</span> <span class="token number">0xee0e612cL</span><span class="token punctuation">,</span> <span class="token number">0x990951baL</span><span class="token punctuation">,</span> <span class="token number">0x076dc419L</span><span class="token punctuation">,</span>    <span class="token number">0x706af48fL</span><span class="token punctuation">,</span> <span class="token number">0xe963a535L</span><span class="token punctuation">,</span> <span class="token number">0x9e6495a3L</span><span class="token punctuation">,</span> <span class="token number">0x0edb8832L</span><span class="token punctuation">,</span> <span class="token number">0x79dcb8a4L</span><span class="token punctuation">,</span>    <span class="token number">0xe0d5e91eL</span><span class="token punctuation">,</span> <span class="token number">0x97d2d988L</span><span class="token punctuation">,</span> <span class="token number">0x09b64c2bL</span><span class="token punctuation">,</span> <span class="token number">0x7eb17cbdL</span><span class="token punctuation">,</span> <span class="token number">0xe7b82d07L</span><span class="token punctuation">,</span>    <span class="token number">0x90bf1d91L</span><span class="token punctuation">,</span> <span class="token number">0x1db71064L</span><span class="token punctuation">,</span> <span class="token number">0x6ab020f2L</span><span class="token punctuation">,</span> <span class="token number">0xf3b97148L</span><span class="token punctuation">,</span> <span class="token number">0x84be41deL</span><span class="token punctuation">,</span>    <span class="token number">0x1adad47dL</span><span class="token punctuation">,</span> <span class="token number">0x6ddde4ebL</span><span class="token punctuation">,</span> <span class="token number">0xf4d4b551L</span><span class="token punctuation">,</span> <span class="token number">0x83d385c7L</span><span class="token punctuation">,</span> <span class="token number">0x136c9856L</span><span class="token punctuation">,</span>    <span class="token number">0x646ba8c0L</span><span class="token punctuation">,</span> <span class="token number">0xfd62f97aL</span><span class="token punctuation">,</span> <span class="token number">0x8a65c9ecL</span><span class="token punctuation">,</span> <span class="token number">0x14015c4fL</span><span class="token punctuation">,</span> <span class="token number">0x63066cd9L</span><span class="token punctuation">,</span>    <span class="token number">0xfa0f3d63L</span><span class="token punctuation">,</span> <span class="token number">0x8d080df5L</span><span class="token punctuation">,</span> <span class="token number">0x3b6e20c8L</span><span class="token punctuation">,</span> <span class="token number">0x4c69105eL</span><span class="token punctuation">,</span> <span class="token number">0xd56041e4L</span><span class="token punctuation">,</span>    <span class="token number">0xa2677172L</span><span class="token punctuation">,</span> <span class="token number">0x3c03e4d1L</span><span class="token punctuation">,</span> <span class="token number">0x4b04d447L</span><span class="token punctuation">,</span> <span class="token number">0xd20d85fdL</span><span class="token punctuation">,</span> <span class="token number">0xa50ab56bL</span><span class="token punctuation">,</span>    <span class="token number">0x35b5a8faL</span><span class="token punctuation">,</span> <span class="token number">0x42b2986cL</span><span class="token punctuation">,</span> <span class="token number">0xdbbbc9d6L</span><span class="token punctuation">,</span> <span class="token number">0xacbcf940L</span><span class="token punctuation">,</span> <span class="token number">0x32d86ce3L</span><span class="token punctuation">,</span>    <span class="token number">0x45df5c75L</span><span class="token punctuation">,</span> <span class="token number">0xdcd60dcfL</span><span class="token punctuation">,</span> <span class="token number">0xabd13d59L</span><span class="token punctuation">,</span> <span class="token number">0x26d930acL</span><span class="token punctuation">,</span> <span class="token number">0x51de003aL</span><span class="token punctuation">,</span>    <span class="token number">0xc8d75180L</span><span class="token punctuation">,</span> <span class="token number">0xbfd06116L</span><span class="token punctuation">,</span> <span class="token number">0x21b4f4b5L</span><span class="token punctuation">,</span> <span class="token number">0x56b3c423L</span><span class="token punctuation">,</span> <span class="token number">0xcfba9599L</span><span class="token punctuation">,</span>    <span class="token number">0xb8bda50fL</span><span class="token punctuation">,</span> <span class="token number">0x2802b89eL</span><span class="token punctuation">,</span> <span class="token number">0x5f058808L</span><span class="token punctuation">,</span> <span class="token number">0xc60cd9b2L</span><span class="token punctuation">,</span> <span class="token number">0xb10be924L</span><span class="token punctuation">,</span>    <span class="token number">0x2f6f7c87L</span><span class="token punctuation">,</span> <span class="token number">0x58684c11L</span><span class="token punctuation">,</span> <span class="token number">0xc1611dabL</span><span class="token punctuation">,</span> <span class="token number">0xb6662d3dL</span><span class="token punctuation">,</span> <span class="token number">0x76dc4190L</span><span class="token punctuation">,</span>    <span class="token number">0x01db7106L</span><span class="token punctuation">,</span> <span class="token number">0x98d220bcL</span><span class="token punctuation">,</span> <span class="token number">0xefd5102aL</span><span class="token punctuation">,</span> <span class="token number">0x71b18589L</span><span class="token punctuation">,</span> <span class="token number">0x06b6b51fL</span><span class="token punctuation">,</span>    <span class="token number">0x9fbfe4a5L</span><span class="token punctuation">,</span> <span class="token number">0xe8b8d433L</span><span class="token punctuation">,</span> <span class="token number">0x7807c9a2L</span><span class="token punctuation">,</span> <span class="token number">0x0f00f934L</span><span class="token punctuation">,</span> <span class="token number">0x9609a88eL</span><span class="token punctuation">,</span>    <span class="token number">0xe10e9818L</span><span class="token punctuation">,</span> <span class="token number">0x7f6a0dbbL</span><span class="token punctuation">,</span> <span class="token number">0x086d3d2dL</span><span class="token punctuation">,</span> <span class="token number">0x91646c97L</span><span class="token punctuation">,</span> <span class="token number">0xe6635c01L</span><span class="token punctuation">,</span>    <span class="token number">0x6b6b51f4L</span><span class="token punctuation">,</span> <span class="token number">0x1c6c6162L</span><span class="token punctuation">,</span> <span class="token number">0x856530d8L</span><span class="token punctuation">,</span> <span class="token number">0xf262004eL</span><span class="token punctuation">,</span> <span class="token number">0x6c0695edL</span><span class="token punctuation">,</span>    <span class="token number">0x1b01a57bL</span><span class="token punctuation">,</span> <span class="token number">0x8208f4c1L</span><span class="token punctuation">,</span> <span class="token number">0xf50fc457L</span><span class="token punctuation">,</span> <span class="token number">0x65b0d9c6L</span><span class="token punctuation">,</span> <span class="token number">0x12b7e950L</span><span class="token punctuation">,</span>    <span class="token number">0x8bbeb8eaL</span><span class="token punctuation">,</span> <span class="token number">0xfcb9887cL</span><span class="token punctuation">,</span> <span class="token number">0x62dd1ddfL</span><span class="token punctuation">,</span> <span class="token number">0x15da2d49L</span><span class="token punctuation">,</span> <span class="token number">0x8cd37cf3L</span><span class="token punctuation">,</span>    <span class="token number">0xfbd44c65L</span><span class="token punctuation">,</span> <span class="token number">0x4db26158L</span><span class="token punctuation">,</span> <span class="token number">0x3ab551ceL</span><span class="token punctuation">,</span> <span class="token number">0xa3bc0074L</span><span class="token punctuation">,</span> <span class="token number">0xd4bb30e2L</span><span class="token punctuation">,</span>    <span class="token number">0x4adfa541L</span><span class="token punctuation">,</span> <span class="token number">0x3dd895d7L</span><span class="token punctuation">,</span> <span class="token number">0xa4d1c46dL</span><span class="token punctuation">,</span> <span class="token number">0xd3d6f4fbL</span><span class="token punctuation">,</span> <span class="token number">0x4369e96aL</span><span class="token punctuation">,</span>    <span class="token number">0x346ed9fcL</span><span class="token punctuation">,</span> <span class="token number">0xad678846L</span><span class="token punctuation">,</span> <span class="token number">0xda60b8d0L</span><span class="token punctuation">,</span> <span class="token number">0x44042d73L</span><span class="token punctuation">,</span> <span class="token number">0x33031de5L</span><span class="token punctuation">,</span>    <span class="token number">0xaa0a4c5fL</span><span class="token punctuation">,</span> <span class="token number">0xdd0d7cc9L</span><span class="token punctuation">,</span> <span class="token number">0x5005713cL</span><span class="token punctuation">,</span> <span class="token number">0x270241aaL</span><span class="token punctuation">,</span> <span class="token number">0xbe0b1010L</span><span class="token punctuation">,</span>    <span class="token number">0xc90c2086L</span><span class="token punctuation">,</span> <span class="token number">0x5768b525L</span><span class="token punctuation">,</span> <span class="token number">0x206f85b3L</span><span class="token punctuation">,</span> <span class="token number">0xb966d409L</span><span class="token punctuation">,</span> <span class="token number">0xce61e49fL</span><span class="token punctuation">,</span>    <span class="token number">0x5edef90eL</span><span class="token punctuation">,</span> <span class="token number">0x29d9c998L</span><span class="token punctuation">,</span> <span class="token number">0xb0d09822L</span><span class="token punctuation">,</span> <span class="token number">0xc7d7a8b4L</span><span class="token punctuation">,</span> <span class="token number">0x59b33d17L</span><span class="token punctuation">,</span>    <span class="token number">0x2eb40d81L</span><span class="token punctuation">,</span> <span class="token number">0xb7bd5c3bL</span><span class="token punctuation">,</span> <span class="token number">0xc0ba6cadL</span><span class="token punctuation">,</span> <span class="token number">0xedb88320L</span><span class="token punctuation">,</span> <span class="token number">0x9abfb3b6L</span><span class="token punctuation">,</span>    <span class="token number">0x03b6e20cL</span><span class="token punctuation">,</span> <span class="token number">0x74b1d29aL</span><span class="token punctuation">,</span> <span class="token number">0xead54739L</span><span class="token punctuation">,</span> <span class="token number">0x9dd277afL</span><span class="token punctuation">,</span> <span class="token number">0x04db2615L</span><span class="token punctuation">,</span>    <span class="token number">0x73dc1683L</span><span class="token punctuation">,</span> <span class="token number">0xe3630b12L</span><span class="token punctuation">,</span> <span class="token number">0x94643b84L</span><span class="token punctuation">,</span> <span class="token number">0x0d6d6a3eL</span><span class="token punctuation">,</span> <span class="token number">0x7a6a5aa8L</span><span class="token punctuation">,</span>    <span class="token number">0xe40ecf0bL</span><span class="token punctuation">,</span> <span class="token number">0x9309ff9dL</span><span class="token punctuation">,</span> <span class="token number">0x0a00ae27L</span><span class="token punctuation">,</span> <span class="token number">0x7d079eb1L</span><span class="token punctuation">,</span> <span class="token number">0xf00f9344L</span><span class="token punctuation">,</span>    <span class="token number">0x8708a3d2L</span><span class="token punctuation">,</span> <span class="token number">0x1e01f268L</span><span class="token punctuation">,</span> <span class="token number">0x6906c2feL</span><span class="token punctuation">,</span> <span class="token number">0xf762575dL</span><span class="token punctuation">,</span> <span class="token number">0x806567cbL</span><span class="token punctuation">,</span>    <span class="token number">0x196c3671L</span><span class="token punctuation">,</span> <span class="token number">0x6e6b06e7L</span><span class="token punctuation">,</span> <span class="token number">0xfed41b76L</span><span class="token punctuation">,</span> <span class="token number">0x89d32be0L</span><span class="token punctuation">,</span> <span class="token number">0x10da7a5aL</span><span class="token punctuation">,</span>    <span class="token number">0x67dd4accL</span><span class="token punctuation">,</span> <span class="token number">0xf9b9df6fL</span><span class="token punctuation">,</span> <span class="token number">0x8ebeeff9L</span><span class="token punctuation">,</span> <span class="token number">0x17b7be43L</span><span class="token punctuation">,</span> <span class="token number">0x60b08ed5L</span><span class="token punctuation">,</span>    <span class="token number">0xd6d6a3e8L</span><span class="token punctuation">,</span> <span class="token number">0xa1d1937eL</span><span class="token punctuation">,</span> <span class="token number">0x38d8c2c4L</span><span class="token punctuation">,</span> <span class="token number">0x4fdff252L</span><span class="token punctuation">,</span> <span class="token number">0xd1bb67f1L</span><span class="token punctuation">,</span>    <span class="token number">0xa6bc5767L</span><span class="token punctuation">,</span> <span class="token number">0x3fb506ddL</span><span class="token punctuation">,</span> <span class="token number">0x48b2364bL</span><span class="token punctuation">,</span> <span class="token number">0xd80d2bdaL</span><span class="token punctuation">,</span> <span class="token number">0xaf0a1b4cL</span><span class="token punctuation">,</span>    <span class="token number">0x36034af6L</span><span class="token punctuation">,</span> <span class="token number">0x41047a60L</span><span class="token punctuation">,</span> <span class="token number">0xdf60efc3L</span><span class="token punctuation">,</span> <span class="token number">0xa867df55L</span><span class="token punctuation">,</span> <span class="token number">0x316e8eefL</span><span class="token punctuation">,</span>    <span class="token number">0x4669be79L</span><span class="token punctuation">,</span> <span class="token number">0xcb61b38cL</span><span class="token punctuation">,</span> <span class="token number">0xbc66831aL</span><span class="token punctuation">,</span> <span class="token number">0x256fd2a0L</span><span class="token punctuation">,</span> <span class="token number">0x5268e236L</span><span class="token punctuation">,</span>    <span class="token number">0xcc0c7795L</span><span class="token punctuation">,</span> <span class="token number">0xbb0b4703L</span><span class="token punctuation">,</span> <span class="token number">0x220216b9L</span><span class="token punctuation">,</span> <span class="token number">0x5505262fL</span><span class="token punctuation">,</span> <span class="token number">0xc5ba3bbeL</span><span class="token punctuation">,</span>    <span class="token number">0xb2bd0b28L</span><span class="token punctuation">,</span> <span class="token number">0x2bb45a92L</span><span class="token punctuation">,</span> <span class="token number">0x5cb36a04L</span><span class="token punctuation">,</span> <span class="token number">0xc2d7ffa7L</span><span class="token punctuation">,</span> <span class="token number">0xb5d0cf31L</span><span class="token punctuation">,</span>    <span class="token number">0x2cd99e8bL</span><span class="token punctuation">,</span> <span class="token number">0x5bdeae1dL</span><span class="token punctuation">,</span> <span class="token number">0x9b64c2b0L</span><span class="token punctuation">,</span> <span class="token number">0xec63f226L</span><span class="token punctuation">,</span> <span class="token number">0x756aa39cL</span><span class="token punctuation">,</span>    <span class="token number">0x026d930aL</span><span class="token punctuation">,</span> <span class="token number">0x9c0906a9L</span><span class="token punctuation">,</span> <span class="token number">0xeb0e363fL</span><span class="token punctuation">,</span> <span class="token number">0x72076785L</span><span class="token punctuation">,</span> <span class="token number">0x05005713L</span><span class="token punctuation">,</span>    <span class="token number">0x95bf4a82L</span><span class="token punctuation">,</span> <span class="token number">0xe2b87a14L</span><span class="token punctuation">,</span> <span class="token number">0x7bb12baeL</span><span class="token punctuation">,</span> <span class="token number">0x0cb61b38L</span><span class="token punctuation">,</span> <span class="token number">0x92d28e9bL</span><span class="token punctuation">,</span>    <span class="token number">0xe5d5be0dL</span><span class="token punctuation">,</span> <span class="token number">0x7cdcefb7L</span><span class="token punctuation">,</span> <span class="token number">0x0bdbdf21L</span><span class="token punctuation">,</span> <span class="token number">0x86d3d2d4L</span><span class="token punctuation">,</span> <span class="token number">0xf1d4e242L</span><span class="token punctuation">,</span>    <span class="token number">0x68ddb3f8L</span><span class="token punctuation">,</span> <span class="token number">0x1fda836eL</span><span class="token punctuation">,</span> <span class="token number">0x81be16cdL</span><span class="token punctuation">,</span> <span class="token number">0xf6b9265bL</span><span class="token punctuation">,</span> <span class="token number">0x6fb077e1L</span><span class="token punctuation">,</span>    <span class="token number">0x18b74777L</span><span class="token punctuation">,</span> <span class="token number">0x88085ae6L</span><span class="token punctuation">,</span> <span class="token number">0xff0f6a70L</span><span class="token punctuation">,</span> <span class="token number">0x66063bcaL</span><span class="token punctuation">,</span> <span class="token number">0x11010b5cL</span><span class="token punctuation">,</span>    <span class="token number">0x8f659effL</span><span class="token punctuation">,</span> <span class="token number">0xf862ae69L</span><span class="token punctuation">,</span> <span class="token number">0x616bffd3L</span><span class="token punctuation">,</span> <span class="token number">0x166ccf45L</span><span class="token punctuation">,</span> <span class="token number">0xa00ae278L</span><span class="token punctuation">,</span>    <span class="token number">0xd70dd2eeL</span><span class="token punctuation">,</span> <span class="token number">0x4e048354L</span><span class="token punctuation">,</span> <span class="token number">0x3903b3c2L</span><span class="token punctuation">,</span> <span class="token number">0xa7672661L</span><span class="token punctuation">,</span> <span class="token number">0xd06016f7L</span><span class="token punctuation">,</span>    <span class="token number">0x4969474dL</span><span class="token punctuation">,</span> <span class="token number">0x3e6e77dbL</span><span class="token punctuation">,</span> <span class="token number">0xaed16a4aL</span><span class="token punctuation">,</span> <span class="token number">0xd9d65adcL</span><span class="token punctuation">,</span> <span class="token number">0x40df0b66L</span><span class="token punctuation">,</span>    <span class="token number">0x37d83bf0L</span><span class="token punctuation">,</span> <span class="token number">0xa9bcae53L</span><span class="token punctuation">,</span> <span class="token number">0xdebb9ec5L</span><span class="token punctuation">,</span> <span class="token number">0x47b2cf7fL</span><span class="token punctuation">,</span> <span class="token number">0x30b5ffe9L</span><span class="token punctuation">,</span>    <span class="token number">0xbdbdf21cL</span><span class="token punctuation">,</span> <span class="token number">0xcabac28aL</span><span class="token punctuation">,</span> <span class="token number">0x53b39330L</span><span class="token punctuation">,</span> <span class="token number">0x24b4a3a6L</span><span class="token punctuation">,</span> <span class="token number">0xbad03605L</span><span class="token punctuation">,</span>    <span class="token number">0xcdd70693L</span><span class="token punctuation">,</span> <span class="token number">0x54de5729L</span><span class="token punctuation">,</span> <span class="token number">0x23d967bfL</span><span class="token punctuation">,</span> <span class="token number">0xb3667a2eL</span><span class="token punctuation">,</span> <span class="token number">0xc4614ab8L</span><span class="token punctuation">,</span>    <span class="token number">0x5d681b02L</span><span class="token punctuation">,</span> <span class="token number">0x2a6f2b94L</span><span class="token punctuation">,</span> <span class="token number">0xb40bbe37L</span><span class="token punctuation">,</span> <span class="token number">0xc30c8ea1L</span><span class="token punctuation">,</span> <span class="token number">0x5a05df1bL</span><span class="token punctuation">,</span>    <span class="token number">0x2d02ef8dL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 根据输入的字符串计算一个 64 位的 CRC</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">crc32</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> crc32val<span class="token punctuation">;</span>    crc32val <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span>  i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        crc32val <span class="token operator">=</span> crc32_tab<span class="token punctuation">[</span><span class="token punctuation">(</span>crc32val <span class="token operator">^</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">]</span> <span class="token operator">^</span> <span class="token punctuation">(</span>crc32val <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> crc32val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们的哈希表使用 <code>knuth multiplicative</code> 方法将字符串转为CRC，另一个可用的方法是 <code>Murmur3</code>，但是我也不清楚什么才是最佳的哈希算法。</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>接下来我们会用到列表 <code>list</code>，虽然 <code>vector</code> 可以通过他的缓存友好性来提升一些性能，但是对于我们的需求来说也没有太大的收益。O(1)的数据插入复杂度对于我们来说完全足够使用了。我们的列表会基于一个单向链表，带有头部和尾部的指针，这样可以保证我们从两侧插入时的复杂度都为O(1)。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/list.h</span></div><code class="language-c"><span class="token comment">// 节点</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 列表</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>head<span class="token punctuation">;</span> <span class="token comment">// 头指针</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span> <span class="token comment">// 尾指针</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> List<span class="token punctuation">;</span><span class="token comment">// 比较函数接口, 用来比较两个节点</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compare_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建列表</span>List <span class="token operator">*</span><span class="token function">list_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放链表, 通过一个 int 的标志来决定释放深度</span><span class="token comment">// 例如：判断是否需要释放所有的节点中的数据</span><span class="token keyword">void</span> <span class="token function">list_release</span><span class="token punctuation">(</span>List <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 当前大小</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">list_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空链表, 但保留链表本身, 根据 int 判断是否释放节点中的数据</span><span class="token keyword">void</span> <span class="token function">list_clear</span><span class="token punctuation">(</span>List <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在头部插入数据</span>List <span class="token operator">*</span><span class="token function">list_push</span><span class="token punctuation">(</span>List <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在尾部插入数据</span>List <span class="token operator">*</span><span class="token function">list_push_back</span><span class="token punctuation">(</span>List <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过传入的比较函数, 删除和第二参数相同的节点</span><span class="token keyword">void</span> <span class="token function">list_remove</span><span class="token punctuation">(</span>List <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> compare_func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除一个节点并返回被删除的节点</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_remove_node</span><span class="token punctuation">(</span>List <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> compare_func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 另一个比较函数接口, 用来进行合并或排序</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 再 cmp_func 计算的位置插入一个节点</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_sort_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> compare_func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将 list 从中间分为两份</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">bisect_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/list.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">// 私有的删除节点函数</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_node_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">,</span> compare_func<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建列表</span>List <span class="token operator">*</span><span class="token function">list_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    List <span class="token operator">*</span>l <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 默认值</span>    l<span class="token operator">-></span>head <span class="token operator">=</span> l<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    l<span class="token operator">-></span>len <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>    <span class="token comment">// TODO 默认析构</span>    l<span class="token operator">-></span>destructor <span class="token operator">=</span> destructor<span class="token punctuation">;</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放列表</span><span class="token keyword">void</span> <span class="token function">list_release</span><span class="token punctuation">(</span>List <span class="token operator">*</span>l<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>h <span class="token operator">=</span> l<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token comment">// 释放所有节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>len<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tmp <span class="token operator">=</span> h<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>destructor<span class="token punctuation">)</span>            l<span class="token operator">-></span><span class="token function">destructor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果需要释放数据</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token operator">-></span>data <span class="token operator">&amp;&amp;</span> deep <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token function">free</span><span class="token punctuation">(</span>h<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">free</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        h <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放列表本身</span>    <span class="token function">free</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">list_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> list<span class="token operator">-></span>len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 清空链表, 但保留链表本身, 根据 int 判断是否释放节点中的数据</span><span class="token keyword">void</span> <span class="token function">list_clear</span><span class="token punctuation">(</span>List <span class="token operator">*</span>l<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>l <span class="token operator">||</span> <span class="token operator">!</span>l<span class="token operator">-></span>head<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>h <span class="token operator">=</span> l<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>    <span class="token comment">// 释放所有节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>len<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tmp <span class="token operator">=</span> h<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token operator">-></span>data <span class="token operator">&amp;&amp;</span> deep <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token function">free</span><span class="token punctuation">(</span>h<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        h <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    l<span class="token operator">-></span>head <span class="token operator">=</span> l<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    l<span class="token operator">-></span>len <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 插入一个数据到头部</span>List <span class="token operator">*</span><span class="token function">list_push</span><span class="token punctuation">(</span>List <span class="token operator">*</span>l<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>new_node <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_node<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    new_node<span class="token operator">-></span>data <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token comment">// 第一个数据即使头也是尾</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        l<span class="token operator">-></span>head <span class="token operator">=</span> l<span class="token operator">-></span>tail <span class="token operator">=</span> new_node<span class="token punctuation">;</span>        new_node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 插入为头部</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        new_node<span class="token operator">-></span>next <span class="token operator">=</span> l<span class="token operator">-></span>head<span class="token punctuation">;</span>        l<span class="token operator">-></span>head <span class="token operator">=</span> new_node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    l<span class="token operator">-></span>len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 插入一个数据到尾部</span>List <span class="token operator">*</span><span class="token function">list_push_back</span><span class="token punctuation">(</span>List <span class="token operator">*</span>l<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>new_node <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_node<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    new_node<span class="token operator">-></span>data <span class="token operator">=</span> val<span class="token punctuation">;</span>    new_node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        l<span class="token operator">-></span>head <span class="token operator">=</span> l<span class="token operator">-></span>tail <span class="token operator">=</span> new_node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        l<span class="token operator">-></span>tail<span class="token operator">-></span>next <span class="token operator">=</span> new_node<span class="token punctuation">;</span>        l<span class="token operator">-></span>tail <span class="token operator">=</span> new_node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    l<span class="token operator">-></span>len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过传入的比较函数, 删除一个节点</span><span class="token keyword">void</span> <span class="token function">list_remove</span><span class="token punctuation">(</span>List <span class="token operator">*</span>l<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span> compare_func cmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>l <span class="token operator">||</span> <span class="token operator">!</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// list_node_remove 会递归的一层一层返回下一个节点指针, 并在其中去除被删除的节点</span>    l<span class="token operator">-></span>head <span class="token operator">=</span> <span class="token function">list_node_remove</span><span class="token punctuation">(</span>l<span class="token operator">-></span>head<span class="token punctuation">,</span> node<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    l<span class="token operator">-></span>len <span class="token operator">-=</span> counter<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除节点的工具方法</span><span class="token comment">// return 递归用的返回, 删除成功后的那次调用会返回被删除节点的 next</span><span class="token comment">// head 传入遍历起点</span><span class="token comment">// node 需要删除的节点的样子</span><span class="token comment">// cmp 比较函数, 用来比较遍历的节点和传入的node</span><span class="token comment">// counter 被删除节点的数量, 0 或者 1</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_node_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>head<span class="token punctuation">,</span>                                          <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span>                                          compare_func cmp<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>tmp_next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">// 译者认为这里没有考虑节点的data也可能需要释放, 或者是作者觉得可以在cmp中释放？</span>        <span class="token function">free</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">// 匹配成功就 return 的话，这里实际只能删除第一个匹配的节点</span>        <span class="token punctuation">(</span><span class="token operator">*</span>counter<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> tmp_next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">list_node_remove</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">,</span> node<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除一个节点的工具方法</span><span class="token comment">// return 递归的返回</span><span class="token comment">// head 查询起点</span><span class="token comment">// data 被删除的 node 的形状</span><span class="token comment">// ret 返回被删除的 node</span><span class="token comment">// cmp 比较函数</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_remove_single_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>head<span class="token punctuation">,</span>                                                 <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span>                                                 <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token operator">*</span>ret<span class="token punctuation">,</span>                                                 compare_func cmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>tmp_next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">*</span>ret <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> tmp_next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">list_remove_single_node</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">,</span> data<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除一个节点并返回被删除的节点</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_remove_node</span><span class="token punctuation">(</span>List <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> compare_func cmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>len <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>list<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">list_remove_single_node</span><span class="token punctuation">(</span>list<span class="token operator">-></span>head<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>node<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token operator">-></span>len<span class="token operator">--</span><span class="token punctuation">;</span>        node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 在 cmp_func 计算的位置插入一个节点</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">list_sort_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token operator">*</span>head<span class="token punctuation">,</span>                                   <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>new<span class="token punctuation">,</span> cmp cmp_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>head <span class="token operator">||</span> <span class="token function">cmp_func</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token punctuation">,</span> new<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        new<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>        <span class="token operator">*</span>head <span class="token operator">=</span> new<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> <span class="token function">cmp_func</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>next<span class="token punctuation">,</span> new<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        new<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> new<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 返回一个靠近中间的 node, 并且已经将原 list 从此处截断</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span><span class="token function">bisect_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// fast 的移动速度是 slow 的两倍</span>    <span class="token comment">// prev 表示 slow的前一个节点, 也就是截取后的第一个 list 的最后一个节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>fast <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>slow <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        prev <span class="token operator">=</span> slow<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        prev<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> slow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我们成功的实现了两个经典的数据结构，这样我们可以在项目中使用他们：</p><ul><li>哈希表</li><li>列表</li></ul><p>下一个要实现的数据结构是 <strong>特里树</strong>，他可以让我们轻松的维护我们的主题和主题的分层结构。</p>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 第三部分：服务</title>
    <link href="/translate-sol-3.html"/>
    <url>/translate-sol-3.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker-p3/">Sol - An MQTT broker from scratch. Part 3 - Server</a></p></blockquote><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一部分我们会实现我们程序中的服务功能，通过之前在 <a href="https://codepr.github.io/posts/sol-mqtt-broker-p2/">part-2</a> 中实现的 <code>network</code> 模块，我们可以比较轻松的接收并处理在 <a href="https://codepr.github.io/posts/sol-mqtt-broker/">part-1</a> 中定义好的各种 <code>MQTT</code> 数据包。</p><h1 id="服务端定义"><a href="#服务端定义" class="headerlink" title="服务端定义"></a>服务端定义</h1><p>我们的头文件非常简单，唯一向外提供的函数只有 <code>start_server</code>，他也只需要接收两个参数：</p><ul><li>一个IP地址</li><li>一个监听端口</li></ul><p>我们还需要定义创建 <strong>epoll</strong> 时使用的两个常量，一个是单次监听的最大事件数量，另一个是 <strong>epoll</strong> 监听的超时时间。这两个常量的定义以后我们也可以轻松的移动到配置模块里，暂时就先放在 <code>server</code> 的头文件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.h</span></div><code class="language-c"><span class="token comment">// epoll 的默认配置</span><span class="token comment">// 最大监听 256 事件</span><span class="token comment">// -1 表示不超时, epoll 可以无限期的阻塞并监听</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLL_MAX_EVENTS</span>    <span class="token expression"><span class="token number">256</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPOLL_TIMEOUT</span>       <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span><span class="token comment">// 不同类型的错误码</span><span class="token comment">// client disconnection 客户端断开</span><span class="token comment">// error reading packet 读包错误</span><span class="token comment">// error packet sent exceeds size defined by configuration 包过大 (限制默认 2M)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERRCLIENTDC</span>         <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERRPACKETERR</span>        <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERRMAXREQSIZE</span>       <span class="token expression"><span class="token number">3</span></span></span><span class="token comment">// handler 的返回值, 表示对客户端读取后的下一个动作是读还是写</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REARM_R</span>             <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REARM_W</span>             <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">// 启动服务的函数</span><span class="token keyword">int</span> <span class="token function">start_server</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>实现的部分比我一开始预想的要庞大一些，所有我们所需的 <code>处理器(handler)</code> 和 回调函数都会在这里定义。所以我们首先来实现三个最基础的回调函数，这三个函数是任何服务器都必不可少的：</p><ul><li>用于建立连接的 <code>on_accept</code></li><li>用于读取事件的 <code>on_read</code></li><li>用于发送数据的 <code>on_write</code></li></ul><p>我们还需要定义一些关于MQTT包处理的 <code>handler</code>，同样使用一个数组保存，并且使 <code>handler</code> 在其中的序号等于包类型码。（这个方式我们已经用过好几次了）</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_POSIX_C_SOURCE</span> <span class="token expression"><span class="token number">200809L</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pack.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mqtt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"core.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"network.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hashtable.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"server.h"</span></span><span class="token comment">/* Seconds in a Sol, easter egg */</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">double</span> SOL_SECONDS <span class="token operator">=</span> <span class="token number">88775.24</span><span class="token punctuation">;</span><span class="token comment">// 服务器本身状态信息</span><span class="token comment">// 所有数据都会通过一个周期性回调发布</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sol_info</span> info<span class="token punctuation">;</span><span class="token comment">// broker 的全局实例, 包括了主题树和客户端的哈希表</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sol</span> sol<span class="token punctuation">;</span><span class="token comment">// 处理器接口</span><span class="token comment">// 内含客户端的 closure 与数据包 mqtt_packet</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 包处理器, 每个函数负责处理对应名称的包</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">connect_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">disconnect_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">subscribe_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">unsubscribe_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">publish_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">puback_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pubrec_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pubrel_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pubcomp_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">pingreq_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 处理器数组, 同样使用 type 的值作为索引</span><span class="token keyword">static</span> handler <span class="token operator">*</span>handlers<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    connect_handler<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    publish_handler<span class="token punctuation">,</span>    puback_handler<span class="token punctuation">,</span>    pubrec_handler<span class="token punctuation">,</span>    pubrel_handler<span class="token punctuation">,</span>    pubcomp_handler<span class="token punctuation">,</span>    subscribe_handler<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    unsubscribe_handler<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    pingreq_handler<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    disconnect_handler<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 本 module 内部使用的 conn 结构体, 用来接收新连接</span><span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>INET_ADDRSTRLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// I/O closures, 关于三个服务器主要操作的回调</span><span class="token comment">// - 读取客户端发来的数据</span><span class="token comment">// - 向客户端写数据</span><span class="token comment">// - 接收新的客户端连接</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定时回调, 周期性发布服务器状态</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publish_stats</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从 sfd 接收一条新链接, 将他的 ip 和 fd 存入conn中</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">accept_new_client</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">connection</span> <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>conn<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 获得新链接</span>    <span class="token keyword">int</span> clientsock <span class="token operator">=</span> <span class="token function">accept_connection</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没有获取成功的话</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clientsock <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 就是检查一些新连接的属性</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getpeername</span><span class="token punctuation">(</span>clientsock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ip_buff<span class="token punctuation">[</span>INET_ADDRSTRLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inet_ntop</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">,</span> ip_buff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ip_buff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> sin<span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> sinlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getsockname</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>sin<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sinlen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 赋值我们要的 ip 和 fd</span>    conn<span class="token operator">-></span>fd <span class="token operator">=</span> clientsock<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>conn<span class="token operator">-></span>ip<span class="token punctuation">,</span> ip_buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// accept 的回调, 通过 sfd 获得 cfd, 然后对 cfd 添加 EPOLLIN 监听</span><span class="token comment">// loop evloop实例</span><span class="token comment">// arg server closure, 包括了 sfd 在其中, on_accept 其实就是 server closure 的 call 参数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// arg 是 server closure</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>server <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">connection</span> conn<span class="token punctuation">;</span>    <span class="token comment">// 获得 conn</span>    <span class="token function">accept_new_client</span><span class="token punctuation">(</span>server<span class="token operator">-></span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建这个客户端的 closure</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>client_closure <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>client_closure<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>client_closure<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 填充内容</span>    client_closure<span class="token operator">-></span>fd <span class="token operator">=</span> conn<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>    client_closure<span class="token operator">-></span>obj <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                 <span class="token comment">// 闭包的主要对象, 这个项目中是 client 对象, 在第六部分定义</span>    client_closure<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    client_closure<span class="token operator">-></span>args <span class="token operator">=</span> client_closure<span class="token punctuation">;</span>      <span class="token comment">// 拿自己当回调参数</span>    client_closure<span class="token operator">-></span>call <span class="token operator">=</span> on_read<span class="token punctuation">;</span>             <span class="token comment">// 数据来时触发 on_read</span>    <span class="token function">generate_uuid</span><span class="token punctuation">(</span>client_closure<span class="token operator">-></span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 生成uuid</span>    <span class="token comment">// 保存在一个哈希表里</span>    <span class="token function">hashtable_put</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>closures<span class="token punctuation">,</span> client_closure<span class="token operator">-></span>closure_id<span class="token punctuation">,</span> client_closure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将这个 closure 注册到 evloop, 事件是 EPOLLIN</span>    <span class="token function">evloop_add_callback</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> client_closure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 重置 server fd, 让其可以继续接收新链接</span>    <span class="token function">evloop_rearm_callback_read</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> server<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录新链接</span>    info<span class="token punctuation">.</span>nclients<span class="token operator">++</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>nconnections<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 日志</span>    <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"New connection from %s on port %s"</span><span class="token punctuation">,</span> conn<span class="token punctuation">.</span>ip<span class="token punctuation">,</span> conf<span class="token operator">-></span>port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正如你所见，我定义了两个静态函数（在C语言中，当我们不严格的追究术语时，由于这种静态函数只能被同样.c文件里的函数访问，我们可以把这种函数看作是其他OOP语言中的私有方法。）</p><p><code>accept_new_client</code> 函数使用了上一篇文中 <code>network</code> 模块定义的 <code>accept_connection</code> 函数，得以从操作系统层级接收新连接并进行一些设置。<code>on_accept</code> 则是实际负责处理新链接的回调函数，他依赖 <code>accept_new_client</code> 函数。</p><p><code>accept_new_client</code> 函数所需的参数结构 <code>connection</code> 是我从我其他项目的代码库复制过来的，并不是说必须要用这种方式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// 接收数据流组装成数据包的函数, 被 on_read 回调使用</span><span class="token comment">// 解析数据包头, 至少会包括 Fixed Header, 因为每个数据包都至少有 2byte 的 Fixed Header, 其中会包括包类型和剩余长度</span><span class="token comment">// 入参包括</span><span class="token comment">// clientfd 客户端fd</span><span class="token comment">// buf 放置所有输入数据流</span><span class="token comment">// command 表示mqtt包的第一个字节</span><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">recv_packet</span><span class="token punctuation">(</span><span class="token keyword">int</span> clientfd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 总计读取的字节数</span>    <span class="token class-name">ssize_t</span> nbytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 读取一个字节, 这里会包括 MQTT 类型字段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nbytes <span class="token operator">=</span> <span class="token function">recv_bytes</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte <span class="token operator">=</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    buf<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 译者没有明白为何可以这样比较, 第一个byte应该是包括了 MQTT type 和 Flags 才对?</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>DISCONNECT <span class="token operator">&lt;</span> byte <span class="token operator">||</span> CONNECT <span class="token operator">></span> byte<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ERRPACKETERR<span class="token punctuation">;</span>    <span class="token comment">// 逐字节读取变长的 Remaining Length</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用 buf 读取</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">recv_bytes</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> buf<span class="token operator">+</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>ERRCLIENTDC<span class="token punctuation">;</span>        <span class="token comment">// 并为 buff 赋值</span>        buff<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        nbytes <span class="token operator">+=</span> n<span class="token punctuation">;</span>        <span class="token comment">// 根据高位判断是否有后续</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>buff<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获得剩余长度的值</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>pbuf <span class="token operator">=</span> <span class="token operator">&amp;</span>buff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> tlen <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断是否过长</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tlen <span class="token operator">></span> conf<span class="token operator">-></span>max_request_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nbytes <span class="token operator">=</span> <span class="token operator">-</span>ERRMAXREQSIZE<span class="token punctuation">;</span>        <span class="token keyword">goto</span> exit<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 读取所有剩余的字节数, 获得完整数据包字节流</span>    <span class="token comment">// 译者认为这里 buf + 1 只考虑了 Remaining Length 长度为 1 的情况, 应改为 buf + count</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">recv_bytes</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> buf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>    nbytes <span class="token operator">+=</span> n<span class="token punctuation">;</span>    <span class="token comment">// 第一个字节赋值为 command</span>    <span class="token operator">*</span>command <span class="token operator">=</span> byte<span class="token punctuation">;</span>exit<span class="token operator">:</span>    <span class="token keyword">return</span> nbytes<span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">shutdown</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nbytes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 客户端输入数据的回调, 当 accepted 或 reply 之后等待</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里带着一些客户端信息</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token comment">// 使用最大数据包尺寸准备接收数据 默认2M</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>conf<span class="token operator">-></span>max_request_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 在此处必须完整的接收一个数据包的所有数据</span>    <span class="token comment">// 通过数据包的 Remaining Length 我们可以了解这个数据包的长度到底应该是多少</span>    bytes <span class="token operator">=</span> <span class="token function">recv_packet</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 链接断开处理</span>    <span class="token comment">// TODO: 使用一个 error_handler 来处理 ERRMAXREQSIZE 将错误码返回给客户端</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">==</span> <span class="token operator">-</span>ERRCLIENTDC <span class="token operator">||</span> bytes <span class="token operator">==</span> <span class="token operator">-</span>ERRMAXREQSIZE<span class="token punctuation">)</span>        <span class="token keyword">goto</span> exit<span class="token punctuation">;</span>    <span class="token comment">// 当我们收到一个错误的包时, 我们需要清理 buffer, 并断开这个客户端连接</span>    <span class="token comment">// 等客户端下次重连上来再处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">==</span> <span class="token operator">-</span>ERRPACKETERR<span class="token punctuation">)</span>        <span class="token keyword">goto</span> errdc<span class="token punctuation">;</span>    <span class="token comment">// 收包计数器</span>    info<span class="token punctuation">.</span>bytes_recv<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 将数据流解码为正确类型的mqtt包</span>    <span class="token keyword">union</span> mqtt_packet packet<span class="token punctuation">;</span>    <span class="token function">unpack_mqtt_packet</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">union</span> mqtt_header hdr <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>byte <span class="token operator">=</span> command <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 然后找到对应的 hander 来处理这个包</span>    <span class="token comment">// 处理完的rc表示</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> handlers<span class="token punctuation">[</span>hdr<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果处理结果是需要发送一个包作为响应</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">==</span> REARM_W<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 重置写入监听</span>        <span class="token comment">// 当 fd 可写入时 epoll 就会触发 EPOLLOUT 事件</span>        <span class="token comment">// cb 中的 call 会被执行, 也就是 on_write</span>        <span class="token comment">// 写入需要的参数, 会在 handlers 中会处理好, 之后由 cb 携带 </span>        cb<span class="token operator">-></span>call <span class="token operator">=</span> on_write<span class="token punctuation">;</span>        <span class="token function">evloop_rearm_callback_write</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">==</span> REARM_R<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 重置读取监听, 后面有数据接着读</span>        cb<span class="token operator">-></span>call <span class="token operator">=</span> on_read<span class="token punctuation">;</span>        <span class="token function">evloop_rearm_callback_read</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Disconnect packet received</span>exit<span class="token operator">:</span>    <span class="token function">free</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>errdc<span class="token operator">:</span>    <span class="token function">free</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 把客户端丢弃了</span>    <span class="token function">sol_error</span><span class="token punctuation">(</span><span class="token string">"Dropping client"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shutdown</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清理哈希表</span>    <span class="token function">hashtable_del</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>clients<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hashtable_del</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>closures<span class="token punctuation">,</span> cb<span class="token operator">-></span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录信息</span>    info<span class="token punctuation">.</span>nclients<span class="token operator">--</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>nconnections<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 写入回调, 当有需要写入的数据且 fd 可被写入时触发</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token class-name">ssize_t</span> sent<span class="token punctuation">;</span>    <span class="token comment">// cb 里包括了所有需要发送的内容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sent <span class="token operator">=</span> <span class="token function">send_bytes</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>fd<span class="token punctuation">,</span> cb<span class="token operator">-></span>payload<span class="token operator">-></span>data<span class="token punctuation">,</span> cb<span class="token operator">-></span>payload<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">sol_error</span><span class="token punctuation">(</span><span class="token string">"Error writing on socket to client %s: %s"</span><span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span><span class="token punctuation">)</span> cb<span class="token operator">-></span>obj<span class="token punctuation">)</span><span class="token operator">-></span>client_id<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发包计数器</span>    info<span class="token punctuation">.</span>bytes_sent <span class="token operator">+=</span> sent<span class="token punctuation">;</span>    <span class="token comment">// 释放</span>    <span class="token function">bytestring_release</span><span class="token punctuation">(</span>cb<span class="token operator">-></span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    cb<span class="token operator">-></span>payload <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 客户端的下一次触发肯定是 read (业务上来说服务端不可能连续发两个包)</span>    cb<span class="token operator">-></span>call <span class="token operator">=</span> on_read<span class="token punctuation">;</span>    <span class="token function">evloop_rearm_callback_read</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们又添加了三个静态函数，<code>recv_packet</code> 函数就像他的名字一样，依赖 <code>mqtt</code> 模块，负责持续接收数据流直到足够一个完整的 MQTT 包。另外两个分别是 <code>on_read</code> 和 <code>on_write</code>。</p><p>请注意，<code>on_read</code> 和 <code>on_write</code> 使用我们之前定义的函数不停的重置对 <code>socket</code> 的监听，就像来回打乒乓球一样。例如， <code>on_read</code> 可以通过 <code>处理器</code> 的返回值来决定下一次的操作是 <code>read</code> 还是 <code>write</code>，然后把客户端链接的下一个回调函数设置为 <code>on_read</code> 或者 <code>on_write</code>，当然也有可能是断开链接。比如说客户端发来的数据出现了错误，或者当客户端发来了 <code>DISCONNECT</code> 包，那么此时对应的 <code>处理器</code> 返回的值就既不是 <code>REARM_W</code> 也不是 <code>REARM_R</code>。</p><p>在 <code>on_write</code> 中我们看到 <code>send_bytes</code> 传入了一个带有大小和内容的 <code>payload</code>，这里使用了我定义的一个方便的工具结构 <code>bytestring</code>，我们现在就在 <code>src/pack.h</code> and <code>src/pack.c</code> 中添加他。</p><h1 id="工具-bytestring"><a href="#工具-bytestring" class="headerlink" title="工具 bytestring"></a>工具 bytestring</h1><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/pack.h</span></div><code class="language-c"><span class="token comment">// bytestring 结构体, 提供了一个便携的保存 bytes 的方法</span><span class="token comment">// 他本质上提供了一个指向最后编辑位置的指针, 和 bytes 的总长度</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> last<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// bytestring 的初始化函数, 需要一个长度作为参数</span><span class="token comment">// 为了简化, 我们直接采用固定长度, 并且不会再后续使用过程中扩容</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span><span class="token function">bytestring_create</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bytestring_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bytestring_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bytestring_reset</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里是关于 <code>bytestring</code> 的实现。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/pack.c</span></div><code class="language-c"><span class="token comment">// 创建</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span><span class="token function">bytestring_create</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span>bstring <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>bstring<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bytestring_init</span><span class="token punctuation">(</span>bstring<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 初始化内部结构</span><span class="token keyword">void</span> <span class="token function">bytestring_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span>bstring<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bstring<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    bstring<span class="token operator">-></span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>    bstring<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bytestring_reset</span><span class="token punctuation">(</span>bstring<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放</span><span class="token keyword">void</span> <span class="token function">bytestring_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span>bstring<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bstring<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>bstring<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>bstring<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 清空数据</span><span class="token keyword">void</span> <span class="token function">bytestring_reset</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span>bstring<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bstring<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    bstring<span class="token operator">-></span>last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bstring<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bstring<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="日志和通用工具"><a href="#日志和通用工具" class="headerlink" title="日志和通用工具"></a>日志和通用工具</h1><p>让我们稍微打断一下主线，按照我的经验，到这个阶段我们往往会需要一些工具函数，我一般会把他们统一放在 <code>util</code> 包中。我们刚才已经看到了一些 <code>sol_info</code>, <code>sol_debug</code> 或者 <code>sol_error</code> 这样的函数，其实就是 <code>util</code> 包中的定义。</p><p>我们的日志需求很简单，所以不需要专门做一个日志模块，就先放到 <code>util</code> 包里。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/util.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;strings.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UUID_LEN</span>     <span class="token expression"><span class="token number">37</span>  </span><span class="token comment">// 36 + nul char</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_LOG_SIZE</span> <span class="token expression"><span class="token number">119</span></span></span><span class="token keyword">enum</span> <span class="token class-name">log_level</span> <span class="token punctuation">&#123;</span> DEBUG<span class="token punctuation">,</span> INFORMATION<span class="token punctuation">,</span> WARNING<span class="token punctuation">,</span> ERROR <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">number_len</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">parse_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">generate_uuid</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">remove_occur</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">append_string</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 日志相关</span><span class="token keyword">void</span> <span class="token function">sol_log_init</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sol_log_close</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sol_log</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">log</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">sol_log</span><span class="token punctuation">(</span> __VA_ARGS__ <span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sol_debug</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">log</span><span class="token punctuation">(</span>DEBUG<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sol_warning</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">log</span><span class="token punctuation">(</span>WARNING<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sol_error</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">log</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sol_info</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">log</span><span class="token punctuation">(</span>INFORMATION<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">STREQ</span><span class="token expression"><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token function">strncasecmp</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> true <span class="token operator">:</span> false</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>log函数设置了一些宏定义，方便我们使用不同级别的日志。我们还做了一个 <code>STREQ</code> 用来比较两个字符串是否相等。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/util.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;uuid/uuid.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token keyword">static</span> FILE <span class="token operator">*</span>fh <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">// 通过文件保存日志</span><span class="token keyword">void</span> <span class="token function">sol_log_init</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    fh <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"a+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fh<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lu * WARNING: Unable to open file %s\n"</span><span class="token punctuation">,</span>               <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sol_log_close</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fflush</span><span class="token punctuation">(</span>fh<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fclose</span><span class="token punctuation">(</span>fh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 按级别写入内容</span><span class="token keyword">void</span> <span class="token function">sol_log</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    va_list ap<span class="token punctuation">;</span>    <span class="token keyword">char</span> msg<span class="token punctuation">[</span>MAX_LOG_SIZE <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">&lt;</span> conf<span class="token operator">-></span>loglevel<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vsnprintf</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> ap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>ap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 过长的信息会被截取, 然后加 ...</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>msg <span class="token operator">+</span> MAX_LOG_SIZE<span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">[</span>MAX_LOG_SIZE <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token comment">// Distinguish message level prefix</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mark <span class="token operator">=</span> <span class="token string">"#i*!"</span><span class="token punctuation">;</span>    <span class="token comment">// 同时写向标准输出和日志文件</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">stdout</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%lu %c %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh<span class="token punctuation">)</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span>fh<span class="token punctuation">,</span> <span class="token string">"%lu %c %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh<span class="token punctuation">)</span>        <span class="token function">fflush</span><span class="token punctuation">(</span>fh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获得一个数字的字符串长度 如 number_len(321) => 3</span><span class="token keyword">int</span> <span class="token function">number_len</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>        number <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 解析字符串中的数字, 返回数字的值</span><span class="token keyword">int</span> <span class="token function">parse_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>string <span class="token operator">&amp;&amp;</span> <span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>string <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 去除字符串中的某个字符</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">remove_occur</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pp <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 当 p 指向内容</span>        <span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token comment">// 1. 使用 *p 赋值 *pp 2. p右移 (保证每次原字符串读取下一个字符)</span>        pp <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pp <span class="token operator">!=</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅当 *pp != c 时, pp 右移 (意味着如果时c则会被下一次写入覆盖)</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> <span class="token comment">// pp的最新位置作为结尾</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将一个字符串添加到另一个字符串后面</span><span class="token comment">// 前面是 src 后面是 chunk</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">append_string</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>chunk<span class="token punctuation">,</span> <span class="token class-name">size_t</span> chunklen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> srclen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ret <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>srclen <span class="token operator">+</span> chunklen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> src<span class="token punctuation">,</span> srclen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>ret <span class="token operator">+</span> srclen<span class="token punctuation">,</span> chunk<span class="token punctuation">,</span> chunklen<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret<span class="token punctuation">[</span>srclen <span class="token operator">+</span> chunklen<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建 uuid</span><span class="token keyword">int</span> <span class="token function">generate_uuid</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>uuid_placeholder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* Generate random uuid */</span>    <span class="token class-name">uuid_t</span> binuuid<span class="token punctuation">;</span>    <span class="token function">uuid_generate_random</span><span class="token punctuation">(</span>binuuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uuid_unparse</span><span class="token punctuation">(</span>binuuid<span class="token punctuation">,</span> uuid_placeholder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这些简单的函数足以支撑我们的日志系统，如果在启动时调用 <code>sol_log_init</code> 我们还能将日志存入日志文件。</p><h1 id="服务入口实现"><a href="#服务入口实现" class="headerlink" title="服务入口实现"></a>服务入口实现</h1><p>终于我们要开始写 <code>start_server</code> 函数了，这个函数会调用所有我们之前写过的内容。他将作为程序的入口点，完成各种设置和全局实例的初始化，然后等待着客户端链接。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// 系统状态主题, 根据配置文件每 n 秒发布一次</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SYS_TOPICS</span> <span class="token expression"><span class="token number">14</span></span></span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sys_topics<span class="token punctuation">[</span>SYS_TOPICS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"$SOL/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/clients/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/bytes/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/messages/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/uptime/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/uptime/sol"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/clients/connected/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/clients/disconnected/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/bytes/sent/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/bytes/received/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/messages/sent/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/messages/received/"</span><span class="token punctuation">,</span>    <span class="token string">"$SOL/broker/memory/used"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 一个阻塞的循环</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">evloop_wait</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sol_error</span><span class="token punctuation">(</span><span class="token string">"Event loop exited unexpectedly: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">evloop_free</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 在全局哈希表中删除客户端时触发回调释放资源</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">client_destructor</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span>entry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>client <span class="token operator">=</span> entry<span class="token operator">-></span>val<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token operator">-></span>client_id<span class="token punctuation">)</span>        <span class="token function">free</span><span class="token punctuation">(</span>client<span class="token operator">-></span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 在全局哈希表中删除闭包时触发回调释放资源</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">closure_destructor</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hashtable_entry</span> <span class="token operator">*</span>entry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>closure <span class="token operator">=</span> entry<span class="token operator">-></span>val<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closure<span class="token operator">-></span>payload<span class="token punctuation">)</span>        <span class="token function">bytestring_release</span><span class="token punctuation">(</span>closure<span class="token operator">-></span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>closure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 启动服务器</span><span class="token keyword">int</span> <span class="token function">start_server</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 初始化 sol 全局实例</span>    <span class="token function">trie_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">.</span>topics<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 确保所有的客户端和闭包都在哈希表中, 这样从哈希表删除时就可以使用回调释放资源</span>    sol<span class="token punctuation">.</span>clients <span class="token operator">=</span> <span class="token function">hashtable_create</span><span class="token punctuation">(</span>client_destructor<span class="token punctuation">)</span><span class="token punctuation">;</span>    sol<span class="token punctuation">.</span>closures <span class="token operator">=</span> <span class="token function">hashtable_create</span><span class="token punctuation">(</span>closure_destructor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 服务端 closure</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> server_closure<span class="token punctuation">;</span>    <span class="token comment">// 开启端口监听</span>    server_closure<span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token function">make_listen</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> port<span class="token punctuation">,</span> conf<span class="token operator">-></span>socket_family<span class="token punctuation">)</span><span class="token punctuation">;</span>    server_closure<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    server_closure<span class="token punctuation">.</span>args <span class="token operator">=</span> <span class="token operator">&amp;</span>server_closure<span class="token punctuation">;</span>    <span class="token comment">// 唯一事件是接受客户端链接</span>    server_closure<span class="token punctuation">.</span>call <span class="token operator">=</span> on_accept<span class="token punctuation">;</span>    <span class="token function">generate_uuid</span><span class="token punctuation">(</span>server_closure<span class="token punctuation">.</span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建输出状态的基础 topic</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SYS_TOPICS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">sol_topic_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">,</span> <span class="token function">topic_create</span><span class="token punctuation">(</span><span class="token function">strdup</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建 evloop</span>    <span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>event_loop <span class="token operator">=</span> <span class="token function">evloop_create</span><span class="token punctuation">(</span>EPOLL_MAX_EVENTS<span class="token punctuation">,</span> EPOLL_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将服务端 closure 放入 evloop</span>    <span class="token function">evloop_add_callback</span><span class="token punctuation">(</span>event_loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>server_closure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加周期性事件 汇报服务器状态</span>    <span class="token comment">// TODO 实现</span>    <span class="token keyword">struct</span> <span class="token class-name">closure</span> sys_closure <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>args <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_closure<span class="token punctuation">,</span>        <span class="token punctuation">.</span>call <span class="token operator">=</span> publish_stats    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">generate_uuid</span><span class="token punctuation">(</span>sys_closure<span class="token punctuation">.</span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">evloop_add_periodic_task</span><span class="token punctuation">(</span>event_loop<span class="token punctuation">,</span> conf<span class="token operator">-></span>stats_pub_interval<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sys_closure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化完成</span>    <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Server start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>start_time <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 进入事件循环</span>    <span class="token function">run</span><span class="token punctuation">(</span>event_loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放资源</span>    <span class="token function">hashtable_release</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>clients<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hashtable_release</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>closures<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sol_info</span><span class="token punctuation">(</span><span class="token string">"Sol v%s exiting"</span><span class="token punctuation">,</span> VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="定时通报服务器状态"><a href="#定时通报服务器状态" class="headerlink" title="定时通报服务器状态"></a>定时通报服务器状态</h1><p>好的，我们现在有了一个（几乎）功能齐全的服务器，它使用我们的回调系统来处理流量。 接下来我们需要在头文件上添加一些代码，例如我们刚才使用的 <code>info</code> 结构体，还有全局的名为 <code>sol</code> 的实例，这些我们都还没有定义。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.h</span></div><code class="language-c"><span class="token comment">// 全局 info</span><span class="token keyword">struct</span> <span class="token class-name">sol_info</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nclients<span class="token punctuation">;</span>               <span class="token comment">// 当前客户端数</span>    <span class="token keyword">int</span> nconnections<span class="token punctuation">;</span>           <span class="token comment">// 历史客户端总数</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> start_time<span class="token punctuation">;</span>       <span class="token comment">// 服务启动时间</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> bytes_recv<span class="token punctuation">;</span>       <span class="token comment">// 接收字节总数</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> bytes_sent<span class="token punctuation">;</span>       <span class="token comment">// 发送字节总数</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> messages_sent<span class="token punctuation">;</span>    <span class="token comment">// 发送消息总数</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> messages_recv<span class="token punctuation">;</span>    <span class="token comment">// 接收消息总数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是刚才的 <code>start_server</code> 函数中我们添加的一个周期性任务。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 添加周期性事件 汇报服务器状态</span><span class="token comment">// TODO 实现</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> sys_closure <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>args <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_closure<span class="token punctuation">,</span>    <span class="token punctuation">.</span>call <span class="token operator">=</span> publish_stats<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">generate_uuid</span><span class="token punctuation">(</span>sys_closure<span class="token punctuation">.</span>closure_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">evloop_add_periodic_task</span><span class="token punctuation">(</span>event_loop<span class="token punctuation">,</span> conf<span class="token operator">-></span>stats_pub_interval<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sys_closure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>publish_stats</code> 函数会每隔 <code>conf-&gt;stats_pub_interval</code> 秒被调用一次， <code>conf-&gt;stats_pub_interval</code> 是一个全局的配置值，配置相关的内容我们稍后会去实现。</p><p>现在，让我们先实现这个回调函数：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// 发送消息的工具方法</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">,</span>                            <span class="token keyword">unsigned</span> <span class="token keyword">short</span> topiclen<span class="token punctuation">,</span>                            <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>topic<span class="token punctuation">,</span>                            <span class="token keyword">unsigned</span> <span class="token keyword">short</span> payloadlen<span class="token punctuation">,</span>                            <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>payload<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 从全局的 topic 表中获得我们需发送的 topic, 如果不存在则退出</span>    <span class="token keyword">struct</span> <span class="token class-name">topic</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">sol_topic_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sol<span class="token punctuation">,</span> topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 制作一个 PUBLISH 包</span>    <span class="token keyword">union</span> mqtt_packet pkt<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">mqtt_packet_publish</span><span class="token punctuation">(</span>PUBLISH_BYTE<span class="token punctuation">,</span>                                                 pkt_id<span class="token punctuation">,</span>                                                 topiclen<span class="token punctuation">,</span>                                                 <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> topic<span class="token punctuation">,</span>                                                 payloadlen<span class="token punctuation">,</span>                                                 payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    pkt<span class="token punctuation">.</span>publish <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> len<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed<span class="token punctuation">;</span>    <span class="token comment">// 通过TCP向所有订阅了该主题的客户端发送 payload</span>    <span class="token keyword">struct</span> <span class="token class-name">list_node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> t<span class="token operator">-></span>subscribers<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> sent <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sol_debug</span><span class="token punctuation">(</span><span class="token string">"Sending PUBLISH (d%i, q%u, r%i, m%u, %s, ... (%i bytes))"</span><span class="token punctuation">,</span>                  pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>dup<span class="token punctuation">,</span>                  pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos<span class="token punctuation">,</span>                  pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>retain<span class="token punctuation">,</span>                  pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">,</span>                  pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">,</span>                  pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>payloadlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        len <span class="token operator">=</span> MQTT_HEADER_LEN <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span>            pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>topiclen <span class="token operator">+</span> pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>payloadlen<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">subscriber</span> <span class="token operator">*</span>sub <span class="token operator">=</span> cur<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">sol_client</span> <span class="token operator">*</span>sc <span class="token operator">=</span> sub<span class="token operator">-></span>client<span class="token punctuation">;</span>        <span class="token comment">// 根据订阅者设置的 qos 更改包中的 qos</span>        pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">=</span> sub<span class="token operator">-></span>qos<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token punctuation">.</span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">></span> AT_MOST_ONCE<span class="token punctuation">)</span>            len <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remaininglen_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x200000</span><span class="token punctuation">)</span>            remaininglen_offset <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x4000</span><span class="token punctuation">)</span>            remaininglen_offset <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x80</span><span class="token punctuation">)</span>            remaininglen_offset <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        len <span class="token operator">+=</span> remaininglen_offset<span class="token punctuation">;</span>                <span class="token comment">// 实际打包发送</span>        packed <span class="token operator">=</span> <span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pkt<span class="token punctuation">,</span> PUBLISH<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sent <span class="token operator">=</span> <span class="token function">send_bytes</span><span class="token punctuation">(</span>sc<span class="token operator">-></span>fd<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">sol_error</span><span class="token punctuation">(</span><span class="token string">"Error publishing to %s: %s"</span><span class="token punctuation">,</span>                      sc<span class="token operator">-></span>client_id<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 统计信息</span>        info<span class="token punctuation">.</span>bytes_sent <span class="token operator">+=</span> sent<span class="token punctuation">;</span>        info<span class="token punctuation">.</span>messages_sent<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 发送服务器状态的周期性任务</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publish_stats</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> cclients<span class="token punctuation">[</span><span class="token function">number_len</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>nclients<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>cclients<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>nclients<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> bsent<span class="token punctuation">[</span><span class="token function">number_len</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>bytes_sent<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>bsent<span class="token punctuation">,</span> <span class="token string">"%lld"</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>bytes_sent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> msent<span class="token punctuation">[</span><span class="token function">number_len</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>messages_sent<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>msent<span class="token punctuation">,</span> <span class="token string">"%lld"</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>messages_sent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> mrecv<span class="token punctuation">[</span><span class="token function">number_len</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>messages_recv<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>mrecv<span class="token punctuation">,</span> <span class="token string">"%lld"</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>messages_recv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> uptime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">-</span> info<span class="token punctuation">.</span>start_time<span class="token punctuation">;</span>    <span class="token keyword">char</span> utime<span class="token punctuation">[</span><span class="token function">number_len</span><span class="token punctuation">(</span>uptime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>utime<span class="token punctuation">,</span> <span class="token string">"%lld"</span><span class="token punctuation">,</span> uptime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> sol_uptime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">-</span> info<span class="token punctuation">.</span>start_time<span class="token punctuation">)</span> <span class="token operator">/</span> SOL_SECONDS<span class="token punctuation">;</span>    <span class="token keyword">char</span> sutime<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>sutime<span class="token punctuation">,</span> <span class="token string">"%.4f"</span><span class="token punctuation">,</span> sol_uptime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sys_topics<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token function">strlen</span><span class="token punctuation">(</span>utime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>utime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sys_topics<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token function">strlen</span><span class="token punctuation">(</span>sutime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>sutime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sys_topics<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token function">strlen</span><span class="token punctuation">(</span>cclients<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cclients<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sys_topics<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token function">strlen</span><span class="token punctuation">(</span>bsent<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>bsent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sys_topics<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token function">strlen</span><span class="token punctuation">(</span>msent<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>msent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">publish_message</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>sys_topics<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sys_topics<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token function">strlen</span><span class="token punctuation">(</span>mrecv<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>mrecv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们已经注册了我们第一个周期性回调，他会定时的发送 <code>sys_topics</code> 数组中主题的消息，</p><p>下面是一些我们需要的全局实例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/server.c</span></div><code class="language-c"><span class="token comment">// info 实例, 其内容会被周期性回调发送</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sol_info</span> info<span class="token punctuation">;</span><span class="token comment">// sol 实例, 包括 主题树 和 客户端哈希表</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sol</span> sol<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我们还需要补充一些代码，才能使我们上面的代码能够运行。比如，<code>struct sol</code> 的定义、<code>closure_destructor</code> 函数，哈希表的定义，比如 <code>topic</code> 的存储和解析方法。这一切我们都需要去完成。</p><p>在下一部分我们会编写处理各种MQTT数据包的 <code>处理器</code>，根据数据包的类型和内容不同，服务器会表现出不同的行为。</p>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]通过三个步骤简单理解epoll</title>
    <link href="/translate-epoll-in-3-steps.html"/>
    <url>/translate-epoll-in-3-steps.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://suchprogramming.com/epoll-in-3-easy-steps/">epoll() Tutorial – epoll() In 3 Easy Steps!</a></p></blockquote><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在不久前，能够让一台服务器<a href="http://www.kegel.com/c10k.html">支持10000个并发连接</a>还是一个很了不起的事情。有很多因素让这个行为成为可能，例如 <a href="https://www.nginx.com/">nginx</a>，他可以比他的前辈们更高效的处理更多连接。不过其中最大的因素应该还是大部分操作系统引入了恒定时间的轮询机制<a href="https://robbell.io/2009/06/a-beginners-guide-to-big-o-notation">O1</a>，用来监视系统中的文件描述符。</p><p>在 <a href="https://nostarch.com/">No Starch Press</a> 的书<a href="https://nostarch.com/tlpi">《Linux 编程接口》</a>中，第 63.4.5 节提供了一个表格，描述了通过一些最常见的轮询方法检查不同数量的文件描述符所需的时间。</p><p><img src="/translate-epoll-in-3-steps/poll-times.png"></p><p>如图所示，在10个文件描述符时，epoll 已经体现出了他的性能优势。随着描述符数量的增加，相比于 <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> 或 <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a>，这种性能优势体现的越来越大。</p><p>本教程将介绍在 Linux 2.6.27+ 上使用 epoll() 的一些基础知识。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>本教程假设您熟悉并熟悉 Linux、C 语法以及类 UNIX 系统中文件描述符的使用。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>创建一个新文件夹来开始我们的教程， Makefile 如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span> epoll_example<span class="token target symbol">epoll_example</span><span class="token punctuation">:</span> epoll_example.cgcc -Wall -Werror -o <span class="token variable">$@</span> epoll_example.c<span class="token target symbol">clean</span><span class="token punctuation">:</span><span class="token operator">@</span>rm -v epoll_example<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这篇文章中，需要使用这些库：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>epoll_example.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>     <span class="token comment">// for fprintf()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>    <span class="token comment">// for close(), read()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span> <span class="token comment">// for epoll_create1(), epoll_ctl(), struct epoll_event</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>    <span class="token comment">// for strncmp</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="第一步：创建-epoll-文件描述符"><a href="#第一步：创建-epoll-文件描述符" class="headerlink" title="第一步：创建 epoll 文件描述符"></a>第一步：创建 epoll 文件描述符</h1><p>从最基础开始，先尝试创建和关闭 epoll 实例。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>epoll_example.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>     <span class="token comment">// for fprintf()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>    <span class="token comment">// for close()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span> <span class="token comment">// for epoll_create1()</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> epoll_fd <span class="token operator">=</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>epoll_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to create epoll file descriptor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to close epoll file descriptor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>运行这段代码，正常来说应该直接返回并且不产生任何输出，如果你看到了错误消息，那么也许你可能正在运行一个非常旧的 Linux 内核。</p><p>第一个例子是使用 <a href="https://linux.die.net/man/2/epoll_create1">epoll_create1()</a> 创建 <code>epoll</code> 实例，并且获得他的文件描述符。虽然我们没有用这个文件描述符做任何事情，我们仍然要记得在关闭程序之前清理他。就像和其他的 <code>Linux</code> 文件描述符一样，使用 <code>close()</code>。</p><h2 id="电平触发（Level-triggered）和边沿触发（edge-triggered）"><a href="#电平触发（Level-triggered）和边沿触发（edge-triggered）" class="headerlink" title="电平触发（Level triggered）和边沿触发（edge triggered）"></a>电平触发（Level triggered）和边沿触发（edge triggered）</h2><p><a href="https://www.quora.com/What-are-the-key-differences-between-edge-triggered-and-level-triggered-interrupts">电平触发和边沿触发</a> 是从电子工程师那边借来的术语，但当我们使用 <code>epoll</code> 时，我们需要注意这两者的差别。在边沿触发模式下，我们只会在被监控文件描述符的状态变化时接收到事件；而在电平触发模式下，我们会持续接收事件，直到被监控的文件描述符不再处于 ready 状态。一般来说电平触发时默认状态，而且更加容易上手，我们的教程也会使用电平触发。但是我们也需要直到有边沿触发这回事。</p><h1 id="第二步：添加被-epoll-监控的文件描述符"><a href="#第二步：添加被-epoll-监控的文件描述符" class="headerlink" title="第二步：添加被 epoll 监控的文件描述符"></a>第二步：添加被 epoll 监控的文件描述符</h1><p>接下来要做的事情就是，告诉 epoll 需要监控哪些文件描述符，以及需要监控哪种类型的事件。在这个例子里，我会使用Linux中我最爱的文件描述符，亲爱的 <code>file descriptor 0</code>（就是标准输入）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>epoll_example.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>     <span class="token comment">// for fprintf()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>    <span class="token comment">// for close()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span> <span class="token comment">// for epoll_create1(), epoll_ctl(), struct epoll_event</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> event<span class="token punctuation">;</span><span class="token keyword">int</span> epoll_fd <span class="token operator">=</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>epoll_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to create epoll file descriptor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to add file descriptor to epoll\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to close epoll file descriptor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里我们创建了 <code>epoll_event</code> 的实例 <code>event</code>，并使用 <a href="https://linux.die.net/man/2/epoll_ctl">epoll_ctl()</a> 将 <code>fd0</code> 添加到 epoll 的实例 <code>epoll_fd</code> 中。最后一个参数 <code>event</code> 是为了让 epoll 知道我们只想关注输入事件（<code>EPOLLIN</code>），而且还能为事件提供一些我们自定义的数据（本例中 <code>event.data.fd = 0</code>）。</p><h1 id="第三步：完整例子"><a href="#第三步：完整例子" class="headerlink" title="第三步：完整例子"></a>第三步：完整例子</h1><p>现在，让 epoll 发挥他的魔力吧</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>epoll_example.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENTS</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">READ_SIZE</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>     <span class="token comment">// for fprintf()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>    <span class="token comment">// for close(), read()</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span> <span class="token comment">// for epoll_create1(), epoll_ctl(), struct epoll_event</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>    <span class="token comment">// for strncmp</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 是否运行中、当前并发事件数、计数器</span><span class="token keyword">int</span> running <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> event_count<span class="token punctuation">,</span> i<span class="token punctuation">;</span>  <span class="token comment">// 接收数据长度</span><span class="token class-name">size_t</span> bytes_read<span class="token punctuation">;</span>  <span class="token comment">// 接收输入 buffer</span><span class="token keyword">char</span> read_buffer<span class="token punctuation">[</span>READ_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// event 是一个事件结构 events 是事件数组, 最多5个</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> event<span class="token punctuation">,</span> events<span class="token punctuation">[</span>MAX_EVENTS<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// epoll 实例</span><span class="token keyword">int</span> epoll_fd <span class="token operator">=</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>epoll_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to create epoll file descriptor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 监听 EPOLLIN</span>event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span><span class="token comment">// 用户数据 fd = 0</span>  event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 epoll_ctl 添加监听</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to add file descriptor to epoll\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 等待输入</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nPolling for input...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// epoll_wait 等待事件发生</span>    <span class="token comment">// 返回值：接收并发事件数</span>    <span class="token comment">// 参数：epoll实例, 事件容器, 并发数, 超时时间</span>event_count <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> MAX_EVENTS<span class="token punctuation">,</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d ready events\n"</span><span class="token punctuation">,</span> event_count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> event_count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reading file descriptor '%d' -- "</span><span class="token punctuation">,</span> events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>bytes_read <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> read_buffer<span class="token punctuation">,</span> READ_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd bytes read.\n"</span><span class="token punctuation">,</span> bytes_read<span class="token punctuation">)</span><span class="token punctuation">;</span>read_buffer<span class="token punctuation">[</span>bytes_read<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Read '%s'"</span><span class="token punctuation">,</span> read_buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 输入为 stop 时结束</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strncmp</span><span class="token punctuation">(</span>read_buffer<span class="token punctuation">,</span> <span class="token string">"stop\n"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>running <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to close epoll file descriptor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们添加了一些变量，用来支撑这个例子，同时使用了一个循环，持续读取标准输入直到读取内容为 <code>stop</code>。我们使用 <a href="">epoll_wait()</a> 来等待事件的发生，每个发生的事件都会被存储在 <code>events</code> 中，最大支持 <code>MAX_EVENTS</code> 个事件，并将超时事件设置为30秒。<code>epoll_wait()</code> 返回了本次触发了多少事件，然后我们只是在一个循环中打印这些事件而已。</p><h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><p>接下来是一些使用示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>example</span></div><code class="language-text">:~/epoll_example$ ./epoll_examplePolling for input...hello1 ready eventsReading file descriptor '0' -- 6 bytes read.Read 'hello'Polling for input...to looooooooooooong1 ready eventsReading file descriptor '0' -- 10 bytes read.Read 'to loooooo'Polling for input...1 ready eventsReading file descriptor '0' -- 10 bytes read.Read 'ooooooong'Polling for input...stop1 ready eventsReading file descriptor '0' -- 5 bytes read.Read 'stop'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到，第一次我们输入 <code>hello</code>，程序正确输出而且继续循环。</p><p>第二次当我们输入一个超过长度限制的输入 <code>to looooooooooooong</code> 时，电平触发机制帮助了我们。因为输入缓冲区一直有值，所以我们的事件就一直触发，直到读取完毕。在这种情况下，如果我们使用的是边沿触发，那么我们就只能收到一次通知，直到下次再有内容写入输入缓冲区时才会执行下一次事件了。</p><p>希望这篇文档能够帮助你使用 <code>epoll()</code>！</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 第二部分：网络</title>
    <link href="/translate-sol-2.html"/>
    <url>/translate-sol-2.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker-p2/">Sol - An MQTT broker from scratch. Part 2 - Networking</a></p></blockquote><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>让我们继续之前的工作，在第一部分中我们实现了 MQTT v3.1.1 的数据结构和解码函数，接下来我们需要做一些组包和编码函数，让我们可以发送网络包。</p><p>顺带说明一下，我们并没有打算去编写完美的或者内存效率很高的代码，而且，过早的优化是万恶之源，以后我们有的是时间来提高我们的代码质量。</p><h1 id="组包实现"><a href="#组包实现" class="headerlink" title="组包实现"></a>组包实现</h1><p>暂时我们只需要做 <code>CONNACK</code> <code>SUBACK</code> <code>PUBLISH</code> 包的组包工作，其他的各种 <code>ACK</code> 的结构都是一样的，之前我们已经用 <strong>typedef</strong> 让这些 <code>ACK</code> 引用了同一个函数。</p><ul><li><p><code>union mqtt_header *mqtt_packet_header(unsigned char)</code> 函数用来处理 Fixed Header，以及以下这些只有 Fixed Header 的包：</p><ul><li>PINGREQ</li><li>PINGRESP</li><li>DISCONNECT</li></ul></li><li><p><code>struct mqtt_ack *mqtt_packet_ack(unsigned char, unsigned short)</code> 用来处理以下这些 <code>类ACK</code> 的包：</p><ul><li>PUBACK</li><li>PUBREC</li><li>PUBREL</li><li>PUBCOMP</li><li>UNSUBACK</li></ul></li></ul><p>其余的包都需要专门的函数来组包。再说一次，虽然可能有很多更优雅的代码或者更优化的方法，但是现在我们只要写能用的代码就行了，以后迟早会优化的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>mqtt.c</span></div><code class="language-c"><span class="token comment">/* * mqtt组包 */</span><span class="token comment">// 头部1byte的组包实现</span><span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token function">mqtt_packet_header</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    header<span class="token punctuation">.</span>byte <span class="token operator">=</span> byte<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>header<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 各种ACK的组包实现</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> <span class="token operator">*</span><span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> ack<span class="token punctuation">;</span>    ack<span class="token punctuation">.</span>header<span class="token punctuation">.</span>byte <span class="token operator">=</span> byte<span class="token punctuation">;</span>    ack<span class="token punctuation">.</span>pkt_id <span class="token operator">=</span> pkt_id<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ack<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// CONNACK 组包实现</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_connack</span> <span class="token operator">*</span><span class="token function">mqtt_packet_connack</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> cflags<span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> rc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_connack</span> connack<span class="token punctuation">;</span>    connack<span class="token punctuation">.</span>header<span class="token punctuation">.</span>byte <span class="token operator">=</span> byte<span class="token punctuation">;</span>    connack<span class="token punctuation">.</span>byte <span class="token operator">=</span> cflags<span class="token punctuation">;</span>    connack<span class="token punctuation">.</span>rc <span class="token operator">=</span> rc<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>connack<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// SUBACK 组包实现</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_suback</span> <span class="token operator">*</span><span class="token function">mqtt_packet_suback</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">,</span>                                       <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">,</span>                                       <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>rcs<span class="token punctuation">,</span>                                       <span class="token keyword">unsigned</span> <span class="token keyword">short</span> rcslen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_suback</span> <span class="token operator">*</span>suback <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>suback<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    suback<span class="token operator">-></span>header<span class="token punctuation">.</span>byte <span class="token operator">=</span> byte<span class="token punctuation">;</span>    suback<span class="token operator">-></span>pkt_id <span class="token operator">=</span> pkt_id<span class="token punctuation">;</span>    suback<span class="token operator">-></span>rcslen <span class="token operator">=</span> rcslen<span class="token punctuation">;</span>    suback<span class="token operator">-></span>rcs <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>rcslen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>suback<span class="token operator">-></span>rcs<span class="token punctuation">,</span> rcs<span class="token punctuation">,</span> rcslen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> suback<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// PUBLISH 组包实现</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> <span class="token operator">*</span><span class="token function">mqtt_packet_publish</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">,</span>                                         <span class="token class-name">size_t</span> topiclen<span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>topic<span class="token punctuation">,</span>                                         <span class="token class-name">size_t</span> payloadlen<span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>payload<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> <span class="token operator">*</span>publish <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>publish<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    publish<span class="token operator">-></span>header<span class="token punctuation">.</span>byte <span class="token operator">=</span> byte<span class="token punctuation">;</span>    publish<span class="token operator">-></span>pkt_id <span class="token operator">=</span> pkt_id<span class="token punctuation">;</span>    publish<span class="token operator">-></span>topiclen <span class="token operator">=</span> topiclen<span class="token punctuation">;</span>    publish<span class="token operator">-></span>topic <span class="token operator">=</span> topic<span class="token punctuation">;</span>    publish<span class="token operator">-></span>payloadlen <span class="token operator">=</span> payloadlen<span class="token punctuation">;</span>    publish<span class="token operator">-></span>payload <span class="token operator">=</span> payload<span class="token punctuation">;</span>    <span class="token keyword">return</span> publish<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放包资源</span><span class="token keyword">void</span> <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span><span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> CONNECT<span class="token operator">:</span>            <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>username <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>password <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>will <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>will_message<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>will_topic<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SUBSCRIBE<span class="token operator">:</span>        <span class="token keyword">case</span> UNSUBSCRIBE<span class="token operator">:</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples_len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SUBACK<span class="token operator">:</span>            <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>rcs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBLISH<span class="token operator">:</span>            <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h1><p>我们接下来处理编码函数，编码函数其实就是解码函数的反方向操作：我们使用内存对象创造一个字节流，之后可以通过socket发出去。</p><p>现在我们有一些函数返回指向 <code>static struct</code> 的指针（例如上方代码中的 <code>mqtt_packet_header</code> ），在单线程的情况下这是没什么问题的。 <strong>在多线程环境下，一定会出问题</strong>，每次这种函数的返回都会指向同一片内存区域，可能导致各种冲突。因此为了将来的改进，需要重构这些部分，使用 <code>malloc</code> 来为每次返回分配地址。</p><p>我们采用和之前解码函数一样的方式来映射编码函数。做一个静态数组，其中的序号恰好等于包类型。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">// MQTT 编码函数接口</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">mqtt_pack_handler</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 编码函数数组, 其中索引和包类型id对应</span><span class="token keyword">static</span> mqtt_pack_handler <span class="token operator">*</span>pack_handlers<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    pack_mqtt_connack<span class="token punctuation">,</span>    pack_mqtt_publish<span class="token punctuation">,</span>    pack_mqtt_ack<span class="token punctuation">,</span>    pack_mqtt_ack<span class="token punctuation">,</span>    pack_mqtt_ack<span class="token punctuation">,</span>    pack_mqtt_ack<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    pack_mqtt_suback<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    pack_mqtt_ack<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// header 的编码实现</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_header</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span>hdr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MQTT_HEADER_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> packed<span class="token punctuation">;</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> hdr<span class="token operator">-></span>byte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Remaining Length 1byte 值为0</span>    <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> packed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ACK 的编码实现</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_ack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4byte</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> packed<span class="token punctuation">;</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>ack<span class="token punctuation">.</span>header<span class="token punctuation">.</span>byte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> MQTT_HEADER_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里指还有2byte 内容是 pkt_id</span>    ptr<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 因为 mqtt_encode_length 不会移动指针, 只会返回 Remaining Length 的长度, 而这里长度显然为1</span>    <span class="token function">pack_u16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>ack<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> packed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// CONNACK 的编码实现</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_connack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MQTT_ACK_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> packed<span class="token punctuation">;</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>connack<span class="token punctuation">.</span>header<span class="token punctuation">.</span>byte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> MQTT_HEADER_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>connack<span class="token punctuation">.</span>byte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>connack<span class="token punctuation">.</span>rc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> packed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// SUBACK 的编码实现</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_suback</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 计算总长度</span>    <span class="token class-name">size_t</span> pktlen <span class="token operator">=</span> MQTT_HEADER_LEN <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span> pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>rcslen<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>pktlen <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> packed<span class="token punctuation">;</span>    <span class="token comment">// 编码固定头</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>header<span class="token punctuation">.</span>byte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 剩余部分的长度</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span> pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>rcslen<span class="token punctuation">;</span>    <span class="token comment">// 变长表示剩余部分长度</span>    <span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 指针后移</span>    ptr <span class="token operator">+=</span> step<span class="token punctuation">;</span>    <span class="token comment">// 剩余部分编码</span>    <span class="token function">pack_u16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>rcslen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>suback<span class="token punctuation">.</span>rcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> packed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// PUBLISH 的编码实现</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_publish</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// pktlen 至少有这么多: 头部至少2byte(1byte头 + 至少1byte的Remaining Length)</span>    <span class="token comment">// sizeof(uint16_t) 表示 topiclen 的长度, 因为 payloadlen 是不被编码到字节流中的</span>    <span class="token comment">// topiclen 和 payloadlen 的内容</span>    <span class="token class-name">size_t</span> pktlen <span class="token operator">=</span> MQTT_HEADER_LEN <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span>        pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topiclen <span class="token operator">+</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payloadlen<span class="token punctuation">;</span>    <span class="token comment">// 这里是去除 fixed header 之外的内容长度</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>    <span class="token comment">// qos > 0, 说明有pkt_id, 需要 +2byte</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">></span> AT_MOST_ONCE<span class="token punctuation">)</span>        pktlen <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里是通过剩余长度计算变长部分还需要的长度, 前面已经预留了1byte</span>    <span class="token keyword">int</span> remaininglen_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pktlen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x200000</span><span class="token punctuation">)</span>        remaininglen_offset <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pktlen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x4000</span><span class="token punctuation">)</span>        remaininglen_offset <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pktlen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0x80</span><span class="token punctuation">)</span>        remaininglen_offset <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 这里是总包长</span>    pktlen <span class="token operator">+=</span> remaininglen_offset<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>packed <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>pktlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> packed<span class="token punctuation">;</span>    <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>byte<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 除去 fixed header 之外剩余部分的长度</span>    len <span class="token operator">+=</span> <span class="token punctuation">(</span>pktlen <span class="token operator">-</span> MQTT_HEADER_LEN <span class="token operator">-</span> remaininglen_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 编码 Remaining Length</span>    <span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr <span class="token operator">+=</span> step<span class="token punctuation">;</span>    <span class="token comment">// 编码 topiclen 和后续的 topic 内容</span>    <span class="token function">pack_u16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topiclen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pack_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当 QoS > 0 时, 编码 pkt_id</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">></span> AT_MOST_ONCE<span class="token punctuation">)</span>        <span class="token function">pack_u16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 编码 payload 的内容</span>    <span class="token function">pack_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptr<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> packed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 编码函数入口</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> PINGREQ <span class="token operator">||</span> type <span class="token operator">==</span> PINGRESP<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">pack_mqtt_header</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pkt<span class="token operator">-></span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pack_handlers<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span>pkt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="socket-封装"><a href="#socket-封装" class="headerlink" title="socket 封装"></a>socket 封装</h1><p>我们计划创建一个单线程 TCP 服务器，使用 <strong>epoll</strong> 接口实现多路 I&#x2F;O。Epoll 是继 <strong>select</strong> 和 <strong>poll</strong> 之后内核 2.5.44 添加的最新的多路复用机制，也是性能最高、连接数最多的多路复用机制，它在 BSD 和 BSD-like (Mac OSX) 系统中的对应机制是 <strong>kqueue</strong>。</p><p>我们需要定义一些函数来管理我们的socket descriptor。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token comment">// 地址族</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UNIX</span>    <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INET</span>    <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">// 设置为 non-blocking 模式</span><span class="token keyword">int</span> <span class="token function">set_nonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将 TCP_NODELAY 设置为 true, 用来关闭 Nagle's algorithm, 关闭收包时的缓冲等待</span><span class="token keyword">int</span> <span class="token function">set_tcp_nodelay</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建 socket 服务的辅助函数</span><span class="token keyword">int</span> <span class="token function">create_and_bind</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建一个 non-blocking socket 并监听指定的地址和端口</span><span class="token keyword">int</span> <span class="token function">make_listen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 接收链接并进行后续处理, 将链接分配到 epollfd</span><span class="token keyword">int</span> <span class="token function">accept_connection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们定义了一些简单的辅助函数，用来创建和绑定 <code>socket</code> 端口，处理新链接并把 <code>socket</code> 设置为 <code>non-blocking</code> 模式（这样才能发挥 <strong>epoll</strong> 的复用能力）。</p><p>我不喜欢必须处理每个进出服务器的字节，在我写的涉及到TCP通信的程序中，我都会定义这两个函数：</p><ul><li><code>ssize_t send_bytes(int, const unsigned char *, size_t)</code> 用于在while循环中持续发送数据，直到把数据全部发送完。正确捕获 <code>EAGAIN</code> 或 <code>EWOUDLBLOCK</code> 异常。</li><li><code>ssize_t recv_bytes(int, unsigned char *, size_t)</code> 在while循环中获得任意长度的数据。正确捕获 <code>EAGAIN</code> 或 <code>EWOUDLBLOCK</code> 异常。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.h</span></div><code class="language-c"><span class="token comment">// I/O 管理函数</span><span class="token comment">// 在循环中发出所有数据, 避免内核buffer可用性造成的中断(EAGAIN EWOUDLBLOCK)</span><span class="token class-name">ssize_t</span> <span class="token function">send_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从 fd 中读取指定长度的数据进入 buffer</span><span class="token class-name">ssize_t</span> <span class="token function">recv_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="socket-封装实现"><a href="#socket-封装实现" class="headerlink" title="socket 封装实现"></a>socket 封装实现</h2><p>接下来是 <code>network.c</code> 的实现。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_DEFAULT_SOURCE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/un.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/timerfd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/tcp.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/eventfd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"network.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token comment">// 设置 non-blocking socket</span><span class="token keyword">int</span> <span class="token function">set_nonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> flags<span class="token punctuation">,</span> result<span class="token punctuation">;</span>    flags <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> flags <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"set_nonblocking"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 设置 TCP_NODELAY 用以关闭 Nagle's algorithm</span><span class="token keyword">int</span> <span class="token function">set_tcp_nodelay</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">,</span> TCP_NODELAY<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// UNIX socket 的绑定方法</span><span class="token comment">// return fd</span><span class="token comment">// sockpath 文件路径</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">create_and_bind_unix</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sockpath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> addr<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token comment">// 创建 socket</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_UNIX<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"socket error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// addr初始值全0</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 赋值</span>    addr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_UNIX<span class="token punctuation">;</span>    <span class="token function">strncpy</span><span class="token punctuation">(</span>addr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> sockpath<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">.</span>sun_path<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 译者没有明白为何 unlink 会出现在此处</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>sockpath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定 socket</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"bind error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> fd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// TCP socket 的绑定方法</span><span class="token comment">// return fd</span><span class="token comment">// host TCP 地址</span><span class="token comment">// port TCP 端口</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">create_and_bind_tcp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>port<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">addrinfo</span> hints <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span>ai_family <span class="token operator">=</span> AF_UNSPEC<span class="token punctuation">,</span>       <span class="token comment">// 不指定协议族, 系统自定可以是IP4 或 IP6</span>        <span class="token punctuation">.</span>ai_socktype <span class="token operator">=</span> SOCK_STREAM<span class="token punctuation">,</span>   <span class="token comment">// 面向流, 就是TCP</span>        <span class="token punctuation">.</span>ai_flags <span class="token operator">=</span> AI_PASSIVE        <span class="token comment">// 被动模式, 可以监听任意地址端口</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// result 是 getaddrinfo 提供的 addrinfo, rp 指如果绑定不成功, 可以变成下一个 addrinfo</span>    <span class="token keyword">struct</span> <span class="token class-name">addrinfo</span> <span class="token operator">*</span>result<span class="token punctuation">,</span> <span class="token operator">*</span>rp<span class="token punctuation">;</span>    <span class="token keyword">int</span> sfd<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getaddrinfo</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"getaddrinfo error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>rp <span class="token operator">=</span> result<span class="token punctuation">;</span> rp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> rp <span class="token operator">=</span> rp<span class="token operator">-></span>ai_next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 先使用 rp 生成 socket</span>        sfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>rp<span class="token operator">-></span>ai_family<span class="token punctuation">,</span> rp<span class="token operator">-></span>ai_socktype<span class="token punctuation">,</span> rp<span class="token operator">-></span>ai_protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果失败就下一个 rp</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 设置 SO_REUSEADDR 这样关闭进程后可以重用端口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span>                       <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"SO_REUSEADDR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>sfd<span class="token punctuation">,</span> rp<span class="token operator">-></span>ai_addr<span class="token punctuation">,</span> rp<span class="token operator">-></span>ai_addrlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// bind 成功</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 绑定失败记得关闭 socket</span>        <span class="token function">close</span><span class="token punctuation">(</span>sfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Could not bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">freeaddrinfo</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sfd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 绑定入口</span><span class="token keyword">int</span> <span class="token function">create_and_bind</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>port<span class="token punctuation">,</span> <span class="token keyword">int</span> socket_family<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_family <span class="token operator">==</span> UNIX<span class="token punctuation">)</span>        fd <span class="token operator">=</span> <span class="token function">create_and_bind_unix</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        fd <span class="token operator">=</span> <span class="token function">create_and_bind_tcp</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> fd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建一个 non-blocking socket, 监听指定的地址端口</span><span class="token comment">// return server file descriptor</span><span class="token comment">// host 地址或UNIX path</span><span class="token comment">// port 端口</span><span class="token comment">// socket_family 地址族 AF_UNIX 或 AF_INET</span><span class="token keyword">int</span> <span class="token function">make_listen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>port<span class="token punctuation">,</span> <span class="token keyword">int</span> socket_family<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sfd<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sfd <span class="token operator">=</span> <span class="token function">create_and_bind</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> socket_family<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">set_nonblocking</span><span class="token punctuation">(</span>sfd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 仅当 TCP链接时设置 TCP_NODELAY</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_family <span class="token operator">==</span> INET<span class="token punctuation">)</span>        <span class="token function">set_tcp_nodelay</span><span class="token punctuation">(</span>sfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// conf是本程序的配置文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>sfd<span class="token punctuation">,</span> conf<span class="token operator">-></span>tcp_backlog<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"listen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sfd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 接收链接后的处理</span><span class="token comment">// return 客户端 fd</span><span class="token comment">// serversock 服务端fd</span><span class="token keyword">int</span> <span class="token function">accept_connection</span><span class="token punctuation">(</span><span class="token keyword">int</span> serversock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> clientsock<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clientsock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>serversock<span class="token punctuation">,</span>                             <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">set_nonblocking</span><span class="token punctuation">(</span>clientsock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 仅当 TCP链接时设置 TCP_NODELAY</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>conf<span class="token operator">-></span>socket_family <span class="token operator">==</span> INET<span class="token punctuation">)</span>        <span class="token function">set_tcp_nodelay</span><span class="token punctuation">(</span>clientsock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ip_buff<span class="token punctuation">[</span>INET_ADDRSTRLEN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将ip地址转为文本, 这里用作检查客户端地址</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inet_ntop</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">,</span>                  ip_buff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ip_buff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">close</span><span class="token punctuation">(</span>clientsock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> clientsock<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 向 fd 发送指定长度的数据</span><span class="token comment">// return 成功发送的数据长度</span><span class="token comment">// fd 发送数据的目的</span><span class="token comment">// buf 发送数据内容地址</span><span class="token comment">// len 需要发送的数据长度</span><span class="token class-name">ssize_t</span> <span class="token function">send_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 发送数据的总长度</span>    <span class="token class-name">size_t</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 剩余需要发送数据的长度</span>    <span class="token class-name">size_t</span> bytesleft <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token comment">// 单次发送数据长度</span>    <span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>total <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送 bytesleft 长度的数据</span>        n <span class="token operator">=</span> <span class="token function">send</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf <span class="token operator">+</span> total<span class="token punctuation">,</span> bytesleft<span class="token punctuation">,</span> MSG_NOSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当 fd 被阻塞时, 直接返回已经发送的长度</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        total <span class="token operator">+=</span> n<span class="token punctuation">;</span>        bytesleft <span class="token operator">-=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> total<span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"send(2) - error sending data: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 从 fd 中获得指定长度的数据</span><span class="token comment">// retrun 成功读取的长度 -1 表示异常</span><span class="token comment">// fd 数据源</span><span class="token comment">// buf 存放结果的指针</span><span class="token comment">// bufsize 期望读取的数据长度</span><span class="token class-name">ssize_t</span> <span class="token function">recv_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> bufsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 单次获取的数据长度</span>    <span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获取的总数据长度</span>    <span class="token class-name">ssize_t</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>total <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token class-name">ssize_t</span><span class="token punctuation">)</span> bufsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用 recv 函数获得最大 bufsize - total 的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> bufsize <span class="token operator">-</span> total<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// fd被阻塞了, 此时total的返回也许是小于 bufsize 的值, 调用者可以选择重试</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>                <span class="token comment">// 对于其他的异常则报错</span>                <span class="token keyword">goto</span> err<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        buf <span class="token operator">+=</span> n<span class="token punctuation">;</span>        total <span class="token operator">+=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> total<span class="token punctuation">;</span>err<span class="token operator">:</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"recv(2) - error reading data: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="epoll-封装"><a href="#epoll-封装" class="headerlink" title="epoll 封装"></a>epoll 封装</h1><p>为了让 <strong>epoll</strong> API能够更加简单易用。我对 epoll 进行了一些的封装，让我们就可以通过注册回调函数的方式来响应事件。</p><p>网络上有很多使用 epoll 的示例，大部分都是描述基本用法：注册一个 socket 并启动一个循环来监听事件，每当 socket 需要被读写时，调用一个函数来使用它们。这些例子当然简单好用，但是并没有告诉我们如何通过回调的方式使用 epoll。经过思考后，我发现可以使用 <code>epoll_event</code> 自带的 <code>epoll_data</code> 来解决这个问题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span>   <span class="token keyword">int</span>          fd<span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span>     u32<span class="token punctuation">;</span>   <span class="token class-name">uint64_t</span>     u64<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正如你看到的，<code>epoll_data</code> 中有一个 <code>void *</code>，一个常常用来保存fd的 <code>int</code>，还有两个大小不同的 <code>uint</code>。我计划做一个自定义事件结构体，其中包括了fd、一些自定义数据和最关键的回调函数指针。然后我们可以把自定义事件结构体绑定到 <code>epoll_data</code> 的 <code>void *</code> 中，如此一来，每当事件发生时，我们都可以通过 <code>epoll_data</code> 获得所有我们需要的东西。</p><p>我想要定义两种类型的回调，一种是事件触发的回调，另一种是间隔触发的周期性回调。我们需要把 epoll 封装到一个自定义结构里，来实现这两种回调。对于这两种回调的处理，我们则会采用完全相同的方式：获得 <code>epoll_data</code>，在其中获得所有我们所需的数据和需要执行的回调函数。</p><p><strong>接收数据包并使用 epoll_wait 处理的顺序图</strong><br><img src="/translate-sol-2/epoll-sequential.png" alt="Epoll sequential diagram"></p><p>我们需要定义两种结构体和一种函数指针</p><ul><li><strong>struct evloop</strong> 封装 epoll 实例的结构体，添加了各种参数用来实现我们的业务设计</li><li><strong>struct closure</strong> 上文中提到的自定义事件结构体，封装了各种事件参数和回调函数的指针</li><li>**void callback(struct evloop <em>, void <em>)</em></em> 回调函数的接口，在 <strong>closure</strong> 里真正被执行的函数的接口</li></ul><p>另外，我们需要在 .c 文件中实现一些对 <code>evloop</code> 的创建、删除和管理功能。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.h</span></div><code class="language-c"><span class="token comment">// epoll 的业务包装，包括 epoll 实例本身和其他参数</span><span class="token comment">// 使用 EPOLLONESHOT 处理事件，并且每次都需要手动重置，这样可以保证未来适应多线程架构</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> epollfd<span class="token punctuation">;</span>                <span class="token comment">// epoll 实例fd</span>    <span class="token keyword">int</span> max_events<span class="token punctuation">;</span>             <span class="token comment">// 单次处理事件最大数量</span>    <span class="token keyword">int</span> timeout<span class="token punctuation">;</span>                <span class="token comment">// 事件等待超时事件</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>                 <span class="token comment">// 运行状态(是否运行中)</span>    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">// 事件数组, 用来接收 epoll_wait 获得的一组并发事件</span>    <span class="token comment">// 周期性任务控制相关</span>    <span class="token keyword">int</span> periodic_maxsize<span class="token punctuation">;</span>       <span class="token comment">// 周期性任务数组初始大小</span>    <span class="token keyword">int</span> periodic_nr<span class="token punctuation">;</span>            <span class="token comment">// 当前周期性任务数量</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> timerfd<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>closure<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token operator">*</span><span class="token operator">*</span>periodic_tasks<span class="token punctuation">;</span>         <span class="token comment">// 周期性任务列表 timerfd &lt;-> closure</span><span class="token punctuation">&#125;</span> evloop<span class="token punctuation">;</span><span class="token comment">// 回调函数接口</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 自定义事件结构体</span><span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>                     <span class="token comment">// 监听的 fd</span>    <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">;</span>                  <span class="token comment">// 存放一些需要的自定义数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">;</span>                 <span class="token comment">// 可以被callback使用的参数, 指向用户自定义结构, 实际调用时就是 call 的第二个参数</span>    <span class="token keyword">char</span> closure_id<span class="token punctuation">[</span>UUID_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// closure 的 UUID</span>    <span class="token keyword">struct</span> <span class="token class-name">bytestring</span> <span class="token operator">*</span>payload<span class="token punctuation">;</span> <span class="token comment">// callback 的结果, 可以被网络发送的数据流</span>    callback <span class="token operator">*</span>call<span class="token punctuation">;</span>             <span class="token comment">// 会被执行的回调函数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// evloop 的创建、初始化、销毁函数</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token function">evloop_create</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">evloop_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">evloop_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 一个阻塞的循环, 监听各种触发并执行对应的回调</span><span class="token keyword">int</span> <span class="token function">evloop_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加一个 closure, 其中包含一个回调函数</span><span class="token comment">// 回调函数是单次触发的(边沿触发), 但是每次触发后都会被重置, 这样下次依然可以触发</span><span class="token keyword">void</span> <span class="token function">evloop_add_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加一个周期性的 closure, 间隔指定事件触发</span><span class="token keyword">void</span> <span class="token function">evloop_add_periodic_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span>                              <span class="token keyword">int</span><span class="token punctuation">,</span>                              <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">,</span>                              <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注销一个 closure, 删除对其 fd 的监听</span><span class="token keyword">int</span> <span class="token function">evloop_del_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重置该 closure 对 read 事件的监听</span><span class="token keyword">int</span> <span class="token function">evloop_rearm_callback_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重置该 closure 对 write 事件的监听</span><span class="token keyword">int</span> <span class="token function">evloop_rearm_callback_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 以下三个函数是对 epoll 原始API的封装, 供上方的函数调用</span><span class="token comment">// EPOLL_CTL_ADD 的封装, 向 epoll 添加监听</span><span class="token keyword">int</span> <span class="token function">epoll_add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// EPOLL_CTL_MOD 的封装, 可以重置 EPOLLONESHOT, 让 closure 下次仍被触发</span><span class="token keyword">int</span> <span class="token function">epoll_mod</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// EPOLL_CTL_DEL 的封装, 删除对某个 fd 的监听</span><span class="token keyword">int</span> <span class="token function">epoll_del</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="epoll-封装实现"><a href="#epoll-封装实现" class="headerlink" title="epoll 封装实现"></a>epoll 封装实现</h2><p>在头文件中定义了我们网络所需的各种工具函数后，接下来我们开始进行函数实现。</p><p>让我们先从最简单的开始，<code>evloop</code> 实例的创建、初始化和删除。他包括了这些内容：</p><ul><li><code>epoll</code> 的 <code>fd</code> 即 <code>epollfd</code></li><li>单次处理的最大事件数量</li><li>一个毫秒单位的超时时间</li><li>loop是否正在运行的状态标识</li><li>动态大小的周期性任务数组</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.c</span></div><code class="language-c"><span class="token comment">/****************************** *         EPOLL APIS         * ******************************/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EVLOOP_INITIAL_SIZE</span> <span class="token expression"><span class="token number">4</span> </span><span class="token comment">// 默认周期任务数组大小</span></span><span class="token comment">// 创建并初始化 evloop</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span><span class="token function">evloop_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> max_events<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">evloop_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> max_events<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> loop<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">evloop_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">int</span> max_events<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    loop<span class="token operator">-></span>max_events <span class="token operator">=</span> max_events<span class="token punctuation">;</span>    loop<span class="token operator">-></span>events <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token punctuation">)</span> <span class="token operator">*</span> max_events<span class="token punctuation">)</span><span class="token punctuation">;</span>    loop<span class="token operator">-></span>epollfd <span class="token operator">=</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里创建 epoll 实例</span>    loop<span class="token operator">-></span>timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span>    loop<span class="token operator">-></span>periodic_maxsize <span class="token operator">=</span> EVLOOP_INITIAL_SIZE<span class="token punctuation">;</span>    loop<span class="token operator">-></span>periodic_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    loop<span class="token operator">-></span>periodic_tasks <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>EVLOOP_INITIAL_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    loop<span class="token operator">-></span>status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放 evloop</span><span class="token keyword">void</span> <span class="token function">evloop_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">free</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>events<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loop<span class="token operator">-></span>periodic_nr<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">free</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接着，我们需要实现三个包装 <code>epoll</code> API的函数，用来创建、修改和删除 <code>epoll</code> 对 <code>fd</code> 的监听。我们封装函数的目的是为所有的 <code>epoll</code> 监听都添加 <code>EPOLLET</code> 和 <code>EPOLLONESHOT</code> 标识。<code>EPOLLET</code> 标识可以让 <code>epoll</code> 工作在<code>边沿触发</code>模式，<code>EPOLLONESHOT</code> 标识则可以确保 <code>epoll</code> 对某个事件触发仅产生一次（然后我们通过手动重置的方式让其可以继续响应）。</p><p>这样的设置可以避免未来我们在使用多线程架构时，一次事件的传入会唤醒所有等待中的线程，这被称为<code>惊群效应</code>(thundering herd problem)，不过这些都是后话，暂时可以不用深究。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.c</span></div><code class="language-c"><span class="token comment">// 添加监听</span><span class="token comment">// return 添加结果</span><span class="token comment">// efd file descriptor</span><span class="token comment">// fd 被监听的 fd</span><span class="token comment">// evs 被监听的事件(可以是一个或一组)</span><span class="token comment">// data 传入自定义结构体</span><span class="token keyword">int</span> <span class="token function">epoll_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> efd<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> evs<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ev<span class="token punctuation">;</span>    <span class="token comment">// 在 epoll_data 中设置 fd</span>    ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token comment">// 注意 epoll_data 是 union, 如果有data并在此处设置, 那么上一行的 ev.data.fd 就不能再使用(是随机数)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span>        ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token comment">// 将所有事件都设置为 边沿触发(EPOLLET) 和 触发后取消监听(EPOLLONESHOT)</span>    ev<span class="token punctuation">.</span>events <span class="token operator">=</span> evs <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLONESHOT<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 修改监听 主要目的是让触发过的事件可以再次被触发</span><span class="token keyword">int</span> <span class="token function">epoll_mod</span><span class="token punctuation">(</span><span class="token keyword">int</span> efd<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> evs<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ev<span class="token punctuation">;</span>    ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token comment">// Being ev.data a union, in case of data != NULL, fd will be set to random</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span>        ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr <span class="token operator">=</span> data<span class="token punctuation">;</span>    ev<span class="token punctuation">.</span>events <span class="token operator">=</span> evs <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLONESHOT<span class="token punctuation">;</span>    <span class="token comment">// 通过 EPOLL_CTL_MOD 可以让事件再次能被触发</span>    <span class="token keyword">return</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除监听</span><span class="token keyword">int</span> <span class="token function">epoll_del</span><span class="token punctuation">(</span><span class="token keyword">int</span> efd<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_DEL<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里有两件事需要注意：</p><ul><li><p>第一，如前所述，<code>epoll_event</code> 中包括了一个 <code>union epoll_data</code>，其中可以保存一个 <code>fd</code> <strong>或</strong> 一个 <code>void *</code>。我们选择了使用后者，传入了我们的 <code>closure</code>，这其中包含了更多有用的信息，也包括 <code>fd</code> 在内。</p></li><li><p>第二，刚才我们定义的添加和修改函数的第三个参数，可以接收一组事件，一般而言是 <code>EPOLLIN</code> 或 <code>EPOLLOUT</code>。同时我们添加了 <code>EPOLLONESHOT</code> 标识，这意味着当事件触发一次后就不会再次触发，除非我们手动重置该事件。这样做是为了保持对低级事件触发的某种程度的控制，并为将来的多线程实现留出空间。这篇<a href="https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/">文档</a>精彩地阐述了 <code>epoll</code> 这种设计的好处，以及为什么最好使用 <code>EPOLLONESHOT</code> 标志。</p></li></ul><h2 id="epoll-循环实现"><a href="#epoll-循环实现" class="headerlink" title="epoll 循环实现"></a>epoll 循环实现</h2><p>我们继续实现我们的封装，接下来是一些回调函数的注册、周期回调的注册以及主循环。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/network.c</span></div><code class="language-c"><span class="token comment">// 添加回调</span><span class="token comment">// loop loop封装实例</span><span class="token comment">// cb 自定义事件封装 closure</span><span class="token keyword">void</span> <span class="token function">evloop_add_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">epoll_add</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>epollfd<span class="token punctuation">,</span> cb<span class="token operator">-></span>fd<span class="token punctuation">,</span> EPOLLIN<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Epoll register callback: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 添加周期事件</span><span class="token comment">// loop loop封装实例</span><span class="token comment">// seconds 以秒为单位的到期时间或触发周期</span><span class="token comment">// ns 以纳秒为单位的到期时间或触发周期</span><span class="token comment">// cb 自定义事件封装</span><span class="token keyword">void</span> <span class="token function">evloop_add_periodic_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>loop<span class="token punctuation">,</span>                              <span class="token keyword">int</span> seconds<span class="token punctuation">,</span>                              <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ns<span class="token punctuation">,</span>                              <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 表示时间间隔或时间点的结构</span>    <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> timervalue<span class="token punctuation">;</span>    <span class="token keyword">int</span> timerfd <span class="token operator">=</span> <span class="token function">timerfd_create</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timervalue<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timervalue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置初始的到期时间 (多久后执行</span>    timervalue<span class="token punctuation">.</span>it_value<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> seconds<span class="token punctuation">;</span>    timervalue<span class="token punctuation">.</span>it_value<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> ns<span class="token punctuation">;</span>    <span class="token comment">// 设置初始的触发周期 (间隔多久执行</span>    timervalue<span class="token punctuation">.</span>it_interval<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> seconds<span class="token punctuation">;</span>    timervalue<span class="token punctuation">.</span>it_interval<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> ns<span class="token punctuation">;</span>    <span class="token comment">// 设置好 timer</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">timerfd_settime</span><span class="token punctuation">(</span>timerfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timervalue<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"timerfd_settime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将 timer 添加到 epoll, 让其能够触发</span>    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ev<span class="token punctuation">;</span>    ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> timerfd<span class="token punctuation">;</span>    ev<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> timerfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"epoll_ctl(2): EPOLLIN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将周期性任务的信息绑定到 loop</span>    <span class="token comment">// 如果周期性任务的数量大于periodic_maxsize, 动态扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-></span>periodic_nr <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> loop<span class="token operator">-></span>periodic_maxsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        loop<span class="token operator">-></span>periodic_maxsize <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        loop<span class="token operator">-></span>periodic_tasks <span class="token operator">=</span>            <span class="token function">realloc</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">,</span>                    loop<span class="token operator">-></span>periodic_maxsize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 存储周期性任务的内容 timerfd 和 自定义事件</span>    loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>loop<span class="token operator">-></span>periodic_nr<span class="token punctuation">]</span> <span class="token operator">=</span>        <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>loop<span class="token operator">-></span>periodic_nr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>loop<span class="token operator">-></span>periodic_nr<span class="token punctuation">]</span><span class="token operator">-></span>closure <span class="token operator">=</span> cb<span class="token punctuation">;</span>    loop<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>loop<span class="token operator">-></span>periodic_nr<span class="token punctuation">]</span><span class="token operator">-></span>timerfd <span class="token operator">=</span> timerfd<span class="token punctuation">;</span>    <span class="token comment">// 记录当前绑定了多少周期性任务</span>    loop<span class="token operator">-></span>periodic_nr<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// epoll 主循环</span><span class="token keyword">int</span> <span class="token function">evloop_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>el<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">// 返回值</span>    <span class="token keyword">int</span> events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 单次触发事件数</span>    <span class="token keyword">long</span> <span class="token keyword">int</span> timer <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>    <span class="token comment">// 拿到我们周期性事件的 timerfd</span>    <span class="token keyword">int</span> periodic_done <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 标记是否是周期性事件并且已经执行</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 等待事件发生</span>        events <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>el<span class="token operator">-></span>epollfd<span class="token punctuation">,</span> el<span class="token operator">-></span>events<span class="token punctuation">,</span>                            el<span class="token operator">-></span>max_events<span class="token punctuation">,</span> el<span class="token operator">-></span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 有异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 系统中断, 暂时不管</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// 确实出了问题, 结束循环</span>            rc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            el<span class="token operator">-></span>status <span class="token operator">=</span> errno<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 循环处理每个事件</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> events<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 错误校验 检查是否是错误事件 检查是否不是输入输出事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLERR<span class="token punctuation">)</span> <span class="token operator">||</span>                <span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLHUP<span class="token punctuation">)</span> <span class="token operator">||</span>                <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                 <span class="token operator">!</span><span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLOUT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 总之这个 fd 上出现了一些异常, 我们把链接关了</span>                <span class="token function">perror</span> <span class="token punctuation">(</span><span class="token string">"epoll_wait(2)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">shutdown</span><span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">close</span><span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>                el<span class="token operator">-></span>status <span class="token operator">=</span> errno<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 拿到我们的 closure</span>            <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>closure <span class="token operator">=</span> el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>            <span class="token comment">// 标记没有完成周期事件</span>            periodic_done <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">// 当没有被标识完成时, 循环查找我们存储的周期事件</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> el<span class="token operator">-></span>periodic_nr <span class="token operator">&amp;&amp;</span> periodic_done <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 找到了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">==</span> el<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>timerfd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 拿到 closure</span>                    <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>c <span class="token operator">=</span> el<span class="token operator">-></span>periodic_tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>closure<span class="token punctuation">;</span>                    <span class="token comment">// 读 timerfd</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">read</span><span class="token punctuation">(</span>el<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 执行回调</span>                    c<span class="token operator">-></span><span class="token function">call</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> c<span class="token operator">-></span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 标记完成</span>                    periodic_done <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>periodic_done <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// 并不是完成了某个周期性事件 那就是触发事件了 这里执行回调</span>            closure<span class="token operator">-></span><span class="token function">call</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> closure<span class="token operator">-></span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> rc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重置该 closure 对 read 事件的监听</span><span class="token keyword">int</span> <span class="token function">evloop_rearm_callback_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">epoll_mod</span><span class="token punctuation">(</span>el<span class="token operator">-></span>epollfd<span class="token punctuation">,</span> cb<span class="token operator">-></span>fd<span class="token punctuation">,</span> EPOLLIN<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重置该 closure 对 write 事件的监听</span><span class="token keyword">int</span> <span class="token function">evloop_rearm_callback_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">epoll_mod</span><span class="token punctuation">(</span>el<span class="token operator">-></span>epollfd<span class="token punctuation">,</span> cb<span class="token operator">-></span>fd<span class="token punctuation">,</span> EPOLLOUT<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除回调函数</span><span class="token keyword">int</span> <span class="token function">evloop_del_callback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">evloop</span> <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">closure</span> <span class="token operator">*</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">epoll_del</span><span class="token punctuation">(</span>el<span class="token operator">-></span>epollfd<span class="token punctuation">,</span> cb<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在我们之前的所有代码中，<code>evloop_wait</code> 是最有意思的，他启动一个循环不停监视 <code>epoll_wait</code>，执行错误检查，区分本次触发是周期性的自动触发或是读写触发，然后执行我们设置的回调函数。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我们的代码越写越多，这次我们又添加了一个模块。</p><p>此时我们的文件结构是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">sol/ ├── src/ │    ├── mqtt.h |    ├── mqtt.c │    ├── network.h │    ├── network.c │    ├── pack.h │    └── pack.c ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[问题]Windows环境下nssm注册的mysql服务无法启动</title>
    <link href="/%5B%E9%97%AE%E9%A2%98%5DWindows%E7%8E%AF%E5%A2%83%E4%B8%8Bnssm%E6%B3%A8%E5%86%8C%E7%9A%84mysql%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8.html"/>
    <url>/%5B%E9%97%AE%E9%A2%98%5DWindows%E7%8E%AF%E5%A2%83%E4%B8%8Bnssm%E6%B3%A8%E5%86%8C%E7%9A%84mysql%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>手上有个项目上一直使用的一键安装包，包括了上位机、后端、前端、数据库、时序库、nginx等一系列东西。一直都是通过 <code>nssm</code> 将这些软件注册成自启动服务的。注册的方式大概是这样：</p><span id="more"></span><figure><div class="code-wrapper"><pre class="line-numbers language-bat" data-language="bat"><div class="caption"><span>install.bat</span></div><code class="language-bat">:: 注册mysqlnssm-2.24\win64\nssm install xxx-scada-mysql %cd%\mysql-8.0.27-winx64\bin\mysqld.exenssm-2.24\win64\nssm set xxx-scada-mysql AppDirectory %cd%\mysql-8.0.27-winx64\bin:: 启动mysqlnssm-2.24\win64\nssm start xxx-scada-mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>前两天我们需要在公司的一台测试服务器上安装这套项目软件，先检查了公司的服务器环境，发现已经有了 <code>mysql</code> 和 <code>nginx</code> 服务，于是手动停止这两个服务，之后使用一键安装包部署项目。</p><blockquote><p>此时，系统中有一个之前已经安装的 <code>mysql</code>，称为 <code>数据库A</code>。<code>数据库A</code> 通过 <code>mysqld install</code> 命令安装了服务，称为 <code>服务A</code>， <code>服务A</code> 已经被手动停止运行。<br>一键安装包中又拷贝了一份 <code>mysql</code> 进去，称为 <code>数据库B</code>。通过 <code>nssm</code> 安装的 <code>数据库B</code> 服务称为 <code>服务B</code>。</p></blockquote><h1 id="问题过程"><a href="#问题过程" class="headerlink" title="问题过程"></a>问题过程</h1><ol><li>发现通过 <code>nssm</code> 注册的 <code>服务B</code> 无法启动，所以关闭 <code>服务B</code>。</li><li>手动运行 <code>数据库B</code> 中的 <code>mysqld</code> 程序，发现程序闪退，没有报错信息，也没有错误日志。</li><li>怀疑是依赖问题，尝试了更新 <code>MSVC</code> ，没有效果。</li><li>尝试使用 <code>数据库B</code> 中的 <code>mysqld --log-error=my.err</code> ，发现 <code>mysqld</code> 不再闪退，但是此时依然不能正常提供数据库服务，并且没有异常的错误日志。</li><li>同事启动了 <code>服务A</code> ，发现可以正常使用。</li><li>受同事启发，尝试删除 <code>服务A</code>，此时脑袋混乱，居然是使用 <code>数据库B</code> 执行的 <code>mysqld --remove</code>，没想到依然能删除 <code>服务A</code>。</li><li>发现删除 <code>服务A</code> 后，<code>数据库B</code> 中的 <code>mysqld</code> 可以正常使用了，再次尝试 <code>服务B</code> ，发现也可以正常使用。</li></ol><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>本次问题的出现，主要原因还是我对 <code>Windows</code> 系统不熟悉，对于 <code>Windows</code> 系统中服务注册原理完全不懂。</p><p>长期使用 <code>nssm</code> 进行服务管理，让我们可以一直忽略 <code>Windows</code> 的服务管理细节，不断地向前走下去。同时也让我们失去了探索 <code>Windows</code> 服务管理的动力。其实，假如世界上没有 <code>nssm</code> ，也许需要一周，也许需要一两个月，我们总是能学会注册服务的方法。</p><p>因为工具过于方便导致失去了底层能力，这次的问题只是这个道理的再一次体现而已。</p>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译]Sol - 从零开始的MQTT broker - 第一部分：协议</title>
    <link href="/translate-sol-1.html"/>
    <url>/translate-sol-1.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://codepr.github.io/posts/sol-mqtt-broker/">Sol - An MQTT broker from scratch. Part 1 - The protocol</a></p></blockquote><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我已经在物联网领域工作有一段时间了，这段时间里我一直在处理物联网架构相关的工作，探索物联网系统开发的最佳模式，研究相关的协议和标准，例如MQTT。</p><p>因为我一直在渴望着提升我编程能力的机会，我觉得在物联网方向深入研究会很有趣也很有好处。因此，我再一次 <code>git init</code> 了一个项目，并且要通过写下这些博客来挑战我自己，强迫自己进步。</p><p><strong>Sol</strong> 是一个C语言项目，一个超级简单的Linux平台的MQTT broker，支持MQTT 3.3.1，不兼容旧的版本，非常类似于轻量级的 <code>Mosquitto</code> （虽然这玩意已经是个轻量级软件了）。由于现在有很多种类的MQTT客户端，所以测试起来会比较简单。最终的成品可能会成为一个更简洁，功能更丰富的软件，我们要创造这个功能的最小化实现。顺便提一下，<strong>Sol</strong> 这个名字的来源有一半的原因是我对短名称的偏好，另一半的原因则是火星日 (The Martian docet)。或者说，<strong>Sol</strong> 可能代表<strong>S</strong>crappy <strong>O</strong>l’ <strong>L</strong>oser。emmmm</p><p><strong>注意</strong>：这个项目一直到最后才会编译，你需要跟写所有的代码步骤。如果你想要在中途进行测试，我建议你自己建一个主函数来做这些测试或者修改。</p><p>一步一步来，我一般会创建一个这样的文件结构来初始化我的C项目：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">sol/ ├── src/ ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里是Github上的<a href="https://github.com/codepr/sol/tree/tutorial">仓库</a>。</p><p>我会尝试着一步一步描述 <strong>Sol</strong> 的开发过程，但我也不会贴上所有的代码，只会解释关键的地方。你想要学习的最好方式依然是亲自编写、编译、修改代码。</p><p>这将是一系列文章，每篇文章都将讨论并主要实施项目的一个概念&#x2F;模块：</p><ul><li><a href="https://codepr.github.io/posts/sol-mqtt-broker/">第一部分 ： 协议</a> MQTT协议数据包处理的基础</li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p2/">第二部分 ： 网络</a> 解决网络通讯的功能模块</li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p3/">第三部分 ： 服务</a> 程序入口</li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p4/">第四部分 ： 数据结构</a> 常用数据结构实现</li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p5/">第五部分 ： 主题树</a> 通过特里树处理主题匹配</li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-p6/">第六部分 ： 处理器</a> 每种数据包的处理函数</li><li><a href="https://codepr.github.io/posts/sol-mqtt-broker-bonus/">特别篇 ： 多线程</a> 各种改进、bug修复、应用多线程</li></ul><p>我想说，虽然 sol 会是一个完全功能的 broker，但仍有很大改进和优化空间，以及可能的一些隐藏功能（俗称BUG）。</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p><code>broker</code> 的本质是一个中间件，它接受来自多个客户端（生产者）的输入，并使用抽象方法将其转发给一组目标客户端（消费者），这种抽象方法用于定义和管理这些客户端组，形式为 <strong>channel</strong> 或 <strong>topic</strong>（根据协议标准）。与 IRC 频道或通用聊天中的等效概念非常相似，每个消费者客户端都可以订阅 <code>topic</code>，以便接收其他客户端发布到这些 <code>topic</code> 的所有消息。</p><p>第一个想到的是建立在某种数据结构之上的服务器，这种数据结构可以轻松管理这些 <code>topic</code> 和连接的客户端（无论是生产者还是消费者）。客户端收到的每个消息都必须转发给所有订阅了该消息指定 <code>topic</code> 的其他已连接客户端。</p><p>让我们试试这种方法，使用一个 TCP 服务器和一个用于处理数据流的模块。实现服务器的方法有很多，包括线程、fork 进程和多路 I&#x2F;O，这次我将尝试用多路 I&#x2F;O 的方式。</p><p>我们先使用单线程多路 I&#x2F;O 服务器，未来有可能进行多线程拓展。实际上，用于多路复用的 <strong>epoll</strong> 接口是线程安全的。</p><h1 id="MQTT结构"><a href="#MQTT结构" class="headerlink" title="MQTT结构"></a>MQTT结构</h1><p>首先，我们需要基于<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/errata01/os/mqtt-v3.1.1-errata01-os-complete.html">官方文档</a>，制作一些描述 MQTT 协议数据包的结构体。</p><p>从 opcode 表和 MQTT 头开始，基于文档，每个数据包都包含以下三部分：</p><ul><li>fixed header（必选）</li><li>variable header（可选）</li><li>payload（可选）</li></ul><h2 id="Fixed-Header"><a href="#Fixed-Header" class="headerlink" title="Fixed Header"></a>Fixed Header</h2><p>Fixed Header的第一个字节包括了 <code>MQTT type</code> 和 <code>Flags</code>，第二到第五个字节使用可变编码的方式，存储剩余数据包的长度。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>Fixed Header</span></div><code class="language-text">| Bit    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 ||--------|---------------|---------------|| Byte 1 | MQTT type     |  Flags        ||--------|-------------------------------|| Byte 2 |                               ||  .     |      Remaining Length         ||  .     |                               || Byte 5 |                               |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Flags并不是强制填写的，只是一些控制类数据，内容如下：</p><ul><li>Dup flag： 当消息被发送超过一次时使用</li><li>QoS level： 有以下三种取值 <code>AT_MOST_ONCE</code>&#x3D;0， <code>AT_LEAST_ONCE</code>&#x3D;1 and <code>EXACTLY_ONCE</code>&#x3D;2</li><li>Retain flag： 保留标志，有保留标志的消息被发布到主题时，消息会被保留，之后连接进来的客户端也可以收到该消息。保留消息可以被另一条保留消息覆盖。</li></ul><p>所以，打开 Vim （或者其他任何你喜欢的IDE），创建名为 <code>mqtt.h</code> 的头文件，开始写关于 Fixed Header 的数据结构吧：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MQTT_HEADER_LEN</span> <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MQTT_ACK_LEN</span>    <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">/* * 回复信息枚举，用于 Fixed Header 中的第一个字节 * 准确的说是只负责设置高位的4bit */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CONNACK_BYTE</span>  <span class="token expression"><span class="token number">0x20</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUBLISH_BYTE</span>  <span class="token expression"><span class="token number">0x30</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUBACK_BYTE</span>   <span class="token expression"><span class="token number">0x40</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUBREC_BYTE</span>   <span class="token expression"><span class="token number">0x50</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUBREL_BYTE</span>   <span class="token expression"><span class="token number">0x60</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUBCOMP_BYTE</span>  <span class="token expression"><span class="token number">0x70</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SUBACK_BYTE</span>   <span class="token expression"><span class="token number">0x90</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UNSUBACK_BYTE</span> <span class="token expression"><span class="token number">0xB0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PINGRESP_BYTE</span> <span class="token expression"><span class="token number">0xD0</span></span></span><span class="token comment">/* 信息类型 */</span><span class="token keyword">enum</span> <span class="token class-name">packet_type</span> <span class="token punctuation">&#123;</span>    CONNECT     <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    CONNACK     <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>    PUBLISH     <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>    PUBACK      <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>    PUBREC      <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>    PUBREL      <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span>    PUBCOMP     <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span>    SUBSCRIBE   <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span>    SUBACK      <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span>    UNSUBSCRIBE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>    UNSUBACK    <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span>    PINGREQ     <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span>    PINGRESP    <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">,</span>    DISCONNECT  <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">qos_level</span> <span class="token punctuation">&#123;</span> AT_MOST_ONCE<span class="token punctuation">,</span> AT_LEAST_ONCE<span class="token punctuation">,</span> EXACTLY_ONCE <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">union</span> mqtt_header <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">;</span>         <span class="token comment">// 将 header 视为一个byte操作</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 将 header 视为内部结构分开操作</span>        <span class="token keyword">unsigned</span> retain <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 保留标识</span>        <span class="token keyword">unsigned</span> qos <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token comment">// qos标识</span>        <span class="token keyword">unsigned</span> dup <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">// 重复标识</span>        <span class="token keyword">unsigned</span> type <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>      <span class="token comment">// 4bit Flags</span>    <span class="token punctuation">&#125;</span> bits<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最上方的两个 <code>#define</code> 定义了 MQTT Fixed Header 和 MQTT ACK 的长度。</p><p>正如你在代码中看到的，我们利用了 <strong>union</strong>——一种可以在内存中的同一位置存储多种表示形式的结构——来表示一个字节。换句话说，与普通的 <code>struct</code> 不同，<code>union</code> 中只能有一个字段具有值（在此例中是byte或bits）。它们的内存位置是共享的，因此，通过使用<strong>位字段</strong>，我们可以有效地操作单个比特或字节的一部分。</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>我们要定义的第一个控制数据包是 CONNECT。 这是当客户端建立新连接时必须发送的第一个数据包，CONNECT 包必须是有且仅有一个，否则视为与协议不符，服务端需要断开连接。</p><p>对于每个 CONNECT，服务端需要在响应中回复 CONNACK。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mqtt_connect</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>               <span class="token comment">// 第一个byte是通用头</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>                                 <span class="token comment">// 第二个byte表示一些控制信息</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> reserved <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">unsigned</span> clean_session <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 为1时表示新session，否则表示已有session</span>            <span class="token keyword">unsigned</span> will <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">// 表示是否有遗嘱</span>            <span class="token keyword">unsigned</span> will_qos <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment">// 表示遗嘱的QOS</span>            <span class="token keyword">unsigned</span> will_retain <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">// 表示遗嘱发布时是否保留</span>            <span class="token keyword">unsigned</span> password <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// 表示是否有密码</span>            <span class="token keyword">unsigned</span> username <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// 表示是否有用户名</span>        <span class="token punctuation">&#125;</span> bits<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 载荷</span>        <span class="token keyword">unsigned</span> <span class="token keyword">short</span> keepalive<span class="token punctuation">;</span>           <span class="token comment">// 会话保活时间，单位秒</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>client_id<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>username<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>password<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>will_topic<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>will_message<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> payload<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_connack</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> byte<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">unsigned</span> session_present <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">unsigned</span> reserved <span class="token operator">:</span> <span class="token number">7</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> bits<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> rc<span class="token punctuation">;</span> <span class="token comment">// return code 返回值</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>按照这个模式，结合 MQTT v3.1.1 的文档，其他数据包的定义也比较简单了。</p><h2 id="SUBSCRIBE-UNSUBSCRIBE-PUBLISH-ACK等"><a href="#SUBSCRIBE-UNSUBSCRIBE-PUBLISH-ACK等" class="headerlink" title="SUBSCRIBE UNSUBSCRIBE PUBLISH ACK等"></a>SUBSCRIBE UNSUBSCRIBE PUBLISH ACK等</h2><p>接下来我们处理 SUBSCRIBE，UNSUBSCRIBE 和 PUBLISH。SUBSCRIBE 必须要使用 SUBACK 来响应，其他的都可以使用通用 ACK，并设置 <strong>typedef</strong> 字段的值来响应。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mqtt_subscribe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> tuples_len<span class="token punctuation">;</span>      <span class="token comment">// 接下来数据元组的长度</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">short</span> topic_len<span class="token punctuation">;</span>   <span class="token comment">// 接下来 topic 字符串的长度</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>topic<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> qos<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token operator">*</span>tuples<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_unsubscribe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> tuples_len<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">short</span> topic_len<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>topic<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token operator">*</span>tuples<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_suback</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 针对 SUB 动作的响应</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> rcslen<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>rcs<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// 发布消息</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> topiclen<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>topic<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> payloadlen<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>payload<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// 通用响应</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> pkt_id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>剩余的这一类ACK包：</p><ul><li>PUBACK</li><li>PUBREC</li><li>PUBREL</li><li>PUBCOMP</li><li>UNSUBACK</li><li>PINGREQ</li><li>PINGRESP</li><li>DISCONNECT</li></ul><p>因为有相同的结构，所以都可以通过 typedef 来定义，只是语义有所不同。最后一个 DISCONNECT，虽然严格来说不是一个 ACK，但是也有相同的结构。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> mqtt_puback<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> mqtt_pubrec<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> mqtt_pubrel<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> mqtt_pubcomp<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> mqtt_unsuback<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> mqtt_header mqtt_pingreq<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> mqtt_header mqtt_pingresp<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> mqtt_header mqtt_disconnect<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h2><p>最终我们可以定义一个通用 MQTT 包，包括上面的一切，后续我们所有的 MQTT 数据包都可以用这个结构来表示。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token keyword">union</span> mqtt_packet <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> ack<span class="token punctuation">;</span>                    <span class="token comment">// 通用ACK</span>    <span class="token keyword">union</span> mqtt_header header<span class="token punctuation">;</span>               <span class="token comment">// 通用头</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_connect</span> connect<span class="token punctuation">;</span>            <span class="token comment">// CONNECT包 (这种包里会包括一个通用头)</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_connack</span> connack<span class="token punctuation">;</span>            <span class="token comment">// CONNACK包</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_suback</span> suback<span class="token punctuation">;</span>              <span class="token comment">// SUBBACK包</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> publish<span class="token punctuation">;</span>            <span class="token comment">// PUBLISH包</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_subscribe</span> subscribe<span class="token punctuation">;</span>        <span class="token comment">// SUB包</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_unsubscribe</span> unsubscribe<span class="token punctuation">;</span>    <span class="token comment">// UNSUB包</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="MQTT函数"><a href="#MQTT函数" class="headerlink" title="MQTT函数"></a>MQTT函数</h1><h2 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h2><p>现在我们继续定义一些公共函数。在 <code>src/mqtt.h</code> 中，我们需要考虑其他模块使用 MQTT 协议时会用到哪些函数。</p><p>为了使用 MQTT 协议处理通信，我们基本上需要 4 个函数，其中客户端向服务端有 2 个，服务端向客户端也是 2 个：</p><ul><li>一个编码函数（总之就是把内存里的数据做成二进制流，这里不讨论术语）</li><li>一个解码函数（就是从二进制流恢复成内存结构）</li></ul><p>我们还需要 2 个函数来处理 fixed head 部分中变长的 Remaining Length 字段。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token comment">// 编码时生成 Remaining Length</span><span class="token keyword">int</span> <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// size_t 指uint32 或 uint64</span><span class="token comment">// 解码时解析 Remaining Length</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将char * 解码为 mqtt_packet *</span><span class="token keyword">int</span> <span class="token function">unpack_mqtt_packet</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将 mqtt_packet * 编码为 char *</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_packet</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// unsigned指 unsigned int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>我们还需要一些工具函数，用来进行基于数据包的内存分配、释放，这里没啥特别的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.h</span></div><code class="language-c"><span class="token comment">// 申请内存，制作各种MQTT包</span><span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token function">mqtt_packet_header</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> <span class="token operator">*</span><span class="token function">mqtt_packet_ack</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_connack</span> <span class="token operator">*</span><span class="token function">mqtt_packet_connack</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_suback</span> <span class="token operator">*</span><span class="token function">mqtt_packet_suback</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">,</span>                                       <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> <span class="token operator">*</span><span class="token function">mqtt_packet_publish</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span>                                         <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                                         <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放MQTT包</span><span class="token keyword">void</span> <span class="token function">mqtt_packet_release</span><span class="token punctuation">(</span><span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h1><h2 id="MQTT包编解码接口"><a href="#MQTT包编解码接口" class="headerlink" title="MQTT包编解码接口"></a>MQTT包编解码接口</h2><p>好了，我们现在有一个不错的头文件了，定义了我们通讯协议中的所有内容，现在我们需要实现这些函数了。为了能够实现这些功能，首先我们要定义几个<strong>私有</strong>的帮助函数，用来进行编码和解码的动作。这些函数会被<strong>公有</strong>函数<code>unpack_mqtt_packet</code> 和 <code>pack_mqtt_packet</code> 调用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mqtt.h"</span></span><span class="token comment">// 一系列对于具体类型包的 pack unpack 函数</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_publish</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_subscribe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                                    <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">,</span>                                    <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_unsubscribe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                                      <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">,</span>                                      <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_ack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                              <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">,</span>                              <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_header</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_ack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_connack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_suback</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">pack_mqtt_publish</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="二进制流编解码实现"><a href="#二进制流编解码实现" class="headerlink" title="二进制流编解码实现"></a>二进制流编解码实现</h2><p>在继续实现 <code>src/mqtt.h</code> 上所有定义的函数之前，我们需要实现一些辅助函数，以简化每个接收到的数据包的编码解码过程。</p><p>让我们快速搞定这部分，这一块只是简单的序列化和反序列化操作而已（记得用Big-endian就行）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/pack.h</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token comment">/* 从数据流中获得数据的方法 */</span><span class="token comment">// bytes -> uint8_t</span><span class="token class-name">uint8_t</span> <span class="token function">unpack_u8</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// bytes -> uint16_t</span><span class="token class-name">uint16_t</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// bytes -> uint32_t</span><span class="token class-name">uint32_t</span> <span class="token function">unpack_u32</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取定义的 len 个字节（用来读取字符串）</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取字符串前面的 ushort 长度，并申请 dest内存块存字符串</span><span class="token class-name">uint16_t</span> <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>dest<span class="token punctuation">)</span><span class="token comment">/* 将数据写入数据流的方法 */</span><span class="token comment">// append a uint8_t -> bytes into the bytestring</span><span class="token keyword">void</span> <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// append a uint16_t -> bytes into the bytestring</span><span class="token keyword">void</span> <span class="token function">pack_u16</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// append a uint32_t -> bytes into the bytestring</span><span class="token keyword">void</span> <span class="token function">pack_u32</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将 len 个字节追加到bytes中</span><span class="token keyword">void</span> <span class="token function">pack_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>以及相应的实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/pack.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pack.h"</span></span><span class="token comment">// Reading data</span><span class="token class-name">uint8_t</span> <span class="token function">unpack_u8</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> val <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">uint16_t</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> val<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>val<span class="token punctuation">,</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">uint32_t</span> <span class="token function">unpack_u32</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> val<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>val<span class="token punctuation">,</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">ntohl</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">uint16_t</span> <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>dest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> len <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>dest <span class="token operator">=</span> <span class="token function">unpack_bytes</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">*</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Write data</span><span class="token keyword">void</span> <span class="token function">pack_u8</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token operator">*</span>buf <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">pack_u16</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> htonsval <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>htonsval<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">pack_u32</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> htonlval <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>htonlval<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">pack_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">,</span> str<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">+=</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这样我们就完成了字节流和数据类型的双向转换工作。</p><h2 id="Remaining-Length编解码实现"><a href="#Remaining-Length编解码实现" class="headerlink" title="Remaining Length编解码实现"></a>Remaining Length编解码实现</h2><p>完成了 <code>pack</code> 部分后，我们需要把他们运用在我们的MQTT包里，首先当然是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pack.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>第一步我们可以实现对 Fixed Header 中的 Remaining Length 字段的操作。MQTT文档中提供了这一段实现的伪代码，我们可以仿写一下。</p><p>让我们来看看 Remaining Length 如何用1-4个变长的Byte来表示剩余包的长度。</p><blockquote><p>Remaining Length 表示的是数据包剩余部分的长度，包括 variable header 和 payload。Remaining Length 中表示的长度不包括 Remaining Length 字段本身所占用的长度。</p><p>Remaining Length 的编码使用了一种可变长度编码方案，该方案对 127 以下的值使用单个字节。较大的值则按以下方式处理：每个字节的低 7 位编码数据，高位用于指示是否存在后续字节。因此，每个字节编码 128 个值和一个 “延续位”。Remaining Length 字段的最大字节数为 4。</p></blockquote><p>MQTT的文档已经描述的非常清晰，我们只需要实现。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">/* * 基于 MQTT v3.1.1，Fixed Header 中的 Remaining Length 最大为4byte */</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAX_LEN_BYTES <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">/* * 根据数据包长度制作变长的 Remaining Length * return Remaining Length 的字节长度 * buf Remaining Length 的数据流 * len Remaining Length 应该表示的值（可变头+载荷总长度） */</span><span class="token keyword">int</span> <span class="token function">mqtt_encode_length</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 字节长度</span>    <span class="token keyword">int</span> bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> MAX_LEN_BYTES<span class="token punctuation">)</span>            <span class="token keyword">return</span> bytes<span class="token punctuation">;</span>        <span class="token keyword">short</span> d <span class="token operator">=</span> len <span class="token operator">%</span> <span class="token number">128</span><span class="token punctuation">;</span>        len <span class="token operator">/=</span> <span class="token number">128</span><span class="token punctuation">;</span>        <span class="token comment">// len > 0 表示还有后续位</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            d <span class="token operator">|=</span> <span class="token number">128</span><span class="token punctuation">;</span> <span class="token comment">// 标记最高位</span>        buf<span class="token punctuation">[</span>bytes<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bytes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * 解析数据流中的 Remaing Length 并将指针移动到下一个位置 * return Remaining Length 的值 * buf Remaining Length 的数据流 * * TODO Handle case where multiplier > 128 * 128 * 128 */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token comment">// 乘数</span>    <span class="token keyword">int</span> multiplier <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 值</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">*</span>buf<span class="token punctuation">;</span>        value <span class="token operator">+=</span> <span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">*</span> multiplier<span class="token punctuation">;</span>        multiplier <span class="token operator">*=</span> <span class="token number">128</span><span class="token punctuation">;</span>        <span class="token comment">// 后移一位</span>        <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 当没有后续位标识时结束</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="CONNECT-解码实现"><a href="#CONNECT-解码实现" class="headerlink" title="CONNECT 解码实现"></a>CONNECT 解码实现</h2><p>好了，现在我们可以完整的解析 Fixed Header 了，接下来我们试着解码 CONNECT 包。</p><p>CONNECT 是一个有很多flags的包，而且长度仅次于 PUBLISH 包。</p><p>CONNECT 包的内容包括：</p><ul><li>Fixed Header 中的 MQTT type + Flags，高4位（MQTT type）（称为<strong>MSB</strong>）的值是<code>1</code>，表示<code>Connect type</code>，低4位（Flags）（<strong>LSB</strong>）保留</li><li>Fixed Header 中的变长 Remaining Length，表示剩余部分的长度</li><li>Variable Header，由四个字段组成：<ul><li>Protocol Name</li><li>Protocol Level</li><li>Connect Flags</li><li>Keep Alive</li></ul></li><li>可能存在或者不存在的 payload（基于 Connect Flags 的设置）</li></ul><blockquote><p>Protocol Name 是 UTF-8 编码的大写字符串 “MQTT”，这个字段的长度和内容在未来版本的MQTT协议中都不会再改变。</p></blockquote><p>所以 3.1.1 版本的 Protocol Name 就是 “MQTT”，我们也不用去管旧版本的名字是什么了。</p><p>Connect flags 为一个byte，包含了一些关于客户端行为以及是否有 payload 段存在的标识：</p><table><thead><tr><th align="center">Connect flags 中的字段</th><th align="center">大小</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Username flag</td><td align="center">1bit</td><td align="center">表示用户名存在与否</td></tr><tr><td align="center">Password flag</td><td align="center">1bit</td><td align="center">表示密码存在与否</td></tr><tr><td align="center">Will retain</td><td align="center">1bit</td><td align="center">表示遗嘱是否保留</td></tr><tr><td align="center">Will QoS</td><td align="center">2bit</td><td align="center">表示遗嘱的QOS等级</td></tr><tr><td align="center">Will flag</td><td align="center">1bit</td><td align="center">表示遗嘱存在与否</td></tr><tr><td align="center">Clean Session</td><td align="center">1bit</td><td align="center">表示是否为新链接</td></tr></tbody></table><p>Connect flags的最高位保留，其他所有位都被当作bool值初始化（除了Will QoS），这些bool值在 payload 部分也有相应的字段。比如当 Username 和 Password 的值为1，那么在 payload 中会有 2byte 的 username length，紧随其后的就是 username 字符串，Password也是相同的道理。</p><p>为了说明这件事，假设我们收到了这样一个 CONNECT 包：</p><ul><li>Connect flags 中的 username 和 password 都置为1</li><li>username &#x3D; “hello”</li><li>password &#x3D; “nacho”</li><li>client ID &#x3D; “danzan”</li></ul><p>那么这个数据包应该长这样：</p><table><thead><tr><th>字段</th><th align="center">大小</th><th align="center">偏移量</th><th>描述</th></tr></thead><tbody><tr><td>Packet type + Falgs</td><td align="center">1</td><td align="center">0</td><td>类型为<code>Connect type</code> <code>0x01</code>，Flags为空</td></tr><tr><td>Length</td><td align="center">1</td><td align="center">1</td><td>后续总长度32Byte，小于127，所以可以用1Byte表示</td></tr><tr><td>Protocol name length</td><td align="center">2</td><td align="center">2</td><td>协议名长度，值固定为 <code>0x04</code></td></tr><tr><td>Protocol name</td><td align="center">4</td><td align="center">4</td><td>‘M’ ‘Q’ ‘T’ ‘T’</td></tr><tr><td>Protocol level</td><td align="center">1</td><td align="center">8</td><td>对于MQTT 3.1.1 此字段值为 <code>0x04</code></td></tr><tr><td>Connect flags</td><td align="center">1</td><td align="center">9</td><td>包括 <code>Username</code>, <code>password</code>, <code>will retain</code>, <code>will QoS</code>, <code>will flag</code>, <code>clean session</code></td></tr><tr><td>Keepalive</td><td align="center">2</td><td align="center">10</td><td>ushort，保活时间，单位秒，最大值65536（18小时12分15秒）</td></tr><tr><td>Client ID length</td><td align="center">2</td><td align="center">12</td><td>ushort, 此例中值为<code>0x06</code> (danzan)</td></tr><tr><td>Client ID</td><td align="center">6</td><td align="center">14</td><td>‘d’ ‘a’ ‘n’ ‘z’ ‘a’ ‘n’</td></tr><tr><td>Username length</td><td align="center">2</td><td align="center">20</td><td>ushort, 此例中值为<code>0x05</code> (hello)</td></tr><tr><td>Username</td><td align="center">5</td><td align="center">22</td><td>‘h’ ‘e’ ‘l’ ‘l’ ‘o’</td></tr><tr><td>Password length</td><td align="center">2</td><td align="center">27</td><td>ushort,  此例中值为<code>0x05</code> (nacho)</td></tr><tr><td>Password</td><td align="center">5</td><td align="center">29</td><td>‘n’ ‘a’ ‘c’ ‘h’ ‘o’</td></tr></tbody></table><p>例如因为 Will Flags 被置为0，所以我们不需要在 <code>payload</code> 中解析这个字段（也压根没有），上例中我们要解析的内容总共就是包括 Fixed Header 在内的 34个byte。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">/* * CONNECT 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span>hdr<span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 制作一个connect结构体，并且用已经解码好的头部赋值</span>    <span class="token comment">// 此处有一个已经解码好的头部，是因为数据作为二进制流进来的时候，肯定是要先解码出头部，然后再根据包类型分到不同的函数里做进一步解码的</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_connect</span> connect <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token operator">*</span>hdr <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 将这个结构体赋值到pkt</span>    pkt<span class="token operator">-></span>connect <span class="token operator">=</span> connect<span class="token punctuation">;</span>    <span class="token comment">// 初始指针指向buf的首部</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>init <span class="token operator">=</span> buf<span class="token punctuation">;</span>    <span class="token comment">/*     * 获得后续的变长总长度,同时将指针移动到 protocol name     */</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 暂时忽略协议名称、保留字段等等，所以直接向后移动8byte</span>    <span class="token comment">// 这里 init 直接+8，暗示了变长长度字段的长度是1byte，所以才能+8后指向Connect flags</span>    buf <span class="token operator">=</span> init <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">// 读取 Connect flags</span>    pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>byte <span class="token operator">=</span> <span class="token function">unpack_u8</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 读取 keepalive</span>    pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>keepalive <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 读取 CID 长度（如果有CID则>0，否则为0）</span>    <span class="token class-name">uint16_t</span> cid_len <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果有，则读取CID</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cid_len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>cid_len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> cid_len<span class="token punctuation">,</span>                     pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>client_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果有，则读取遗嘱</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>will <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>will_topic<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>will_message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果有，则读取用户名</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>username <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果有，则读取密码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>password <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pkt<span class="token operator">-></span>connect<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><!-- read --><h2 id="PUBLISH-解码实现"><a href="#PUBLISH-解码实现" class="headerlink" title="PUBLISH 解码实现"></a>PUBLISH 解码实现</h2><p>以下是 PUBLISH 包的结构：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|   Bit    |  7  |  6  |  5  |  4  |  3  |  2  |  1  |   0    |  &lt;-- Fixed Header|----------|-----------------------|--------------------------|| Byte 1   |      MQTT type 3      | dup |    QoS    | retain ||----------|--------------------------------------------------|| Byte 2   |                                                  ||  .       |               Remaining Length                   ||  .       |                                                  || Byte 5   |                                                  ||----------|--------------------------------------------------|  &lt;-- Variable Header| Byte 6   |                Topic len MSB                     || Byte 7   |                Topic len LSB                     ||-------------------------------------------------------------|| Byte 8   |                                                  ||   .      |                Topic name                        || Byte N   |                                                  ||----------|--------------------------------------------------|| Byte N+1 |            Packet Identifier MSB                 || Byte N+2 |            Packet Identifier LSB                 ||----------|--------------------------------------------------|  &lt;-- Payload| Byte N+3 |                   Payload                        || Byte N+M |                                                  |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>仅当 QoS level &gt; 0 时，存在 Packet identifier MSB 和 LSB。当 QoS 被设置为 <em>at most once</em> （值为0）时，没有必要存在 packet ID。</p><p>Payload部分的长度通过 Remaining Length 减去其他所有内容计算得来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">/* * PUBLISH 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_publish</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span>hdr<span class="token punctuation">,</span>                                  <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建 PUBLISH 包并且使用已经解码好的 header 赋值</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_publish</span> publish <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token operator">*</span>hdr <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 准备给返回值提供这个 PUBLISH 包</span>    pkt<span class="token operator">-></span>publish <span class="token operator">=</span> publish<span class="token punctuation">;</span>    <span class="token comment">// 通过变长的 Remaing Length 字段获取剩余部分的长度</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获得 topiclen 和 topic 内容</span>    pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topiclen <span class="token operator">=</span> <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 len 赋值, 并视为 payload 长度</span>    <span class="token class-name">uint16_t</span> message_len <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token comment">// 如果 QoS > 0, 需要读取pkt_id</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>publish<span class="token punctuation">.</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>qos <span class="token operator">></span> AT_MOST_ONCE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>pkt_id <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 此时payload长度需要减去pkt_id</span>        message_len <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// payload 长度需要减去 topic_len 字段长度和 topic 字段实际长度</span>    message_len <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span> <span class="token operator">+</span> topic_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里是正确的 payloadlen</span>    pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payloadlen <span class="token operator">=</span> message_len<span class="token punctuation">;</span>    <span class="token comment">// 读取 payload</span>    pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>message_len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unpack_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> message_len<span class="token punctuation">,</span> pkt<span class="token operator">-></span>publish<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="SUBSCRIBE-和-UNSUBSCRIBE-解码实现"><a href="#SUBSCRIBE-和-UNSUBSCRIBE-解码实现" class="headerlink" title="SUBSCRIBE 和 UNSUBSCRIBE 解码实现"></a>SUBSCRIBE 和 UNSUBSCRIBE 解码实现</h2><p>SUBSCRIBE 包和 UNSUBSCRIBE 包的结构非常相似。他们的 payload 部分都是一个 topic 相关的元组列表，其中 SUBSCRIBE 的元组是 (topic_len, topic_filter, qos)，而 UNSUBSCRIBE 是 (topic_len, topic_filter)。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">/* * SUBSCRIBE 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_subscribe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span>                                    <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span>hdr<span class="token punctuation">,</span>                                    <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建 SUBSCRIBE 包并且使用已经解码好的 header 赋值</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_subscribe</span> subscribe <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token operator">*</span>hdr <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 通过变长的 Remaing Length 字段获取剩余部分的长度</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> remaining_bytes <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token comment">// 读取pkt_id</span>    subscribe<span class="token punctuation">.</span>pkt_id <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    remaining_bytes <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * 订阅频道列表, 由一系列三元组构成     *  - topic length 主题字符串长度     *  - topic filter (string) 主题filter     *  - qos     */</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>remaining_bytes <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 减去2byte, 是topic length的空间</span>        remaining_bytes <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 给这个主题字符串分配内存</span>        subscribe<span class="token punctuation">.</span>tuples <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">,</span>                                   <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获得主题字符串长度, 获得主题字符串内容</span>        subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len <span class="token operator">=</span>            <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 减去主题字符串实际占用的空间</span>        remaining_bytes <span class="token operator">-=</span> subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len<span class="token punctuation">;</span>        <span class="token comment">// 获得主题qos</span>        subscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>qos <span class="token operator">=</span> <span class="token function">unpack_u8</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 减去主题 qos 的空间</span>        len <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 操作下一个主题</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 记录订阅主题数</span>    subscribe<span class="token punctuation">.</span>tuples_len <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token comment">// 记录到 mqtt_packet</span>    pkt<span class="token operator">-></span>subscribe <span class="token operator">=</span> subscribe<span class="token punctuation">;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * UNSUBSCRIBE 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_unsubscribe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span>                                      <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span>hdr<span class="token punctuation">,</span>                                      <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_unsubscribe</span> unsubscribe <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token operator">*</span>hdr <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">/*     * Second byte of the fixed header, contains the length of remaining bytes     * of the connect packet     */</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> remaining_bytes <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token comment">/* Read packet id */</span>    unsubscribe<span class="token punctuation">.</span>pkt_id <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    remaining_bytes <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * Read in a loop all remaining bytes specified by len of the Fixed Header.     * From now on the payload consists of 2-tuples formed by:     *  - topic length     *  - topic filter (string)     */</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>remaining_bytes <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* Read length bytes of the first topic filter */</span>        remaining_bytes <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* We have to make room for additional incoming tuples */</span>        unsubscribe<span class="token punctuation">.</span>tuples <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>unsubscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">,</span>                                     <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>unsubscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unsubscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len <span class="token operator">=</span>            <span class="token function">unpack_string16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>unsubscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>        remaining_bytes <span class="token operator">-=</span> unsubscribe<span class="token punctuation">.</span>tuples<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>topic_len<span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    unsubscribe<span class="token punctuation">.</span>tuples_len <span class="token operator">=</span> i<span class="token punctuation">;</span>    pkt<span class="token operator">-></span>unsubscribe <span class="token operator">=</span> unsubscribe<span class="token punctuation">;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="ACK-解码实现"><a href="#ACK-解码实现" class="headerlink" title="ACK 解码实现"></a>ACK 解码实现</h2><p>最终到了 ACK 包，MQTT 协议中没有设计通用 ACK，但是实际上每个 ACK 包的数据结构都是一样的，有一个 Fixed Header 和一个 packet_id组成。</p><p>MQTT 协议中有如下几种类型的ACK:</p><ul><li>PUBACK</li><li>PUBREC</li><li>PUBREL</li><li>PUBCOMP</li><li>UNSUBACK</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">/* * ACK 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */</span><span class="token keyword">static</span> <span class="token class-name">size_t</span> <span class="token function">unpack_mqtt_ack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span>                              <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span>hdr<span class="token punctuation">,</span>                              <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建 ACK 包并且使用已经解码好的 header 赋值</span>    <span class="token keyword">struct</span> <span class="token class-name">mqtt_ack</span> ack <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token operator">*</span>hdr <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 通过变长的 Remaing Length 字段获取剩余部分的长度</span>    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">mqtt_decode_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// pkt_id</span>    ack<span class="token punctuation">.</span>pkt_id <span class="token operator">=</span> <span class="token function">unpack_u16</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    pkt<span class="token operator">-></span>ack <span class="token operator">=</span> ack<span class="token punctuation">;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="MQTT包解码实现"><a href="#MQTT包解码实现" class="headerlink" title="MQTT包解码实现"></a>MQTT包解码实现</h2><p>现在我们已经实现了 <code>unpack_mqtt_packet</code> 需要的所有工具函数，接下来我们先定义一个解码函数的接口，然后使用一个静态数组来索引所有的解码函数，这里我们直接使用 <code>Control Packet type</code> 的值来作为数组中的索引。</p><p>需要注意的是，<code>DISCONNECT</code> <code>PINGREQ</code> <code>PINGRESP</code> 这三种包只有一个byte，所以我们不需要编写解码工具函数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>src/mqtt.c</span></div><code class="language-c"><span class="token comment">// 解码函数接口</span><span class="token keyword">typedef</span> <span class="token class-name">size_t</span> <span class="token function">mqtt_unpack_handler</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>                                   <span class="token keyword">union</span> mqtt_header <span class="token operator">*</span><span class="token punctuation">,</span>                                   <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 所有解码函数的列表, 索引值和包类型对应</span><span class="token keyword">static</span> mqtt_unpack_handler <span class="token operator">*</span>unpack_handlers<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    unpack_mqtt_connect<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    unpack_mqtt_publish<span class="token punctuation">,</span>    unpack_mqtt_ack<span class="token punctuation">,</span>    unpack_mqtt_ack<span class="token punctuation">,</span>    unpack_mqtt_ack<span class="token punctuation">,</span>    unpack_mqtt_ack<span class="token punctuation">,</span>    unpack_mqtt_subscribe<span class="token punctuation">,</span>    <span class="token constant">NULL</span><span class="token punctuation">,</span>    unpack_mqtt_unsubscribe<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// MQTT 包解码入口</span><span class="token keyword">int</span> <span class="token function">unpack_mqtt_packet</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">union</span> mqtt_packet <span class="token operator">*</span>pkt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 第一个 byte 是 fiexd header 中的 mqttType + flags</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> type <span class="token operator">=</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    <span class="token comment">// 第一个byte可以被作为header</span>    <span class="token keyword">union</span> mqtt_header header <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span>byte <span class="token operator">=</span> type    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 对于这些包暂时无需解码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type <span class="token operator">==</span> DISCONNECT        <span class="token operator">||</span> header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type <span class="token operator">==</span> PINGREQ        <span class="token operator">||</span> header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type <span class="token operator">==</span> PINGRESP<span class="token punctuation">)</span>        pkt<span class="token operator">-></span>header <span class="token operator">=</span> header<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 通过包类型找到解码函数, 执行解码操作后返回rc, 此时rc等于具体解码函数的返回值</span>        rc <span class="token operator">=</span> unpack_handlers<span class="token punctuation">[</span>header<span class="token punctuation">.</span>bits<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">++</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>header<span class="token punctuation">,</span> pkt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>从零开始MQTT broker的第一部分就这样结束了，我们做了两个模块，一个根据 OASIS 定义的标准描述MQTT协议结构，另一个则用来处理编解码操作。</p><p>此时我们的文件结构是这样的：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">sol/ ├── src/ │    ├── mqtt.h │    ├── mqtt.c │    ├── pack.h │    └── pack.c ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>MQTT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>翻译</tag>
      
      <tag>C</tag>
      
      <tag>MQTT</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[翻译] n2n 常见问题</title>
    <link href="/n2n%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <url>/n2n%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://github.com/ntop/n2n/blob/dev/doc/Faq.md">n2n Frequently Asked Questions</a></p></blockquote><span id="more"></span><h1 id="n2n-常见问题"><a href="#n2n-常见问题" class="headerlink" title="n2n 常见问题"></a>n2n 常见问题</h1><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="哪里能找到Windows系统的n2n软件？"><a href="#哪里能找到Windows系统的n2n软件？" class="headerlink" title="哪里能找到Windows系统的n2n软件？"></a>哪里能找到Windows系统的n2n软件？</h3><p>我们没有在<code>release</code>中发布Windows版本的n2n，但是我们的自动化测试流程会创建他们。你可以点击项目界面中的 <code>Actions</code>，选择 <code>Testing</code>，进入最近一次的运行实例，在界面最下方的 <code>Artifacts</code> 处下载 <code>binaries</code>，其中就包括了编译好的windows版本<code>n2n</code>。通常来说你可以使用 <code>x86_64-w64-mingw32\usr\sbin</code> 路径下的版本。</p><p>此外，正如我们的<a href="https://github.com/ntop/n2n#further-readings-and-related-projects">README</a>中提到的，luckytu 一直在更新<code>n2n</code>的<a href="https://github.com/lucktu/n2n">Windows版本</a>，你也可以在他那里直接下载编译后的软件。</p><h2 id="Supernode"><a href="#Supernode" class="headerlink" title="Supernode"></a>Supernode</h2><h3 id="我想部署一个私有的，有密码保护的supernode，需要怎么设置？"><a href="#我想部署一个私有的，有密码保护的supernode，需要怎么设置？" class="headerlink" title="我想部署一个私有的，有密码保护的supernode，需要怎么设置？"></a>我想部署一个私有的，有密码保护的supernode，需要怎么设置？</h3><p>你可以直接配置 <code>community.list</code> 文件，在其中设置一个 <code>&lt;community name&gt;</code> (输入单行文本即可) ，然后把这个 <code>&lt;community name&gt;</code> 当作您的密码。</p><p>在启动 <code>supernode</code> 时，记得加上 <code>-c &lt;community file&gt;</code> 参数指定配置文件。这样，只有设置了 <code>-c &lt;community name&gt;</code> 的 <code>edge</code> 可以使用 <code>supernode</code>。</p><p>此时，在您的 <code>edge</code> 向 <code>supernode</code> 注册的过程中，<code>&lt;community name&gt;</code> 是明文传递的。如果您想要对传输过程进行加密，需要在<strong>所有</strong> <code>edge</code> 节点启动时添加 <code>-H</code> 参数。</p><p>另外，请参阅 <code>n2n</code> 附带的 <code>community.list</code> 文件以了解该文件的高级使用。</p><p>除了这个访问障碍之外，您可能希望在边缘使用有效负载加密 -A_。</p><p>只有边缘（而不是超级节点）能够解密有效负载数据。</p><p>因此，即使任何人都能够打破超级节点的访问障碍，有效负载仍然受到有效负载加密的保护，请参阅此文档了解详细信息。</p><p>除了上述的这些安全手段之外，您还可以在 <code>edge</code> 添加 <code>-A_</code> 参数来加密传输的数据。数据的加密和解密都是 <code>edge</code> 进行的，所以即使是 <code>supernode</code> 节点也无法解密数据内容。因此，即使你的 <code>supernode</code> 节点被黑客入侵，你的数据内容依然是被加密算法保护的。更多细节可以参考这一篇关于加密的<a href="https://github.com/ntop/n2n/blob/dev/doc/Crypto.md">文档</a>。</p><h3 id="我可以在supernode查看接入的edge列表吗？"><a href="#我可以在supernode查看接入的edge列表吗？" class="headerlink" title="我可以在supernode查看接入的edge列表吗？"></a>我可以在supernode查看接入的edge列表吗？</h3><p>可以，<code>supernode</code> 通过UDP提供了基本的管理接口，默认端口是5645，可以通过 <code>-t</code> 参数修改。</p><p>只需要发送一个新的行就可以查询当前状态，例如，在 <code>supernode</code> <strong>本机</strong>（远程链接不可以）上按下[ENTER]键，然后输入如下命令：</p><p><code>netcat -u localhost 5645</code></p><h3 id="支持多个supernode节点的部署方式吗？"><a href="#支持多个supernode节点的部署方式吗？" class="headerlink" title="支持多个supernode节点的部署方式吗？"></a>支持多个supernode节点的部署方式吗？</h3><p>支持，这篇<a href="https://github.com/ntop/n2n/blob/dev/doc/Federation.md">文档</a>描述了如何部署多个 <code>supernode</code> 节点来提升网络的可用性。</p><h3 id="supernode可以监听多个UDP端口吗？"><a href="#supernode可以监听多个UDP端口吗？" class="headerlink" title="supernode可以监听多个UDP端口吗？"></a>supernode可以监听多个UDP端口吗？</h3><p><code>supernode</code> 本身只支持监听一个端口，但是你应该可以通过做NAT的方式将多个端口映射到同一个端口上，例如：</p><p><code>sudo iptables -t nat -A PREROUTING -i &lt;network interface name&gt; -d &lt;supernode&#39;s ip address&gt; -p udp --dport &lt;additional port number&gt; -j REDIRECT --to-ports &lt;regular supernode port number&gt;</code></p><p>这条命令可以作为 <code>ExecStartPost=</code> 添加到 <code>supernode</code> 的 <code>.service</code> 文件中（不需要加sudo），如果需要映射多个端口，可以多加几行。</p><h3 id="这个报错是怎么回事-“process-udp-dropped-a-packet-with-seemingly-encrypted-header-for-which-no-matching-community-which-uses-encrypted-headers-was-found”？"><a href="#这个报错是怎么回事-“process-udp-dropped-a-packet-with-seemingly-encrypted-header-for-which-no-matching-community-which-uses-encrypted-headers-was-found”？" class="headerlink" title="这个报错是怎么回事 “process_udp dropped a packet with seemingly encrypted header for which no matching community which uses encrypted headers was found”？"></a>这个报错是怎么回事 “process_udp dropped a packet with seemingly encrypted header for which no matching community which uses encrypted headers was found”？</h3><p>这条报错的意思是 <code>supernode</code> 收到了一个无法使用的数据包。<code>supernode</code> 先将这个包视为一个未加密的包来处理，如果处理失败的话，<code>supernode</code> 会<strong>假定</strong>这是一个加密的数据包，之后 <code>supernode</code> 会尝试所有可以生成key的 <code>community</code> （排除明确没有加密的<code>community</code>）。如果任何 <code>community</code> 的key都无法解开此数据包，就会产生这条报错。</p><p>如果所有 <code>edge</code> 的 <code>-H</code> 参数配置是相同的（都有 <code>-H</code> 或者都没有 <code>-H</code> ），并且重启 <code>supernode</code> 后依然报错，最大的可能是 <code>supernode</code> 或者 <code>edge</code> 的版本不一致，导致了数据包格式不一致。</p><p>因此，请确保所有 <code>edge</code> <strong>和</strong> <code>supernode</code> 具有完全相同的版本，例如：最新的 <code>_dev_</code> 分支。</p><h2 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h2><h3 id="如何查看p2p链接的状态？"><a href="#如何查看p2p链接的状态？" class="headerlink" title="如何查看p2p链接的状态？"></a>如何查看p2p链接的状态？</h3><p><code>edge</code> 同样提供了一个本地的UDP管理端口，包括了 <em>peers</em> 这种已经建立的p2p链接，还有 <em>pending peers</em> 这种通过 <code>supernode</code> 中转的链接。</p><p><code>edge</code> 的默认管理端口号是 5644，可以通过 <code>-t</code> 参数修改。可以在<strong>本机</strong>通过此命令查看：</p><p><code>netcat -u localhost 5644</code></p><p>发送空行就可以查看链接信息，对于其他的命令行功能，请通过 <code>help</code> 查看。</p><h3 id="edge-反复报错-“Authentication-error-MAC-or-IP-address-already-in-use-or-not-released-yet-by-supernode”。是什么问题？"><a href="#edge-反复报错-“Authentication-error-MAC-or-IP-address-already-in-use-or-not-released-yet-by-supernode”。是什么问题？" class="headerlink" title="edge 反复报错 “Authentication error. MAC or IP address already in use or not released yet by supernode”。是什么问题？"></a>edge 反复报错 “Authentication error. MAC or IP address already in use or not released yet by supernode”。是什么问题？</h3><p>Edge 遇到了 n2n 的防欺骗保护。</p><p>它可以防止一个边缘的身份（MAC 和 IP 地址）在原始边缘仍然在线时被其他边缘冒充，请参阅一些详细信息。</p><p>大多数情况下，有两种情况可以触发此操作：</p><p>这是触发了 <code>n2n</code> 的防欺骗保护机制，这个机制可以防止已经在线的 <code>edge</code> 节点被其他人冒充，这篇<a href="Authentication.md">文档</a>有更详细的描述。总之，大部分情况下，有两种可能触发这个机制：</p><p>你使用的 MAC 地址或 IP 地址已经被使用了，修改这些参数就可以了。</p><p>如果一个 <code>edge</code> 非正常退出，例如被 <code>kill -9 ...</code> 或 <code>kill -SIGKILL ...</code>，那么这个 <code>edge</code> 可能没有机会通知 <code>supernode</code> 取消注册，因此 <code>supernode</code> 仍然认为此 <code>edge</code> 在线，此时具有相同 MAC 或 IP 地址的注册就不会成功。</p><p><code>supernode</code> 记录 <code>edge</code> 的超时时间是两分钟，所以可以等待两分钟，或者换不同的 MAC 和 IP 地址注册。</p><p>基本上来说，不管是 <code>CTRL</code> + <code>C</code> 或是 <code>kill -SIGTERM ...</code> 或者 <code>kill -SIGINT ...</code> 或者 <code>kill ...</code> 不带9，都可以正常的结束 <code>edge</code>，在管理接口下发 <code>stop</code> 命令也可以停止 <code>edge</code> ，所以大部分情况下无需使用 <code>kill -9 ...</code>。</p>]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>网络工具</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用n2n连接不同局域网设备</title>
    <link href="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87.html"/>
    <url>/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目的是想在办公室使用家里的服务器</p><p>家里有不固定的公网IP，办公室有固定的公网IP，因此打算使用办公室服务器做Server</p><p>为什么不用frp？：因为想获得一个完整的网络服务，而frp只能做端口映射，如果开发过程中新增端口，需要修改frp就很麻烦</p><span id="more"></span><h1 id="n2n简介"><a href="#n2n简介" class="headerlink" title="n2n简介"></a>n2n简介</h1><p><code>n2n</code> 是一个开源项目，地址在这里：</p><p><a href="https://github.com/ntop/n2n">https://github.com/ntop/n2n</a></p><p><code>n2n</code> 是一个二层VPN技术，他能在家里的服务器和办公室的服务器之间创建一个局域网链接</p><p><code>n2n</code> 网络由 <code>supernode</code> 和 <code>edge</code> 组成，可以简单理解为同一 <code>supernode</code> 下的所有 <code>edge</code> 都处在同一个局域网中。</p><h1 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h1><h2 id="办公室网络："><a href="#办公室网络：" class="headerlink" title="办公室网络："></a>办公室网络：</h2><ul><li>网段：192.168.34.0&#x2F;24</li><li>网关：192.168.34.1</li><li>网关公网地址：88.88.88.88</li><li>服务器地址：192.168.34.194</li></ul><h2 id="家庭网络"><a href="#家庭网络" class="headerlink" title="家庭网络"></a>家庭网络</h2><ul><li>网段：192.168.0.0&#x2F;24</li><li>网关：192.168.0.1</li><li>网关公网地址：不固定</li><li>服务器地址：192.168.0.12</li></ul><h2 id="规划n2n网络"><a href="#规划n2n网络" class="headerlink" title="规划n2n网络"></a>规划n2n网络</h2><p>由于办公室有固定的公网地址，就由办公室服务器充当 <code>supernode</code>，同时家庭服务器和办公室服务器都是此 <code>supernode</code> 下的 <code>edge</code><br><code>n2n</code> 会形成一个新的局域网，规划如下：</p><ul><li>网段：10.0.34.0&#x2F;24</li><li>网关：无</li><li>办公室服务器：10.0.34.21</li><li>家庭服务器：10.0.34.41</li></ul><h1 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h1><h2 id="下载安装n2n"><a href="#下载安装n2n" class="headerlink" title="下载安装n2n"></a>下载安装n2n</h2><p>在办公室服务器和家庭服务器都下载并安装 <code>n2n</code>：</p><p><a href="https://github.com/ntop/n2n/releases">https://github.com/ntop/n2n/releases</a></p><p>安装完成后，服务器中会自动生成两个服务 <code>supernode</code> 和 <code>edge</code></p><p>配置文件位于 <code>/etc/n2n/</code></p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/installVerify.png"></p><h2 id="配置办公室服务器"><a href="#配置办公室服务器" class="headerlink" title="配置办公室服务器"></a>配置办公室服务器</h2><p>办公室服务器需要承担三个职能：充当 <code>supernode</code>，充当 <code>edge</code>，转发其他办公室设备到家庭服务器的网络包</p><h3 id="配置supernode"><a href="#配置supernode" class="headerlink" title="配置supernode"></a>配置supernode</h3><p>配置 <code>/etc/n2n/community.list</code> 文件，指定community名称</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><div class="caption"><span>community.list</span></div><code class="language-text">com8888 # community名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>复制 <code>supernode.conf.sample</code> 文件，并修改配置内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>bash</span></div><code class="language-bash"><span class="token function">cp</span> /etc/n2n/supernode.conf.sample /etc/n2n/supernode.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>bash</span></div><code class="language-bash"><span class="token function">vi</span> /etc/n2n/supernode.conf  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><div class="caption"><span>supernode.conf</span></div><code class="language-conf">-p&#x3D;7777 # 指定supernode服务端口-c&#x3D;&#x2F;etc&#x2F;n2n&#x2F;community.list # 指定引用的community文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>启动supernode</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>shell</span></div><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> supernodesystemctl start supernode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>之后可以看到 <code>supernode</code> 已经启动，并且在7777端口提供服务：</p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/supernodeVerify.png"></p><h3 id="配置edge"><a href="#配置edge" class="headerlink" title="配置edge"></a>配置edge</h3><p>配置 <code>edge</code> 使办公室服务器成为 <code>n2n</code> 网络的成员</p><p>复制 <code>edge.conf.sample</code> 文件，并修改配置内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>bash</span></div><code class="language-bash"><span class="token function">cp</span> /etc/n2n/edge.conf.sample /etc/n2n/edge.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>bash</span></div><code class="language-bash"><span class="token function">vi</span> /etc/n2n/edge.conf  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><div class="caption"><span>edge.conf</span></div><code class="language-conf">-d&#x3D;n2n0 # 指定虚拟网卡名称-c&#x3D;com8888 # community名称-k&#x3D;888888 # 通讯加密密钥-a&#x3D;10.0.34.21 # 在n2n网络中的地址-l&#x3D;127.0.0.1:7777 # supernode服务地址-r # 允许通过n2n转发数据包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>启动edge</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>shell</span></div><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> edgesystemctl start edge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>启动后，可以看到 <code>n2n</code> 已经添加了虚拟网卡：</p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/edgeVerify.png"></p><h3 id="开启数据包转发功能"><a href="#开启数据包转发功能" class="headerlink" title="开启数据包转发功能"></a>开启数据包转发功能</h3><p>需要通过办公室服务器转发办公室其他电脑到家庭服务器的流量，因此需要在办公室服务器上开启数据包转发功能</p><p>需要将 <code>/etc/sysctl.conf</code> 文件中的 <code>net.ipv4.ip_forward</code> 修改为 1</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>bash</span></div><code class="language-bash"><span class="token function">vi</span> /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><div class="caption"><span>sysctl.conf</span></div><code class="language-conf">...net.ipv4.ip_forward&#x3D;1...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="配置办公室网关"><a href="#配置办公室网关" class="headerlink" title="配置办公室网关"></a>配置办公室网关</h2><h3 id="添加静态路由"><a href="#添加静态路由" class="headerlink" title="添加静态路由"></a>添加静态路由</h3><p>其他办公室电脑没有到 <code>n2n</code> 网络的路由，因此数据包会发送到办公室网关</p><p>此时需要配置办公室网关，添加一条指向 <code>n2n</code> 网络的静态路由，下一条为办公室服务器的办公网地址</p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/gwRoute.png"></p><h2 id="配置家庭服务器"><a href="#配置家庭服务器" class="headerlink" title="配置家庭服务器"></a>配置家庭服务器</h2><h3 id="配置edge，设置自动添加路由"><a href="#配置edge，设置自动添加路由" class="headerlink" title="配置edge，设置自动添加路由"></a>配置edge，设置自动添加路由</h3><p>家庭服务器的 <code>edge</code> 安装配置过程与办公室服务器的 <code>edge</code> 大致相同，但有两点需要注意：</p><ol><li>无需添加<code>-r</code>参数，因为家庭服务器不需要将来自其他设备的包转发到<code>n2n</code>网络</li><li>需要添加<code>-n</code>参数，这样<code>edge</code>启动时会自动产生一条通过<code>n2n</code>网络到达办公室网络的路由</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-conf" data-language="conf"><div class="caption"><span>edge.conf</span></div><code class="language-conf">-d&#x3D;n2n0 # 指定虚拟网卡名称-c&#x3D;com8888 # community名称-k&#x3D;888888 # 通讯加密密钥-a&#x3D;10.0.34.41 # 在n2n网络中的地址-l&#x3D;88.88.88.88:17777 # supernode公网地址-n&#x3D;192.168.34.0&#x2F;24:10.0.34.21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><h2 id="n2n网络验证"><a href="#n2n网络验证" class="headerlink" title="n2n网络验证"></a>n2n网络验证</h2><p>使用 <code>n2n</code> 网络地址从办公室服务器ping家庭服务器，或从家庭服务器ping办公室服务器，成功</p><p>此时数据包的实际流向是 办公室服务器-&gt;办公室网关-&gt;运营商网络-&gt;家庭网关-&gt;家庭服务器</p><p>由于 <code>n2n</code> vpn的配置，此时可以认为办公室服务器和家庭服务器处在同一局域网下，tracert也仅一跳可达</p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/trace.png"></p><h2 id="办公室电脑到家庭服务器网络验证"><a href="#办公室电脑到家庭服务器网络验证" class="headerlink" title="办公室电脑到家庭服务器网络验证"></a>办公室电脑到家庭服务器网络验证</h2><p>办公室电脑ping家庭服务器，成功</p><p>此时数据包流向是 办公室电脑-&gt;办公室网关-&gt;办公室服务器-&gt;家庭服务器，其中办公室服务器到家庭服务器是 <code>n2n</code> 虚拟链路</p><p>tracert三跳可达</p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/trace2.png"></p><h2 id="家庭服务器到办公室电脑"><a href="#家庭服务器到办公室电脑" class="headerlink" title="家庭服务器到办公室电脑"></a>家庭服务器到办公室电脑</h2><p>家庭服务器ping办公室电脑，成功</p><p>此时数据包流向是 家庭服务器-&gt;办公室服务器-&gt;办公室电脑，其中家庭服务器到办公室服务器是 <code>n2n</code> 虚拟链路</p><p>tracert两跳可达</p><p><img src="/%E4%BD%BF%E7%94%A8n2n%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BE%E5%A4%87/trace3.png"></p>]]></content>
    
    
    <categories>
      
      <category>网络工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>网络工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作周报可视化</title>
    <link href="/%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5%E5%8F%AF%E8%A7%86%E5%8C%96.html"/>
    <url>/%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5%E5%8F%AF%E8%A7%86%E5%8C%96.html</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这个项目是一个纯粹的小玩具，起因是我公司的工作周报都是 <code>.doc</code> 格式存储的，现在到年底了，我又比较想知道我一年都干了哪些工作。显而易见的一个方式就是提取所有周报文字内容做词频分析。</p><span id="more"></span><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>完成之后的效果还算不错，源码也放在了github上：</p><p><a href="https://github.com/vitsumoc/weekreport2chart">https://github.com/vitsumoc/weekreport2chart</a></p><p>提取一段时间的工作周报内容，生成词云和河流图</p><p><img src="/%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud.png"></p><p><img src="/%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5%E5%8F%AF%E8%A7%86%E5%8C%96/river.png"></p><p>可以直接过滤低频词汇，或手动操作删除某些虚词、连词等</p><p><img src="/%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5%E5%8F%AF%E8%A7%86%E5%8C%96/disable.png"></p><h1 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h1><p>使用libreoffice将doc转为docx</p><p>使用结巴分词分词：<a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p><p>使用wordcloudjs词云：<a href="https://wordcloud2-js.timdream.org/#love">https://wordcloud2-js.timdream.org/#love</a></p><p>使用echarts河流图</p>]]></content>
    
    
    <categories>
      
      <category>小玩具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小玩具</tag>
      
      <tag>python</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Go中使用lua</title>
    <link href="/%E5%9C%A8Go%E4%B8%AD%E4%BD%BF%E7%94%A8lua.html"/>
    <url>/%E5%9C%A8Go%E4%B8%AD%E4%BD%BF%E7%94%A8lua.html</url>
    
    <content type="html"><![CDATA[<p>使用<code>gopher-lua</code>，在 Go 中使用lua。<code>gopher-lua</code> 项目地址：</p><p><a href="https://github.com/yuin/gopher-lua">https://github.com/yuin/gopher-lua</a></p><span id="more"></span><p>使用示例仓库地址：</p><p><a href="https://github.com/vitsumoc/my-golua">https://github.com/vitsumoc/my-golua</a></p><p>示例列表：</p><ul><li>最基础的用法</li><li>基础数据类型</li><li>在lua中调用go方法</li><li>在go中使用lua协程</li><li>示范如何手动开启模块</li><li>在lua中使用go模块</li><li>在 Go 中调用lua方法</li><li>在lua中使用 Go 数据</li><li>通过context控制停止</li><li>在有协程的情况下使用context控制</li><li>共享lua文件字节码, 减少开销</li><li>通过go协程跑lua的示例 可以把ch带到lua中 和相关限制</li><li>在lua中使用ch的例子</li><li>lua虚拟机池</li><li>在 Go 中提供钩子, 使lua可以注册脚本, 在脚本中获得并修改用户数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSH包装Socks5代理</title>
    <link href="/%E4%BD%BF%E7%94%A8SSH%E5%8C%85%E8%A3%85Socks5%E4%BB%A3%E7%90%86.html"/>
    <url>/%E4%BD%BF%E7%94%A8SSH%E5%8C%85%E8%A3%85Socks5%E4%BB%A3%E7%90%86.html</url>
    
    <content type="html"><![CDATA[<h1 id="subSocks简介"><a href="#subSocks简介" class="headerlink" title="subSocks简介"></a>subSocks简介</h1><p><a href="https://github.com/luyuhuang/subsocks">subSocks</a>是<a href="https://luyuhuang.tech/">Luyu Huang</a>制作的纯 Go 网络代理软件。</p><p>这里是作者本人对此项目的介绍<a href="https://luyuhuang.tech/2020/12/02/subsocks.html">文档</a>。</p><span id="more"></span><h1 id="为什么要做SSH包装"><a href="#为什么要做SSH包装" class="headerlink" title="为什么要做SSH包装"></a>为什么要做SSH包装</h1><p>因为之前使用v2ray总是被封端口，但是VPS上的22端口始终建在，考虑到SSH协议比较复杂，包括了Shell，SFTP等多种应用。我认为使用SSH协议包装流量可以起到一定的伪装作用，减少端口被封的可能性。</p><p>subSocks项目的代码结构非常漂亮，添加SSH包装非常便捷。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>首先需要了解subSocks的代码结构，Luyu Huang的<a href="https://luyuhuang.tech/2020/12/02/subsocks.html">文档</a>中描述的非常详细，我只需要实现SSHWarpper和SSHStripper。</p><p>Go 已经提供了SSH的官方实现，参考<a href="https://pkg.go.dev/golang.org/x/crypto/ssh">文档</a>。并且提供了使用SSH进行远程Shell的示例。</p><p>之后需要对SSH的<a href="/SSH.html">通讯过程</a>，<code>Session</code> <code>Channel</code> <code>Request</code>等等各种概念有基础的了解。</p><p>使用ssh包中的代码，在服务端使用TCP链接，创建SSH服务器，等待客户端链接后获取Channel，将Channel包装为Stripper。</p><p>客户端与服务端相似，需要使用TCP链接，向服务端完成握手过程，之后可获得Session，将Session包装成Wrapper。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>改动的源码请参考我 fork 的<a href="https://github.com/vitsumoc/subsocks">仓库</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>为了能够使用ssh协议进行代理，并且能支持密码和密钥认证，配置文件添加了一些字段</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure><div class="code-wrapper"><pre class="line-numbers language-toml" data-language="toml"><div class="caption"><span>client.toml</span></div><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">client</span><span class="token punctuation">]</span> <span class="token comment"># client configuration</span><span class="token key property">listen</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1:1080"</span><span class="token key property">username</span> <span class="token punctuation">=</span> <span class="token string">"subsocks"</span><span class="token key property">password</span> <span class="token punctuation">=</span> <span class="token string">"subsocks"</span><span class="token key property">server.protocol</span> <span class="token punctuation">=</span> <span class="token string">"ssh"</span><span class="token key property">server.address</span> <span class="token punctuation">=</span> <span class="token string">"127.0.0.1:22"</span><span class="token key property">ssh.key</span> <span class="token punctuation">=</span> <span class="token string">"./ssWithPass"</span><span class="token key property">ssh.passphrase</span> <span class="token punctuation">=</span> <span class="token string">"123123"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>server.protocol：当配置为 ssh 时使用 ssh 协议代理流量</li><li>username，password：这两个字段配置后，ssh协议可以使用账号密码的方式向服务端认证</li><li>ssh.key：配置后客户端可以使用密钥方式向服务端认证，这里配置客户端私钥文件，并把公钥文件存放在服务端</li><li>ssh.passphrase：如果私钥有密码的话，在这里配置</li><li>账号密码验证和密钥验证是选配的，配置其中一种或两者皆配置都可以。</li></ul><p>服务端</p><figure><div class="code-wrapper"><pre class="line-numbers language-toml" data-language="toml"><div class="caption"><span>server.toml</span></div><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">server</span><span class="token punctuation">]</span> <span class="token comment"># server configuration</span><span class="token key property">protocol</span> <span class="token punctuation">=</span> <span class="token string">"ssh"</span><span class="token key property">listen</span> <span class="token punctuation">=</span> <span class="token string">"0.0.0.0:22"</span><span class="token key property">ssh.key</span> <span class="token punctuation">=</span> <span class="token string">"./ssWithPass"</span><span class="token key property">ssh.passphrase</span> <span class="token punctuation">=</span> <span class="token string">"123123"</span><span class="token key property">ssh.cert</span> <span class="token punctuation">=</span> <span class="token string">"./ssWithPass.pub"</span><span class="token punctuation">[</span><span class="token table class-name">server.users</span><span class="token punctuation">]</span><span class="token key property">"subsocks"</span> <span class="token punctuation">=</span> <span class="token string">"subsocks"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>protocol ：当配置为 ssh 时使用 ssh 协议代理流量</li><li>ssh.key：服务端的 ssh 私钥路径，必填</li><li>ssh.passphrase：服务端 ssh 私钥的密码，有密码就填</li><li>[server.users]：支持的账号密码对，配合客户端的账号密码校验</li><li>ssh.cert： 客户端 ssh 公钥路径，用来支持客户端和服务端之间的密钥认证</li></ul><h1 id="SSH私钥加密的说明"><a href="#SSH私钥加密的说明" class="headerlink" title="SSH私钥加密的说明"></a>SSH私钥加密的说明</h1><p>由于 Go 中的ssh暂时还没有支持加密的PKCS#8 format，如果想要使用加密的私钥，需要选择PEM格式。可以用如下命令生成：</p><p>ssh-keygen -t rsa -b 4096 -m PEM<br>使用 ssh-keygen 的默认参数生成的带密码的私钥，在 ssh.ParsePrivateKeyWithPassphrase 过程中会报错。</p><p>情况参考：<a href="https://github.com/gaia-pipeline/gaia/issues/182#issuecomment-502120516">gaia-pipeline&#x2F;gaia#182 (comment)</a></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>通过抓包验证，握手过程正常，通讯过程与SSH相同，多条链接使用正常，所有数据均经过加密：</p><p><img src="/%E4%BD%BF%E7%94%A8SSH%E5%8C%85%E8%A3%85Socks5%E4%BB%A3%E7%90%86/wireshark.png"></p><p>使用 SSH 代理看了一会视频网站，效果也不错，很流畅。</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>SSH</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go与串口设备在项目中的运用</title>
    <link href="/Go%E4%B8%8E%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8.html"/>
    <url>/Go%E4%B8%8E%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="需求简述"><a href="#需求简述" class="headerlink" title="需求简述"></a>需求简述</h1><p>硬件设备使用485Modbus通讯，需使用 Go 编写采集程序，将数据采集至平台。</p><span id="more"></span><h1 id="方案简述"><a href="#方案简述" class="headerlink" title="方案简述"></a>方案简述</h1><p>使用串口服务器将485Modbus通讯转为TCPModbus，并将串口服务器设置为TCPserver。</p><p>使用 Go 编写采集器，定期向串口服务器建立TCP链接，采集数据。</p><h1 id="技术点与实现"><a href="#技术点与实现" class="headerlink" title="技术点与实现"></a>技术点与实现</h1><h2 id="点表"><a href="#点表" class="headerlink" title="点表"></a>点表</h2><p>通过<code>struct</code>实现点位表</p><p>这里使用Raw表示原始点表数据，和通讯协议一一对应</p><p>后续可将Raw结构封装至更高层的业务结构，用来实现业务数据的表示、嵌套能其他功能</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>go</span></div><code class="language-go"><span class="token keyword">type</span> StructMcuRaw <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Ver               <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">uint8</span> <span class="token string">`json:"ver"`</span>                                                                               <span class="token comment">// 软件版本[4]char</span>Id                <span class="token builtin">uint16</span>   <span class="token string">`json:"id"`</span>                                                                                <span class="token comment">// 通信箱id</span>TargetAngle       <span class="token builtin">uint16</span>   <span class="token string">`json:"targetAngle" IEC104:"yc" IEC104Name:"子阵目标角度" IEC104Unit:"°" IEC104Factor:"0.1"`</span> <span class="token comment">// 对整个子阵设置目标角度</span>InitSnowDepth     <span class="token builtin">uint16</span>   <span class="token string">`json:"initSnowDepth" IEC104:"yx" IEC104Name:"标定初始雪深标志"`</span>                              <span class="token comment">// 标定初始雪深标志</span>PrecipitationType <span class="token builtin">uint16</span>   <span class="token string">`json:"precipitationType"`</span>                                                                 <span class="token comment">// 降水类型</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="读取二进制数据"><a href="#读取二进制数据" class="headerlink" title="读取二进制数据"></a>读取二进制数据</h2><p>通过<code>binary</code>包，可以实现从buffer中读取数据向<code>struct</code>赋值</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>StructMcuRaw<span class="token punctuation">)</span> <span class="token function">MCUFromByte</span><span class="token punctuation">(</span>res <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 软件版本[4]char</span><span class="token keyword">for</span> x <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> x<span class="token operator">++</span> <span class="token punctuation">&#123;</span>binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Ver<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 通信箱id</span>binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>Id<span class="token punctuation">)</span><span class="token comment">// 对整个子阵设置目标角度</span>binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>TargetAngle<span class="token punctuation">)</span><span class="token comment">// 标定初始雪深标志</span>binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>InitSnowDepth<span class="token punctuation">)</span><span class="token comment">// 降水类型</span>binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">.</span>PrecipitationType<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="封装为query"><a href="#封装为query" class="headerlink" title="封装为query"></a>封装为query</h2><p>在本项目中，query指对单个设备的采集方法</p><p>将数据读取封装成query方法，包括TCP采集过程、日志记录、包格式处理等</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token function">MCUQuery</span><span class="token punctuation">(</span>conn <span class="token operator">*</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> reader <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">,</span> buffer <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> cb <span class="token operator">*</span>rs<span class="token punctuation">.</span>StructCommBox<span class="token punctuation">,</span> mcu <span class="token operator">*</span>rs<span class="token punctuation">.</span>StructMcu<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token comment">// 查询地址</span>addInt<span class="token punctuation">,</span> err <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>mcu<span class="token punctuation">.</span>Addr<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token comment">// 包编号</span>tcpSeq <span class="token operator">:=</span> <span class="token function">TcpSeq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> query <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token function">uint8</span><span class="token punctuation">(</span>tcpSeq <span class="token operator">/</span> <span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uint8</span><span class="token punctuation">(</span>tcpSeq <span class="token operator">%</span> <span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 编号</span><span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">,</span> <span class="token comment">// 长度</span><span class="token function">byte</span><span class="token punctuation">(</span>addInt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x03</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0xa0</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x29</span><span class="token punctuation">&#125;</span> <span class="token comment">// 指令</span><span class="token punctuation">(</span><span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetWriteDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span>QUERY_DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> cb<span class="token punctuation">.</span>IpAddr<span class="token punctuation">,</span> cb<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token comment">// 日志</span>log<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> cb<span class="token punctuation">.</span>IpAddr<span class="token punctuation">,</span> cb<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> query<span class="token punctuation">)</span><span class="token comment">// 接收</span><span class="token punctuation">(</span><span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span>QUERY_DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>reader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> cb<span class="token punctuation">.</span>IpAddr<span class="token punctuation">,</span> cb<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token comment">// 日志</span>log<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> cb<span class="token punctuation">.</span>IpAddr<span class="token punctuation">,</span> cb<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">// 解析</span>res <span class="token operator">:=</span> bytes<span class="token punctuation">.</span><span class="token function">NewBuffer</span><span class="token punctuation">(</span><span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token comment">// TCP头</span><span class="token keyword">var</span> tcpHeader rs<span class="token punctuation">.</span>StructTCPHeadertcpHeader<span class="token punctuation">.</span><span class="token function">TCPHeaderFromByte</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">if</span> tcpHeader<span class="token punctuation">.</span>Seq <span class="token operator">!=</span> tcpSeq <span class="token punctuation">&#123;</span><span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"TCP异常"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> tcpHeader<span class="token punctuation">.</span>Len <span class="token operator">!=</span> <span class="token number">85</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"TCP长度异常"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// modbus头</span><span class="token keyword">var</span> mbHeader rs<span class="token punctuation">.</span>StructMudbusHeadermbHeader<span class="token punctuation">.</span><span class="token function">MudbusHeaderFromByte</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment">// mcu内容</span>mcu<span class="token punctuation">.</span>Raw<span class="token punctuation">.</span><span class="token function">MCUFromByte</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>mcu<span class="token punctuation">.</span>VUpdate <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 标记更新</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="封装为采集过程"><a href="#封装为采集过程" class="headerlink" title="封装为采集过程"></a>封装为采集过程</h2><p>最后需要将所有的采集query放置在统一的采集过程中</p><p>在一次采集过程中，创建一条TCP链接，完成所有采集动作，最后断开链接</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><div class="caption"><span>go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token function">Collect</span><span class="token punctuation">(</span>cb <span class="token operator">*</span>rs<span class="token punctuation">.</span>StructCommBox<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 记录网络占用</span>NetCh <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">&lt;-</span>NetCh<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 初始化采集标识</span><span class="token function">eraseFlag</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token comment">// 采集结束后更新时标</span><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">updateTs</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 建链</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialTimeout</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> cb<span class="token punctuation">.</span>IpAddr<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>cb<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> rs<span class="token punctuation">.</span>QUERY_DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> cb<span class="token punctuation">.</span>IpAddr<span class="token punctuation">,</span> cb<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>cb<span class="token punctuation">.</span>VUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 读写缓存</span>readBuf <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>buffer <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token comment">// 按mcu查询</span><span class="token keyword">for</span> x <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>cb<span class="token punctuation">.</span>Mcus<span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token comment">// 切换MCU预留时间, 提高成功率</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span>QUERY_MCU_INTERVAL<span class="token punctuation">)</span><span class="token comment">// 查mcu信息</span>mcu <span class="token operator">:=</span> cb<span class="token punctuation">.</span>Mcus<span class="token punctuation">[</span>x<span class="token punctuation">]</span>err <span class="token operator">=</span> cmd<span class="token punctuation">.</span><span class="token function">MCUQuery</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conn<span class="token punctuation">,</span> readBuf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> mcu<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// 分次查跟踪器信息</span><span class="token keyword">for</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> mcu<span class="token punctuation">.</span>TracerNum<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span><span class="token comment">// 切换Tracer预留时间, 提高成功率</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span>QUERY_TRACER_INTERVAL<span class="token punctuation">)</span><span class="token comment">// 查询长度</span>tracerLen <span class="token operator">:=</span> rs<span class="token punctuation">.</span>QUERY_TRACER_COUNT<span class="token keyword">if</span> mcu<span class="token punctuation">.</span>TracerNum<span class="token operator">-</span>y <span class="token operator">&lt;</span> rs<span class="token punctuation">.</span>QUERY_TRACER_COUNT <span class="token punctuation">&#123;</span>tracerLen <span class="token operator">=</span> mcu<span class="token punctuation">.</span>TracerNum <span class="token operator">-</span> y<span class="token punctuation">&#125;</span>err <span class="token operator">=</span> cmd<span class="token punctuation">.</span><span class="token function">TracerQuery</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conn<span class="token punctuation">,</span> readBuf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> mcu<span class="token punctuation">,</span> y<span class="token punctuation">,</span> tracerLen<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>y <span class="token operator">+=</span> tracerLen<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Go + 串口服务器 进行串口通讯，非常的简单、直观，易于开发维护。</p><p>在本次项目实践中，由于 Go 提供了方便的并发编程与控制机制，高负载环境下的性能也得到了充分保障。</p>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>项目实践</tag>
      
      <tag>串口通讯</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH中的握手过程</title>
    <link href="/SSH%E4%B8%AD%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.html"/>
    <url>/SSH%E4%B8%AD%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<h1 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h1><p><a href="https://datatracker.ietf.org/doc/html/rfc4253">https://datatracker.ietf.org/doc/html/rfc4253</a></p><h1 id="SSH简介"><a href="#SSH简介" class="headerlink" title="SSH简介"></a>SSH简介</h1><p>安全外壳协议（Secure Shell Protocol，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。</p><span id="more"></span><h1 id="SSH数据包基本格式"><a href="#SSH数据包基本格式" class="headerlink" title="SSH数据包基本格式"></a>SSH数据包基本格式</h1><p>SSH的数据包加密后分块传输，每次传输的实际包长度都应为密码块大小的整数倍或8</p><p>每个加密后的数据包都由如下结构构成</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><div class="caption"><span>c</span></div><code class="language-c">uint32    packet_length<span class="token punctuation">;</span>byte      padding_length<span class="token punctuation">;</span>byte<span class="token punctuation">[</span>n1<span class="token punctuation">]</span>  payload<span class="token punctuation">;</span> <span class="token comment">// n1 = packet_length - padding_length - 1</span>byte<span class="token punctuation">[</span>n2<span class="token punctuation">]</span>  random_padding<span class="token punctuation">;</span> <span class="token comment">// n2 = padding_length</span>byte<span class="token punctuation">[</span>m<span class="token punctuation">]</span>   <span class="token function">mac</span><span class="token punctuation">(</span>Message_Authentication_Code <span class="token operator">-</span> MAC<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// m = mac_length</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><p>packet_length：数据载荷的长度，不包括<code>mac</code>部分和<code>packet_length</code>本身。在进行加密协商完成后，传输的<code>packet_length</code>也会被加密</p></li><li><p>padding_length：<code>random_padding</code>块的大小</p></li><li><p>payload：数据载荷，根绝协商决定被加密或被压缩的方法</p></li><li><p>random padding： 0-255位随机填充</p></li><li><p>mac：信息认证码，用作信息完整性校验</p></li></ul><h1 id="SSH过程"><a href="#SSH过程" class="headerlink" title="SSH过程"></a>SSH过程</h1><p>以下采用一个SSH抓包结果为例，描述SSH链接建立过程：</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><p>|&nbsp;&nbsp;&nbsp;客户端&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;服务端&nbsp;&nbsp;&nbsp;&nbsp;|</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;链接建立&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><p>|1. 三次握手1|—————————————————————————————–&gt;</p><p>&lt;—————————————————————————————-|2. 三次握手2|</p><p>|3. 三次握手3|—————————————————————————————–&gt;</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;协议协商&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><p>&lt;—————————————————————————————-|4. 服务端协议|</p><p>|5. 客户端协议|—————————————————————————————–&gt;</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;算法协商&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><p>&lt;————————————————————————————-|6. 服务端算法表|</p><p>|7. 客户端算法表|————————————————————————————&gt;</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;密钥交换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><p>|8. Diffie-Hellman Init|——————————————————————————&gt;</p><p>&lt;————————————————|9. Diffie-Hellman Reply，New Keys，加密包|</p><p>|10. New Keys|—————————————————————————————-&gt;</p><p>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加密通讯&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</p><h2 id="链接建立"><a href="#链接建立" class="headerlink" title="链接建立"></a>链接建立</h2><p>（1）（2）（3）三次握手报文</p><p><a href="https://zh.wikipedia.org/zh-hans/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP三次握手</a></p><h2 id="协议协商"><a href="#协议协商" class="headerlink" title="协议协商"></a>协议协商</h2><p>（4）服务端协议报文</p><p>Hex内容</p><blockquote><p>0x 53 53 48 2d 32 2e 30 2d 4f 70 65 6e 53 53 48 5f 38 2e 30 0d 0a</p></blockquote><p>报文内容</p><blockquote><p>SSH-2.0-OpenSSH_8.0&lt;CR&gt;&lt;LF&gt;</p></blockquote><p>包括SSH、协议版本（2.0）、软件版本（OpenSSH_8.0）</p><p>（5）客户端协议报文</p><p>Hex内容</p><blockquote><p>0x 53 53 48 2d 32 2e 30 2d 6e 73 73 73 68 32 5f 37 2e 30 2e 30 30 33 33 20 4e 65 74 53 61 72 61 6e 67 20 43 6f 6d 70 75 74 65 72 2c 20 49 6e 63 2e 0d 0a</p></blockquote><p>报文内容</p><blockquote><p>SSH-2.0-nsssh2_7.0.0033 NetSarang Computer, Inc.&lt;CR&gt;&lt;LF&gt;</p></blockquote><h2 id="算法协商"><a href="#算法协商" class="headerlink" title="算法协商"></a>算法协商</h2><p>在算法协商的过程中，双方会各自发送自己支持的算法列表，最终对以下几个算法达成共识：</p><ul><li>kex_algorithms：密钥交换算法</li><li>server_host_key_algorithms：公钥算法</li><li>encryption_algorithms：加密算法</li><li>mac_algorithms：数据完整性算法</li><li>compression_algorithms：压缩算法</li><li>languages：语言标签（可选）</li><li>first_kex_packet_follows：表示是否有猜测数据包</li></ul><p>在达成共识的过程中，基本以客户端中的算法排序优先匹配</p><p>（6）服务端算法表报文</p><ul><li>packet_length：0x00 00 04 14（1044）</li><li>padding_length：0x05（5）</li><li>SSH_MSG_SERVICE_ACCEPT：0x14（<code>SSH_MSG_KEXINIT</code>）</li><li>Cookie：0xd7 86 29 66…(16Byte)</li><li>kex_algorithms length：下方算法表长度</li><li>kex_algorithms list：算法表（字符串表示，逗号分隔）</li><li>server_host_key_algorithms length：下方算法表长度</li><li>server_host_key_algorithms list：算法表（字符串表示，逗号分隔）</li><li>encryption_algorithms_client_to_server length：下方算法表长度</li><li>encryption_algorithms_client_to_server list：算法表（字符串表示，逗号分隔）</li><li>encryption_algorithms_server_to_client length：下方算法表长度</li><li>encryption_algorithms_server_to_client list：算法表（字符串表示，逗号分隔）</li><li>mac_algorithms_client_to_server length：下方算法表长度</li><li>mac_algorithms_client_to_server list：算法表（字符串表示，逗号分隔）</li><li>mac_algorithms_server_to_client length：下方算法表长度</li><li>mac_algorithms_server_to_client list：算法表（字符串表示，逗号分隔）</li><li>compression_algorithms_client_to_server length：下方算法表长度</li><li>compression_algorithms_client_to_server list：算法表（字符串表示，逗号分隔）</li><li>compression_algorithms_server_to_client length：下方算法表长度</li><li>compression_algorithms_server_to_client list：算法表（字符串表示，逗号分隔）</li><li>languages_client_to_server length：下方算法表长度</li><li>languages_client_to_server list：算法表（字符串表示，逗号分隔）</li><li>languages_server_to_client length：下方算法表长度</li><li>languages_server_to_client list：算法表（字符串表示，逗号分隔）</li><li>first_kex_packet_follows：0x00</li><li>Reserved：0x00 00 00 00</li><li>Padding：0x00 00 00 00 00（<code>padding_length</code>长度）</li></ul><p>（7）客户端算法表报文</p><p>与服务端算法表格式相同</p><h2 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h2><p>通过双方协商，决定采用Elliptic Curve Diffie-Hellman方式进行密钥交换</p><p>（8）客户端Diffie-Hellman Init</p><ul><li>packet_length：0x00 00 00 2c</li><li>padding_length：0x06</li><li>MSG：0x1e（Elliptic Curve Diffie-Hellman Key Exchange Init）</li><li>客户端公钥长度：0x00 00 00 20（32）</li><li>客户端公钥：0xd1 d9 b8 6c 84 67 55 0f ca 84 6e 8b 0e 67 25 27 6b 50 ae ed a4 6d dc 0b 73 4c 15 ad e9 f5 51 66</li><li>Padding：0x91 f0 e8 0c f4 9b</li></ul><p>（9）服务端Diffie-Hellman Reply，New Keys，加密包</p><p>服务端的回复包含三部分内容，Key Exchange Reply、New Keys、 加密包</p><p>其中，Key Exchange Reply包括了密钥交换的结果</p><ul><li>packet_length：0x00 00 03 5c</li><li>padding_length：0x08</li><li>MSG：0x1f（Elliptic Curve Diffie-Hellman Key Exchange Reply）</li><li>Host Key Length：0x00 00 01 97</li><li>Host Key Type Length：0x00 00 00 07</li><li>Host Key Type：0x73 73 68 2d 72 73 21（ssh-rsa）</li><li>Multi Precision Integer Length：0x00 00 00 03</li><li>RSA public exponent (e)：0x01 00 01</li><li>Multi Precision Integer Length：0x00 00 01 81</li><li>RSA Modulus (N)：0x00 be 1b 4b 73 9d f8 37 0e 33…</li><li>ECDH server’s ephemeral public key length：0x00 00 00 20</li><li>ECDH server’s ephemeral public key (Q_S)：0x3a 2e 62 f6 ee…</li><li>KEX H signature length：0x00 00 01 8f</li><li>KEX H signature ：0x00 00 00 07 73 73 68 2d 72 73 61 00 00 01 80 a0…</li><li>Padding：0x00 00 00 00 00 00 00 00</li></ul><p>New Keys表示密钥交换完成，此后的内容都需要使用新密钥处理</p><ul><li>packet_length：0x00 00 00 0c</li><li>padding_length：0x0a</li><li>MSG：0x15（<code>SSH_MSG_NEWKEYS</code>）</li><li>Padding：0x00 00 00 00 00 00 00 00 00 00</li></ul><p>后续的数据已经被加密，无法查看内容，推测是与客户端进行登录认证的协商</p><p>（10）客户端New Keys</p><p>客户端的New Keys包与服务端相同，后续客户端发送数据也都被加密处理</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Windows中使用Linux——WSL</title>
    <link href="/%E5%9C%A8Windows%E4%B8%AD%E4%BD%BF%E7%94%A8Linux%E2%80%94%E2%80%94WSL.html"/>
    <url>/%E5%9C%A8Windows%E4%B8%AD%E4%BD%BF%E7%94%A8Linux%E2%80%94%E2%80%94WSL.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/">https://learn.microsoft.com/zh-cn/windows/wsl/</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>豆知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>豆知识</tag>
      
      <tag>环境配置</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
